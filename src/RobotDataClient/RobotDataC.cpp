/* RobotDataC.cpp
   Generated by gSOAP 2.8.16 from .\robotdata.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "RobotDataH.h"

namespace RobotData {

SOAP_SOURCE_STAMP("@(#) RobotDataC.cpp ver 2.8.16 2020-03-04 05:49:42 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_RobotData_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_RobotData_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_RobotData_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_RobotData_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_RobotData_ns3__ControlTaskType:
		return soap_in_ns3__ControlTaskType(soap, NULL, NULL, "ns3:ControlTaskType");
	case SOAP_TYPE_RobotData_ns3__PdControlType:
		return soap_in_ns3__PdControlType(soap, NULL, NULL, "ns3:PdControlType");
	case SOAP_TYPE_RobotData_ns3__LifterControlType:
		return soap_in_ns3__LifterControlType(soap, NULL, NULL, "ns3:LifterControlType");
	case SOAP_TYPE_RobotData_ns3__FilrControlType:
		return soap_in_ns3__FilrControlType(soap, NULL, NULL, "ns3:FilrControlType");
	case SOAP_TYPE_RobotData_ns3__WiperControlType:
		return soap_in_ns3__WiperControlType(soap, NULL, NULL, "ns3:WiperControlType");
	case SOAP_TYPE_RobotData_ns3__LightControlType:
		return soap_in_ns3__LightControlType(soap, NULL, NULL, "ns3:LightControlType");
	case SOAP_TYPE_RobotData_ns3__CameraControlType:
		return soap_in_ns3__CameraControlType(soap, NULL, NULL, "ns3:CameraControlType");
	case SOAP_TYPE_RobotData_ns3__YuntaiControlType:
		return soap_in_ns3__YuntaiControlType(soap, NULL, NULL, "ns3:YuntaiControlType");
	case SOAP_TYPE_RobotData_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfos:
		return soap_in_ns3__TaskExcuteInfos(soap, NULL, NULL, "ns3:TaskExcuteInfos");
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfo:
		return soap_in_ns3__TaskExcuteInfo(soap, NULL, NULL, "ns3:TaskExcuteInfo");
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfos:
		return soap_in_ns3__TaskFinishInfos(soap, NULL, NULL, "ns3:TaskFinishInfos");
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfo:
		return soap_in_ns3__TaskFinishInfo(soap, NULL, NULL, "ns3:TaskFinishInfo");
	case SOAP_TYPE_RobotData_ns3__TaskExcuteData:
		return soap_in_ns3__TaskExcuteData(soap, NULL, NULL, "ns3:TaskExcuteData");
	case SOAP_TYPE_RobotData_ns3__TaskPathInfos:
		return soap_in_ns3__TaskPathInfos(soap, NULL, NULL, "ns3:TaskPathInfos");
	case SOAP_TYPE_RobotData_ns3__TaskPathInfo:
		return soap_in_ns3__TaskPathInfo(soap, NULL, NULL, "ns3:TaskPathInfo");
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfos:
		return soap_in_ns3__PatrolPointInfos(soap, NULL, NULL, "ns3:PatrolPointInfos");
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfo:
		return soap_in_ns3__PatrolPointInfo(soap, NULL, NULL, "ns3:PatrolPointInfo");
	case SOAP_TYPE_RobotData_ns3__DockPointInfos:
		return soap_in_ns3__DockPointInfos(soap, NULL, NULL, "ns3:DockPointInfos");
	case SOAP_TYPE_RobotData_ns3__DockPointInfo:
		return soap_in_ns3__DockPointInfo(soap, NULL, NULL, "ns3:DockPointInfo");
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfos:
		return soap_in_ns3__MapEdgeInfos(soap, NULL, NULL, "ns3:MapEdgeInfos");
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfo:
		return soap_in_ns3__MapEdgeInfo(soap, NULL, NULL, "ns3:MapEdgeInfo");
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfos:
		return soap_in_ns3__PatrolAreaInfos(soap, NULL, NULL, "ns3:PatrolAreaInfos");
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfo:
		return soap_in_ns3__PatrolAreaInfo(soap, NULL, NULL, "ns3:PatrolAreaInfo");
	case SOAP_TYPE_RobotData_ns3__MapAreaInfos:
		return soap_in_ns3__MapAreaInfos(soap, NULL, NULL, "ns3:MapAreaInfos");
	case SOAP_TYPE_RobotData_ns3__MapAreaInfo:
		return soap_in_ns3__MapAreaInfo(soap, NULL, NULL, "ns3:MapAreaInfo");
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfos:
		return soap_in_ns3__RobotAlarmInfos(soap, NULL, NULL, "ns3:RobotAlarmInfos");
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfo:
		return soap_in_ns3__RobotAlarmInfo(soap, NULL, NULL, "ns3:RobotAlarmInfo");
	case SOAP_TYPE_RobotData_ns3__RobotGasInfos:
		return soap_in_ns3__RobotGasInfos(soap, NULL, NULL, "ns3:RobotGasInfos");
	case SOAP_TYPE_RobotData_ns3__RobotGasInfo:
		return soap_in_ns3__RobotGasInfo(soap, NULL, NULL, "ns3:RobotGasInfo");
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfos:
		return soap_in_ns3__RobotMileageInfos(soap, NULL, NULL, "ns3:RobotMileageInfos");
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfo:
		return soap_in_ns3__RobotMileageInfo(soap, NULL, NULL, "ns3:RobotMileageInfo");
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos:
		return soap_in_ns3__RobotYunTaiInfos(soap, NULL, NULL, "ns3:RobotYunTaiInfos");
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo:
		return soap_in_ns3__RobotYunTaiInfo(soap, NULL, NULL, "ns3:RobotYunTaiInfo");
	case SOAP_TYPE_RobotData_ns3__RobotPosInfos:
		return soap_in_ns3__RobotPosInfos(soap, NULL, NULL, "ns3:RobotPosInfos");
	case SOAP_TYPE_RobotData_ns3__RobotPosInfo:
		return soap_in_ns3__RobotPosInfo(soap, NULL, NULL, "ns3:RobotPosInfo");
	case SOAP_TYPE_RobotData_ns3__RobotTaskStates:
		return soap_in_ns3__RobotTaskStates(soap, NULL, NULL, "ns3:RobotTaskStates");
	case SOAP_TYPE_RobotData_ns3__RobotTaskState:
		return soap_in_ns3__RobotTaskState(soap, NULL, NULL, "ns3:RobotTaskState");
	case SOAP_TYPE_RobotData_ns3__SpeedInfos:
		return soap_in_ns3__SpeedInfos(soap, NULL, NULL, "ns3:SpeedInfos");
	case SOAP_TYPE_RobotData_ns3__SpeedInfo:
		return soap_in_ns3__SpeedInfo(soap, NULL, NULL, "ns3:SpeedInfo");
	case SOAP_TYPE_RobotData_ns3__BatteryInfos:
		return soap_in_ns3__BatteryInfos(soap, NULL, NULL, "ns3:BatteryInfos");
	case SOAP_TYPE_RobotData_ns3__BatteryInfo:
		return soap_in_ns3__BatteryInfo(soap, NULL, NULL, "ns3:BatteryInfo");
	case SOAP_TYPE_RobotData_ns3__RobotInfos:
		return soap_in_ns3__RobotInfos(soap, NULL, NULL, "ns3:RobotInfos");
	case SOAP_TYPE_RobotData_ns3__RobotInfo:
		return soap_in_ns3__RobotInfo(soap, NULL, NULL, "ns3:RobotInfo");
	case SOAP_TYPE_RobotData_ns3__ConnectInfos:
		return soap_in_ns3__ConnectInfos(soap, NULL, NULL, "ns3:ConnectInfos");
	case SOAP_TYPE_RobotData_ns3__ConnectInfo:
		return soap_in_ns3__ConnectInfo(soap, NULL, NULL, "ns3:ConnectInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotAlarmInfoResponse:
		return soap_in_PointerTo_ns3__GetRobotAlarmInfoResponse(soap, NULL, NULL, "ns3:GetRobotAlarmInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotAlarmInfo:
		return soap_in_PointerTo_ns3__GetRobotAlarmInfo(soap, NULL, NULL, "ns3:GetRobotAlarmInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotGasInfoResponse:
		return soap_in_PointerTo_ns3__GetRobotGasInfoResponse(soap, NULL, NULL, "ns3:GetRobotGasInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotGasInfo:
		return soap_in_PointerTo_ns3__GetRobotGasInfo(soap, NULL, NULL, "ns3:GetRobotGasInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotMileageInfoResponse:
		return soap_in_PointerTo_ns3__GetRobotMileageInfoResponse(soap, NULL, NULL, "ns3:GetRobotMileageInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotMileageInfo:
		return soap_in_PointerTo_ns3__GetRobotMileageInfo(soap, NULL, NULL, "ns3:GetRobotMileageInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotYunTaiInfoResponse:
		return soap_in_PointerTo_ns3__GetRobotYunTaiInfoResponse(soap, NULL, NULL, "ns3:GetRobotYunTaiInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotYunTaiInfo:
		return soap_in_PointerTo_ns3__GetRobotYunTaiInfo(soap, NULL, NULL, "ns3:GetRobotYunTaiInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotPosInfoResponse:
		return soap_in_PointerTo_ns3__GetRobotPosInfoResponse(soap, NULL, NULL, "ns3:GetRobotPosInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotPosInfo:
		return soap_in_PointerTo_ns3__GetRobotPosInfo(soap, NULL, NULL, "ns3:GetRobotPosInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTaskStateResponse:
		return soap_in_PointerTo_ns3__GetRobotTaskStateResponse(soap, NULL, NULL, "ns3:GetRobotTaskStateResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTaskState:
		return soap_in_PointerTo_ns3__GetRobotTaskState(soap, NULL, NULL, "ns3:GetRobotTaskState");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotSpeedInfoResponse:
		return soap_in_PointerTo_ns3__GetRobotSpeedInfoResponse(soap, NULL, NULL, "ns3:GetRobotSpeedInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotSpeedInfo:
		return soap_in_PointerTo_ns3__GetRobotSpeedInfo(soap, NULL, NULL, "ns3:GetRobotSpeedInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotBatteryInfoResponse:
		return soap_in_PointerTo_ns3__GetRobotBatteryInfoResponse(soap, NULL, NULL, "ns3:GetRobotBatteryInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotBatteryInfo:
		return soap_in_PointerTo_ns3__GetRobotBatteryInfo(soap, NULL, NULL, "ns3:GetRobotBatteryInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotPdControlResponse:
		return soap_in_PointerTo_ns3__RobotPdControlResponse(soap, NULL, NULL, "ns3:RobotPdControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotPdControl:
		return soap_in_PointerTo_ns3__RobotPdControl(soap, NULL, NULL, "ns3:RobotPdControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLifterControlResponse:
		return soap_in_PointerTo_ns3__RobotLifterControlResponse(soap, NULL, NULL, "ns3:RobotLifterControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLifterControl:
		return soap_in_PointerTo_ns3__RobotLifterControl(soap, NULL, NULL, "ns3:RobotLifterControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotFlirControlResponse:
		return soap_in_PointerTo_ns3__RobotFlirControlResponse(soap, NULL, NULL, "ns3:RobotFlirControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotFlirControl:
		return soap_in_PointerTo_ns3__RobotFlirControl(soap, NULL, NULL, "ns3:RobotFlirControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotWiperControlResponse:
		return soap_in_PointerTo_ns3__RobotWiperControlResponse(soap, NULL, NULL, "ns3:RobotWiperControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotWiperControl:
		return soap_in_PointerTo_ns3__RobotWiperControl(soap, NULL, NULL, "ns3:RobotWiperControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLightControlResponse:
		return soap_in_PointerTo_ns3__RobotLightControlResponse(soap, NULL, NULL, "ns3:RobotLightControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLightControl:
		return soap_in_PointerTo_ns3__RobotLightControl(soap, NULL, NULL, "ns3:RobotLightControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotCameraControlResponse:
		return soap_in_PointerTo_ns3__RobotCameraControlResponse(soap, NULL, NULL, "ns3:RobotCameraControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotCameraControl:
		return soap_in_PointerTo_ns3__RobotCameraControl(soap, NULL, NULL, "ns3:RobotCameraControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotYuntaiControlResponse:
		return soap_in_PointerTo_ns3__RobotYuntaiControlResponse(soap, NULL, NULL, "ns3:RobotYuntaiControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotYuntaiControl:
		return soap_in_PointerTo_ns3__RobotYuntaiControl(soap, NULL, NULL, "ns3:RobotYuntaiControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotSpeedControlResponse:
		return soap_in_PointerTo_ns3__RobotSpeedControlResponse(soap, NULL, NULL, "ns3:RobotSpeedControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotSpeedControl:
		return soap_in_PointerTo_ns3__RobotSpeedControl(soap, NULL, NULL, "ns3:RobotSpeedControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetControlModeResponse:
		return soap_in_PointerTo_ns3__GetControlModeResponse(soap, NULL, NULL, "ns3:GetControlModeResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetControlMode:
		return soap_in_PointerTo_ns3__GetControlMode(soap, NULL, NULL, "ns3:GetControlMode");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetControlModeResponse:
		return soap_in_PointerTo_ns3__SetControlModeResponse(soap, NULL, NULL, "ns3:SetControlModeResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetControlMode:
		return soap_in_PointerTo_ns3__SetControlMode(soap, NULL, NULL, "ns3:SetControlMode");
	case SOAP_TYPE_RobotData_PointerTo_ns3__ReleaseCurrentRobotResponse:
		return soap_in_PointerTo_ns3__ReleaseCurrentRobotResponse(soap, NULL, NULL, "ns3:ReleaseCurrentRobotResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__ReleaseCurrentRobot:
		return soap_in_PointerTo_ns3__ReleaseCurrentRobot(soap, NULL, NULL, "ns3:ReleaseCurrentRobot");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetCurrentRobotResponse:
		return soap_in_PointerTo_ns3__SetCurrentRobotResponse(soap, NULL, NULL, "ns3:SetCurrentRobotResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetCurrentRobot:
		return soap_in_PointerTo_ns3__SetCurrentRobot(soap, NULL, NULL, "ns3:SetCurrentRobot");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetRobotTimeResponse:
		return soap_in_PointerTo_ns3__SetRobotTimeResponse(soap, NULL, NULL, "ns3:SetRobotTimeResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetRobotTime:
		return soap_in_PointerTo_ns3__SetRobotTime(soap, NULL, NULL, "ns3:SetRobotTime");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTimeResponse:
		return soap_in_PointerTo_ns3__GetRobotTimeResponse(soap, NULL, NULL, "ns3:GetRobotTimeResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTime:
		return soap_in_PointerTo_ns3__GetRobotTime(soap, NULL, NULL, "ns3:GetRobotTime");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotInfoResponse:
		return soap_in_PointerTo_ns3__GetRobotInfoResponse(soap, NULL, NULL, "ns3:GetRobotInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotInfo:
		return soap_in_PointerTo_ns3__GetRobotInfo(soap, NULL, NULL, "ns3:GetRobotInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotConnectResponse:
		return soap_in_PointerTo_ns3__GetRobotConnectResponse(soap, NULL, NULL, "ns3:GetRobotConnectResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotConnect:
		return soap_in_PointerTo_ns3__GetRobotConnect(soap, NULL, NULL, "ns3:GetRobotConnect");
	case SOAP_TYPE_RobotData_PointerTons3__RobotAlarmInfos:
		return soap_in_PointerTons3__RobotAlarmInfos(soap, NULL, NULL, "ns3:RobotAlarmInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotGasInfos:
		return soap_in_PointerTons3__RobotGasInfos(soap, NULL, NULL, "ns3:RobotGasInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotMileageInfos:
		return soap_in_PointerTons3__RobotMileageInfos(soap, NULL, NULL, "ns3:RobotMileageInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotYunTaiInfos:
		return soap_in_PointerTons3__RobotYunTaiInfos(soap, NULL, NULL, "ns3:RobotYunTaiInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotPosInfos:
		return soap_in_PointerTons3__RobotPosInfos(soap, NULL, NULL, "ns3:RobotPosInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotTaskStates:
		return soap_in_PointerTons3__RobotTaskStates(soap, NULL, NULL, "ns3:RobotTaskStates");
	case SOAP_TYPE_RobotData_PointerTons3__SpeedInfos:
		return soap_in_PointerTons3__SpeedInfos(soap, NULL, NULL, "ns3:SpeedInfos");
	case SOAP_TYPE_RobotData_PointerTons3__BatteryInfos:
		return soap_in_PointerTons3__BatteryInfos(soap, NULL, NULL, "ns3:BatteryInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotInfos:
		return soap_in_PointerTons3__RobotInfos(soap, NULL, NULL, "ns3:RobotInfos");
	case SOAP_TYPE_RobotData_PointerTons3__ConnectInfos:
		return soap_in_PointerTons3__ConnectInfos(soap, NULL, NULL, "ns3:ConnectInfos");
	case SOAP_TYPE_RobotData_PointerTons3__TaskExcuteInfo:
		return soap_in_PointerTons3__TaskExcuteInfo(soap, NULL, NULL, "ns3:TaskExcuteInfo");
	case SOAP_TYPE_RobotData_PointerTons3__TaskFinishInfo:
		return soap_in_PointerTons3__TaskFinishInfo(soap, NULL, NULL, "ns3:TaskFinishInfo");
	case SOAP_TYPE_RobotData_PointerTons3__TaskPathInfo:
		return soap_in_PointerTons3__TaskPathInfo(soap, NULL, NULL, "ns3:TaskPathInfo");
	case SOAP_TYPE_RobotData_PointerTons3__PatrolPointInfo:
		return soap_in_PointerTons3__PatrolPointInfo(soap, NULL, NULL, "ns3:PatrolPointInfo");
	case SOAP_TYPE_RobotData_PointerTons3__DockPointInfo:
		return soap_in_PointerTons3__DockPointInfo(soap, NULL, NULL, "ns3:DockPointInfo");
	case SOAP_TYPE_RobotData_PointerTons3__MapEdgeInfo:
		return soap_in_PointerTons3__MapEdgeInfo(soap, NULL, NULL, "ns3:MapEdgeInfo");
	case SOAP_TYPE_RobotData_PointerTons3__PatrolAreaInfo:
		return soap_in_PointerTons3__PatrolAreaInfo(soap, NULL, NULL, "ns3:PatrolAreaInfo");
	case SOAP_TYPE_RobotData_PointerTons3__MapAreaInfo:
		return soap_in_PointerTons3__MapAreaInfo(soap, NULL, NULL, "ns3:MapAreaInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotAlarmInfo:
		return soap_in_PointerTons3__RobotAlarmInfo(soap, NULL, NULL, "ns3:RobotAlarmInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotGasInfo:
		return soap_in_PointerTons3__RobotGasInfo(soap, NULL, NULL, "ns3:RobotGasInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotMileageInfo:
		return soap_in_PointerTons3__RobotMileageInfo(soap, NULL, NULL, "ns3:RobotMileageInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotYunTaiInfo:
		return soap_in_PointerTons3__RobotYunTaiInfo(soap, NULL, NULL, "ns3:RobotYunTaiInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotPosInfo:
		return soap_in_PointerTons3__RobotPosInfo(soap, NULL, NULL, "ns3:RobotPosInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotTaskState:
		return soap_in_PointerTons3__RobotTaskState(soap, NULL, NULL, "ns3:RobotTaskState");
	case SOAP_TYPE_RobotData_PointerTons3__SpeedInfo:
		return soap_in_PointerTons3__SpeedInfo(soap, NULL, NULL, "ns3:SpeedInfo");
	case SOAP_TYPE_RobotData_PointerTons3__BatteryInfo:
		return soap_in_PointerTons3__BatteryInfo(soap, NULL, NULL, "ns3:BatteryInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotInfo:
		return soap_in_PointerTons3__RobotInfo(soap, NULL, NULL, "ns3:RobotInfo");
	case SOAP_TYPE_RobotData_PointerTons3__ConnectInfo:
		return soap_in_PointerTons3__ConnectInfo(soap, NULL, NULL, "ns3:ConnectInfo");
	case SOAP_TYPE_RobotData__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_RobotData_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_RobotData_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskExcuteInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__TaskExcuteInfos;
			return soap_in_ns3__TaskExcuteInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskExcuteInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__TaskExcuteInfo;
			return soap_in_ns3__TaskExcuteInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskFinishInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__TaskFinishInfos;
			return soap_in_ns3__TaskFinishInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskFinishInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__TaskFinishInfo;
			return soap_in_ns3__TaskFinishInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskExcuteData"))
		{	*type = SOAP_TYPE_RobotData_ns3__TaskExcuteData;
			return soap_in_ns3__TaskExcuteData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskPathInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__TaskPathInfos;
			return soap_in_ns3__TaskPathInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskPathInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__TaskPathInfo;
			return soap_in_ns3__TaskPathInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PatrolPointInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__PatrolPointInfos;
			return soap_in_ns3__PatrolPointInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PatrolPointInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__PatrolPointInfo;
			return soap_in_ns3__PatrolPointInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DockPointInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__DockPointInfos;
			return soap_in_ns3__DockPointInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DockPointInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__DockPointInfo;
			return soap_in_ns3__DockPointInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MapEdgeInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__MapEdgeInfos;
			return soap_in_ns3__MapEdgeInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MapEdgeInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__MapEdgeInfo;
			return soap_in_ns3__MapEdgeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PatrolAreaInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__PatrolAreaInfos;
			return soap_in_ns3__PatrolAreaInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PatrolAreaInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__PatrolAreaInfo;
			return soap_in_ns3__PatrolAreaInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MapAreaInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__MapAreaInfos;
			return soap_in_ns3__MapAreaInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MapAreaInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__MapAreaInfo;
			return soap_in_ns3__MapAreaInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotAlarmInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotAlarmInfos;
			return soap_in_ns3__RobotAlarmInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotAlarmInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotAlarmInfo;
			return soap_in_ns3__RobotAlarmInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotGasInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotGasInfos;
			return soap_in_ns3__RobotGasInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotGasInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotGasInfo;
			return soap_in_ns3__RobotGasInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotMileageInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotMileageInfos;
			return soap_in_ns3__RobotMileageInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotMileageInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotMileageInfo;
			return soap_in_ns3__RobotMileageInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotYunTaiInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos;
			return soap_in_ns3__RobotYunTaiInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotYunTaiInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo;
			return soap_in_ns3__RobotYunTaiInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotPosInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotPosInfos;
			return soap_in_ns3__RobotPosInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotPosInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotPosInfo;
			return soap_in_ns3__RobotPosInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotTaskStates"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotTaskStates;
			return soap_in_ns3__RobotTaskStates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotTaskState"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotTaskState;
			return soap_in_ns3__RobotTaskState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SpeedInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__SpeedInfos;
			return soap_in_ns3__SpeedInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SpeedInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__SpeedInfo;
			return soap_in_ns3__SpeedInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:BatteryInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__BatteryInfos;
			return soap_in_ns3__BatteryInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:BatteryInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__BatteryInfo;
			return soap_in_ns3__BatteryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotInfos;
			return soap_in_ns3__RobotInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__RobotInfo;
			return soap_in_ns3__RobotInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ConnectInfos"))
		{	*type = SOAP_TYPE_RobotData_ns3__ConnectInfos;
			return soap_in_ns3__ConnectInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ConnectInfo"))
		{	*type = SOAP_TYPE_RobotData_ns3__ConnectInfo;
			return soap_in_ns3__ConnectInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_RobotData_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_RobotData_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_RobotData_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_RobotData_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ControlTaskType"))
		{	*type = SOAP_TYPE_RobotData_ns3__ControlTaskType;
			return soap_in_ns3__ControlTaskType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PdControlType"))
		{	*type = SOAP_TYPE_RobotData_ns3__PdControlType;
			return soap_in_ns3__PdControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LifterControlType"))
		{	*type = SOAP_TYPE_RobotData_ns3__LifterControlType;
			return soap_in_ns3__LifterControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FilrControlType"))
		{	*type = SOAP_TYPE_RobotData_ns3__FilrControlType;
			return soap_in_ns3__FilrControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:WiperControlType"))
		{	*type = SOAP_TYPE_RobotData_ns3__WiperControlType;
			return soap_in_ns3__WiperControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LightControlType"))
		{	*type = SOAP_TYPE_RobotData_ns3__LightControlType;
			return soap_in_ns3__LightControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CameraControlType"))
		{	*type = SOAP_TYPE_RobotData_ns3__CameraControlType;
			return soap_in_ns3__CameraControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:YuntaiControlType"))
		{	*type = SOAP_TYPE_RobotData_ns3__YuntaiControlType;
			return soap_in_ns3__YuntaiControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_RobotData__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_RobotData_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:GetRobotAlarmInfoResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse;
			return soap_in__ns3__GetRobotAlarmInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotAlarmInfo"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo;
			return soap_in__ns3__GetRobotAlarmInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotGasInfoResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse;
			return soap_in__ns3__GetRobotGasInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotGasInfo"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotGasInfo;
			return soap_in__ns3__GetRobotGasInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotMileageInfoResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse;
			return soap_in__ns3__GetRobotMileageInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotMileageInfo"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo;
			return soap_in__ns3__GetRobotMileageInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotYunTaiInfoResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse;
			return soap_in__ns3__GetRobotYunTaiInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotYunTaiInfo"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo;
			return soap_in__ns3__GetRobotYunTaiInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotPosInfoResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse;
			return soap_in__ns3__GetRobotPosInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotPosInfo"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotPosInfo;
			return soap_in__ns3__GetRobotPosInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotTaskStateResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse;
			return soap_in__ns3__GetRobotTaskStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotTaskState"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotTaskState;
			return soap_in__ns3__GetRobotTaskState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotSpeedInfoResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse;
			return soap_in__ns3__GetRobotSpeedInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotSpeedInfo"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo;
			return soap_in__ns3__GetRobotSpeedInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotBatteryInfoResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse;
			return soap_in__ns3__GetRobotBatteryInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotBatteryInfo"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo;
			return soap_in__ns3__GetRobotBatteryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotPdControlResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotPdControlResponse;
			return soap_in__ns3__RobotPdControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotPdControl"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotPdControl;
			return soap_in__ns3__RobotPdControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotLifterControlResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse;
			return soap_in__ns3__RobotLifterControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotLifterControl"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotLifterControl;
			return soap_in__ns3__RobotLifterControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotFlirControlResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse;
			return soap_in__ns3__RobotFlirControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotFlirControl"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotFlirControl;
			return soap_in__ns3__RobotFlirControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotWiperControlResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse;
			return soap_in__ns3__RobotWiperControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotWiperControl"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotWiperControl;
			return soap_in__ns3__RobotWiperControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotLightControlResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotLightControlResponse;
			return soap_in__ns3__RobotLightControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotLightControl"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotLightControl;
			return soap_in__ns3__RobotLightControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotCameraControlResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse;
			return soap_in__ns3__RobotCameraControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotCameraControl"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotCameraControl;
			return soap_in__ns3__RobotCameraControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotYuntaiControlResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse;
			return soap_in__ns3__RobotYuntaiControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotYuntaiControl"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotYuntaiControl;
			return soap_in__ns3__RobotYuntaiControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotSpeedControlResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse;
			return soap_in__ns3__RobotSpeedControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RobotSpeedControl"))
		{	*type = SOAP_TYPE_RobotData__ns3__RobotSpeedControl;
			return soap_in__ns3__RobotSpeedControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetControlModeResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetControlModeResponse;
			return soap_in__ns3__GetControlModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetControlMode"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetControlMode;
			return soap_in__ns3__GetControlMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SetControlModeResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__SetControlModeResponse;
			return soap_in__ns3__SetControlModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SetControlMode"))
		{	*type = SOAP_TYPE_RobotData__ns3__SetControlMode;
			return soap_in__ns3__SetControlMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ReleaseCurrentRobotResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse;
			return soap_in__ns3__ReleaseCurrentRobotResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ReleaseCurrentRobot"))
		{	*type = SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot;
			return soap_in__ns3__ReleaseCurrentRobot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SetCurrentRobotResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse;
			return soap_in__ns3__SetCurrentRobotResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SetCurrentRobot"))
		{	*type = SOAP_TYPE_RobotData__ns3__SetCurrentRobot;
			return soap_in__ns3__SetCurrentRobot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SetRobotTimeResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse;
			return soap_in__ns3__SetRobotTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SetRobotTime"))
		{	*type = SOAP_TYPE_RobotData__ns3__SetRobotTime;
			return soap_in__ns3__SetRobotTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotTimeResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse;
			return soap_in__ns3__GetRobotTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotTime"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotTime;
			return soap_in__ns3__GetRobotTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotInfoResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse;
			return soap_in__ns3__GetRobotInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotInfo"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotInfo;
			return soap_in__ns3__GetRobotInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotConnectResponse"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse;
			return soap_in__ns3__GetRobotConnectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRobotConnect"))
		{	*type = SOAP_TYPE_RobotData__ns3__GetRobotConnect;
			return soap_in__ns3__GetRobotConnect(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_RobotData_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_RobotData_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_RobotData_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_RobotData_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_RobotData_ns3__ControlTaskType:
		return soap_out_ns3__ControlTaskType(soap, tag, id, (const enum ns3__ControlTaskType *)ptr, "ns3:ControlTaskType");
	case SOAP_TYPE_RobotData_ns3__PdControlType:
		return soap_out_ns3__PdControlType(soap, tag, id, (const enum ns3__PdControlType *)ptr, "ns3:PdControlType");
	case SOAP_TYPE_RobotData_ns3__LifterControlType:
		return soap_out_ns3__LifterControlType(soap, tag, id, (const enum ns3__LifterControlType *)ptr, "ns3:LifterControlType");
	case SOAP_TYPE_RobotData_ns3__FilrControlType:
		return soap_out_ns3__FilrControlType(soap, tag, id, (const enum ns3__FilrControlType *)ptr, "ns3:FilrControlType");
	case SOAP_TYPE_RobotData_ns3__WiperControlType:
		return soap_out_ns3__WiperControlType(soap, tag, id, (const enum ns3__WiperControlType *)ptr, "ns3:WiperControlType");
	case SOAP_TYPE_RobotData_ns3__LightControlType:
		return soap_out_ns3__LightControlType(soap, tag, id, (const enum ns3__LightControlType *)ptr, "ns3:LightControlType");
	case SOAP_TYPE_RobotData_ns3__CameraControlType:
		return soap_out_ns3__CameraControlType(soap, tag, id, (const enum ns3__CameraControlType *)ptr, "ns3:CameraControlType");
	case SOAP_TYPE_RobotData_ns3__YuntaiControlType:
		return soap_out_ns3__YuntaiControlType(soap, tag, id, (const enum ns3__YuntaiControlType *)ptr, "ns3:YuntaiControlType");
	case SOAP_TYPE_RobotData_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse:
		return ((_ns3__GetRobotAlarmInfoResponse *)ptr)->soap_out(soap, "ns3:GetRobotAlarmInfoResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo:
		return ((_ns3__GetRobotAlarmInfo *)ptr)->soap_out(soap, "ns3:GetRobotAlarmInfo", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse:
		return ((_ns3__GetRobotGasInfoResponse *)ptr)->soap_out(soap, "ns3:GetRobotGasInfoResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotGasInfo:
		return ((_ns3__GetRobotGasInfo *)ptr)->soap_out(soap, "ns3:GetRobotGasInfo", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse:
		return ((_ns3__GetRobotMileageInfoResponse *)ptr)->soap_out(soap, "ns3:GetRobotMileageInfoResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo:
		return ((_ns3__GetRobotMileageInfo *)ptr)->soap_out(soap, "ns3:GetRobotMileageInfo", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse:
		return ((_ns3__GetRobotYunTaiInfoResponse *)ptr)->soap_out(soap, "ns3:GetRobotYunTaiInfoResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo:
		return ((_ns3__GetRobotYunTaiInfo *)ptr)->soap_out(soap, "ns3:GetRobotYunTaiInfo", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse:
		return ((_ns3__GetRobotPosInfoResponse *)ptr)->soap_out(soap, "ns3:GetRobotPosInfoResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotPosInfo:
		return ((_ns3__GetRobotPosInfo *)ptr)->soap_out(soap, "ns3:GetRobotPosInfo", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse:
		return ((_ns3__GetRobotTaskStateResponse *)ptr)->soap_out(soap, "ns3:GetRobotTaskStateResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotTaskState:
		return ((_ns3__GetRobotTaskState *)ptr)->soap_out(soap, "ns3:GetRobotTaskState", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse:
		return ((_ns3__GetRobotSpeedInfoResponse *)ptr)->soap_out(soap, "ns3:GetRobotSpeedInfoResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo:
		return ((_ns3__GetRobotSpeedInfo *)ptr)->soap_out(soap, "ns3:GetRobotSpeedInfo", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse:
		return ((_ns3__GetRobotBatteryInfoResponse *)ptr)->soap_out(soap, "ns3:GetRobotBatteryInfoResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo:
		return ((_ns3__GetRobotBatteryInfo *)ptr)->soap_out(soap, "ns3:GetRobotBatteryInfo", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotPdControlResponse:
		return ((_ns3__RobotPdControlResponse *)ptr)->soap_out(soap, "ns3:RobotPdControlResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotPdControl:
		return ((_ns3__RobotPdControl *)ptr)->soap_out(soap, "ns3:RobotPdControl", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse:
		return ((_ns3__RobotLifterControlResponse *)ptr)->soap_out(soap, "ns3:RobotLifterControlResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotLifterControl:
		return ((_ns3__RobotLifterControl *)ptr)->soap_out(soap, "ns3:RobotLifterControl", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse:
		return ((_ns3__RobotFlirControlResponse *)ptr)->soap_out(soap, "ns3:RobotFlirControlResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotFlirControl:
		return ((_ns3__RobotFlirControl *)ptr)->soap_out(soap, "ns3:RobotFlirControl", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse:
		return ((_ns3__RobotWiperControlResponse *)ptr)->soap_out(soap, "ns3:RobotWiperControlResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotWiperControl:
		return ((_ns3__RobotWiperControl *)ptr)->soap_out(soap, "ns3:RobotWiperControl", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotLightControlResponse:
		return ((_ns3__RobotLightControlResponse *)ptr)->soap_out(soap, "ns3:RobotLightControlResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotLightControl:
		return ((_ns3__RobotLightControl *)ptr)->soap_out(soap, "ns3:RobotLightControl", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse:
		return ((_ns3__RobotCameraControlResponse *)ptr)->soap_out(soap, "ns3:RobotCameraControlResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotCameraControl:
		return ((_ns3__RobotCameraControl *)ptr)->soap_out(soap, "ns3:RobotCameraControl", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse:
		return ((_ns3__RobotYuntaiControlResponse *)ptr)->soap_out(soap, "ns3:RobotYuntaiControlResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotYuntaiControl:
		return ((_ns3__RobotYuntaiControl *)ptr)->soap_out(soap, "ns3:RobotYuntaiControl", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse:
		return ((_ns3__RobotSpeedControlResponse *)ptr)->soap_out(soap, "ns3:RobotSpeedControlResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__RobotSpeedControl:
		return ((_ns3__RobotSpeedControl *)ptr)->soap_out(soap, "ns3:RobotSpeedControl", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetControlModeResponse:
		return ((_ns3__GetControlModeResponse *)ptr)->soap_out(soap, "ns3:GetControlModeResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetControlMode:
		return ((_ns3__GetControlMode *)ptr)->soap_out(soap, "ns3:GetControlMode", id, NULL);
	case SOAP_TYPE_RobotData__ns3__SetControlModeResponse:
		return ((_ns3__SetControlModeResponse *)ptr)->soap_out(soap, "ns3:SetControlModeResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__SetControlMode:
		return ((_ns3__SetControlMode *)ptr)->soap_out(soap, "ns3:SetControlMode", id, NULL);
	case SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse:
		return ((_ns3__ReleaseCurrentRobotResponse *)ptr)->soap_out(soap, "ns3:ReleaseCurrentRobotResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot:
		return ((_ns3__ReleaseCurrentRobot *)ptr)->soap_out(soap, "ns3:ReleaseCurrentRobot", id, NULL);
	case SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse:
		return ((_ns3__SetCurrentRobotResponse *)ptr)->soap_out(soap, "ns3:SetCurrentRobotResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__SetCurrentRobot:
		return ((_ns3__SetCurrentRobot *)ptr)->soap_out(soap, "ns3:SetCurrentRobot", id, NULL);
	case SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse:
		return ((_ns3__SetRobotTimeResponse *)ptr)->soap_out(soap, "ns3:SetRobotTimeResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__SetRobotTime:
		return ((_ns3__SetRobotTime *)ptr)->soap_out(soap, "ns3:SetRobotTime", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse:
		return ((_ns3__GetRobotTimeResponse *)ptr)->soap_out(soap, "ns3:GetRobotTimeResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotTime:
		return ((_ns3__GetRobotTime *)ptr)->soap_out(soap, "ns3:GetRobotTime", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse:
		return ((_ns3__GetRobotInfoResponse *)ptr)->soap_out(soap, "ns3:GetRobotInfoResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotInfo:
		return ((_ns3__GetRobotInfo *)ptr)->soap_out(soap, "ns3:GetRobotInfo", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse:
		return ((_ns3__GetRobotConnectResponse *)ptr)->soap_out(soap, "ns3:GetRobotConnectResponse", id, NULL);
	case SOAP_TYPE_RobotData__ns3__GetRobotConnect:
		return ((_ns3__GetRobotConnect *)ptr)->soap_out(soap, "ns3:GetRobotConnect", id, NULL);
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfos:
		return ((ns3__TaskExcuteInfos *)ptr)->soap_out(soap, tag, id, "ns3:TaskExcuteInfos");
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfo:
		return ((ns3__TaskExcuteInfo *)ptr)->soap_out(soap, tag, id, "ns3:TaskExcuteInfo");
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfos:
		return ((ns3__TaskFinishInfos *)ptr)->soap_out(soap, tag, id, "ns3:TaskFinishInfos");
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfo:
		return ((ns3__TaskFinishInfo *)ptr)->soap_out(soap, tag, id, "ns3:TaskFinishInfo");
	case SOAP_TYPE_RobotData_ns3__TaskExcuteData:
		return ((ns3__TaskExcuteData *)ptr)->soap_out(soap, tag, id, "ns3:TaskExcuteData");
	case SOAP_TYPE_RobotData_ns3__TaskPathInfos:
		return ((ns3__TaskPathInfos *)ptr)->soap_out(soap, tag, id, "ns3:TaskPathInfos");
	case SOAP_TYPE_RobotData_ns3__TaskPathInfo:
		return ((ns3__TaskPathInfo *)ptr)->soap_out(soap, tag, id, "ns3:TaskPathInfo");
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfos:
		return ((ns3__PatrolPointInfos *)ptr)->soap_out(soap, tag, id, "ns3:PatrolPointInfos");
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfo:
		return ((ns3__PatrolPointInfo *)ptr)->soap_out(soap, tag, id, "ns3:PatrolPointInfo");
	case SOAP_TYPE_RobotData_ns3__DockPointInfos:
		return ((ns3__DockPointInfos *)ptr)->soap_out(soap, tag, id, "ns3:DockPointInfos");
	case SOAP_TYPE_RobotData_ns3__DockPointInfo:
		return ((ns3__DockPointInfo *)ptr)->soap_out(soap, tag, id, "ns3:DockPointInfo");
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfos:
		return ((ns3__MapEdgeInfos *)ptr)->soap_out(soap, tag, id, "ns3:MapEdgeInfos");
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfo:
		return ((ns3__MapEdgeInfo *)ptr)->soap_out(soap, tag, id, "ns3:MapEdgeInfo");
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfos:
		return ((ns3__PatrolAreaInfos *)ptr)->soap_out(soap, tag, id, "ns3:PatrolAreaInfos");
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfo:
		return ((ns3__PatrolAreaInfo *)ptr)->soap_out(soap, tag, id, "ns3:PatrolAreaInfo");
	case SOAP_TYPE_RobotData_ns3__MapAreaInfos:
		return ((ns3__MapAreaInfos *)ptr)->soap_out(soap, tag, id, "ns3:MapAreaInfos");
	case SOAP_TYPE_RobotData_ns3__MapAreaInfo:
		return ((ns3__MapAreaInfo *)ptr)->soap_out(soap, tag, id, "ns3:MapAreaInfo");
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfos:
		return ((ns3__RobotAlarmInfos *)ptr)->soap_out(soap, tag, id, "ns3:RobotAlarmInfos");
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfo:
		return ((ns3__RobotAlarmInfo *)ptr)->soap_out(soap, tag, id, "ns3:RobotAlarmInfo");
	case SOAP_TYPE_RobotData_ns3__RobotGasInfos:
		return ((ns3__RobotGasInfos *)ptr)->soap_out(soap, tag, id, "ns3:RobotGasInfos");
	case SOAP_TYPE_RobotData_ns3__RobotGasInfo:
		return ((ns3__RobotGasInfo *)ptr)->soap_out(soap, tag, id, "ns3:RobotGasInfo");
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfos:
		return ((ns3__RobotMileageInfos *)ptr)->soap_out(soap, tag, id, "ns3:RobotMileageInfos");
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfo:
		return ((ns3__RobotMileageInfo *)ptr)->soap_out(soap, tag, id, "ns3:RobotMileageInfo");
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos:
		return ((ns3__RobotYunTaiInfos *)ptr)->soap_out(soap, tag, id, "ns3:RobotYunTaiInfos");
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo:
		return ((ns3__RobotYunTaiInfo *)ptr)->soap_out(soap, tag, id, "ns3:RobotYunTaiInfo");
	case SOAP_TYPE_RobotData_ns3__RobotPosInfos:
		return ((ns3__RobotPosInfos *)ptr)->soap_out(soap, tag, id, "ns3:RobotPosInfos");
	case SOAP_TYPE_RobotData_ns3__RobotPosInfo:
		return ((ns3__RobotPosInfo *)ptr)->soap_out(soap, tag, id, "ns3:RobotPosInfo");
	case SOAP_TYPE_RobotData_ns3__RobotTaskStates:
		return ((ns3__RobotTaskStates *)ptr)->soap_out(soap, tag, id, "ns3:RobotTaskStates");
	case SOAP_TYPE_RobotData_ns3__RobotTaskState:
		return ((ns3__RobotTaskState *)ptr)->soap_out(soap, tag, id, "ns3:RobotTaskState");
	case SOAP_TYPE_RobotData_ns3__SpeedInfos:
		return ((ns3__SpeedInfos *)ptr)->soap_out(soap, tag, id, "ns3:SpeedInfos");
	case SOAP_TYPE_RobotData_ns3__SpeedInfo:
		return ((ns3__SpeedInfo *)ptr)->soap_out(soap, tag, id, "ns3:SpeedInfo");
	case SOAP_TYPE_RobotData_ns3__BatteryInfos:
		return ((ns3__BatteryInfos *)ptr)->soap_out(soap, tag, id, "ns3:BatteryInfos");
	case SOAP_TYPE_RobotData_ns3__BatteryInfo:
		return ((ns3__BatteryInfo *)ptr)->soap_out(soap, tag, id, "ns3:BatteryInfo");
	case SOAP_TYPE_RobotData_ns3__RobotInfos:
		return ((ns3__RobotInfos *)ptr)->soap_out(soap, tag, id, "ns3:RobotInfos");
	case SOAP_TYPE_RobotData_ns3__RobotInfo:
		return ((ns3__RobotInfo *)ptr)->soap_out(soap, tag, id, "ns3:RobotInfo");
	case SOAP_TYPE_RobotData_ns3__ConnectInfos:
		return ((ns3__ConnectInfos *)ptr)->soap_out(soap, tag, id, "ns3:ConnectInfos");
	case SOAP_TYPE_RobotData_ns3__ConnectInfo:
		return ((ns3__ConnectInfo *)ptr)->soap_out(soap, tag, id, "ns3:ConnectInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotAlarmInfoResponse:
		return soap_out_PointerTo_ns3__GetRobotAlarmInfoResponse(soap, tag, id, (_ns3__GetRobotAlarmInfoResponse *const*)ptr, "ns3:GetRobotAlarmInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotAlarmInfo:
		return soap_out_PointerTo_ns3__GetRobotAlarmInfo(soap, tag, id, (_ns3__GetRobotAlarmInfo *const*)ptr, "ns3:GetRobotAlarmInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotGasInfoResponse:
		return soap_out_PointerTo_ns3__GetRobotGasInfoResponse(soap, tag, id, (_ns3__GetRobotGasInfoResponse *const*)ptr, "ns3:GetRobotGasInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotGasInfo:
		return soap_out_PointerTo_ns3__GetRobotGasInfo(soap, tag, id, (_ns3__GetRobotGasInfo *const*)ptr, "ns3:GetRobotGasInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotMileageInfoResponse:
		return soap_out_PointerTo_ns3__GetRobotMileageInfoResponse(soap, tag, id, (_ns3__GetRobotMileageInfoResponse *const*)ptr, "ns3:GetRobotMileageInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotMileageInfo:
		return soap_out_PointerTo_ns3__GetRobotMileageInfo(soap, tag, id, (_ns3__GetRobotMileageInfo *const*)ptr, "ns3:GetRobotMileageInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotYunTaiInfoResponse:
		return soap_out_PointerTo_ns3__GetRobotYunTaiInfoResponse(soap, tag, id, (_ns3__GetRobotYunTaiInfoResponse *const*)ptr, "ns3:GetRobotYunTaiInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotYunTaiInfo:
		return soap_out_PointerTo_ns3__GetRobotYunTaiInfo(soap, tag, id, (_ns3__GetRobotYunTaiInfo *const*)ptr, "ns3:GetRobotYunTaiInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotPosInfoResponse:
		return soap_out_PointerTo_ns3__GetRobotPosInfoResponse(soap, tag, id, (_ns3__GetRobotPosInfoResponse *const*)ptr, "ns3:GetRobotPosInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotPosInfo:
		return soap_out_PointerTo_ns3__GetRobotPosInfo(soap, tag, id, (_ns3__GetRobotPosInfo *const*)ptr, "ns3:GetRobotPosInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTaskStateResponse:
		return soap_out_PointerTo_ns3__GetRobotTaskStateResponse(soap, tag, id, (_ns3__GetRobotTaskStateResponse *const*)ptr, "ns3:GetRobotTaskStateResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTaskState:
		return soap_out_PointerTo_ns3__GetRobotTaskState(soap, tag, id, (_ns3__GetRobotTaskState *const*)ptr, "ns3:GetRobotTaskState");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotSpeedInfoResponse:
		return soap_out_PointerTo_ns3__GetRobotSpeedInfoResponse(soap, tag, id, (_ns3__GetRobotSpeedInfoResponse *const*)ptr, "ns3:GetRobotSpeedInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotSpeedInfo:
		return soap_out_PointerTo_ns3__GetRobotSpeedInfo(soap, tag, id, (_ns3__GetRobotSpeedInfo *const*)ptr, "ns3:GetRobotSpeedInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotBatteryInfoResponse:
		return soap_out_PointerTo_ns3__GetRobotBatteryInfoResponse(soap, tag, id, (_ns3__GetRobotBatteryInfoResponse *const*)ptr, "ns3:GetRobotBatteryInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotBatteryInfo:
		return soap_out_PointerTo_ns3__GetRobotBatteryInfo(soap, tag, id, (_ns3__GetRobotBatteryInfo *const*)ptr, "ns3:GetRobotBatteryInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotPdControlResponse:
		return soap_out_PointerTo_ns3__RobotPdControlResponse(soap, tag, id, (_ns3__RobotPdControlResponse *const*)ptr, "ns3:RobotPdControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotPdControl:
		return soap_out_PointerTo_ns3__RobotPdControl(soap, tag, id, (_ns3__RobotPdControl *const*)ptr, "ns3:RobotPdControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLifterControlResponse:
		return soap_out_PointerTo_ns3__RobotLifterControlResponse(soap, tag, id, (_ns3__RobotLifterControlResponse *const*)ptr, "ns3:RobotLifterControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLifterControl:
		return soap_out_PointerTo_ns3__RobotLifterControl(soap, tag, id, (_ns3__RobotLifterControl *const*)ptr, "ns3:RobotLifterControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotFlirControlResponse:
		return soap_out_PointerTo_ns3__RobotFlirControlResponse(soap, tag, id, (_ns3__RobotFlirControlResponse *const*)ptr, "ns3:RobotFlirControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotFlirControl:
		return soap_out_PointerTo_ns3__RobotFlirControl(soap, tag, id, (_ns3__RobotFlirControl *const*)ptr, "ns3:RobotFlirControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotWiperControlResponse:
		return soap_out_PointerTo_ns3__RobotWiperControlResponse(soap, tag, id, (_ns3__RobotWiperControlResponse *const*)ptr, "ns3:RobotWiperControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotWiperControl:
		return soap_out_PointerTo_ns3__RobotWiperControl(soap, tag, id, (_ns3__RobotWiperControl *const*)ptr, "ns3:RobotWiperControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLightControlResponse:
		return soap_out_PointerTo_ns3__RobotLightControlResponse(soap, tag, id, (_ns3__RobotLightControlResponse *const*)ptr, "ns3:RobotLightControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLightControl:
		return soap_out_PointerTo_ns3__RobotLightControl(soap, tag, id, (_ns3__RobotLightControl *const*)ptr, "ns3:RobotLightControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotCameraControlResponse:
		return soap_out_PointerTo_ns3__RobotCameraControlResponse(soap, tag, id, (_ns3__RobotCameraControlResponse *const*)ptr, "ns3:RobotCameraControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotCameraControl:
		return soap_out_PointerTo_ns3__RobotCameraControl(soap, tag, id, (_ns3__RobotCameraControl *const*)ptr, "ns3:RobotCameraControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotYuntaiControlResponse:
		return soap_out_PointerTo_ns3__RobotYuntaiControlResponse(soap, tag, id, (_ns3__RobotYuntaiControlResponse *const*)ptr, "ns3:RobotYuntaiControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotYuntaiControl:
		return soap_out_PointerTo_ns3__RobotYuntaiControl(soap, tag, id, (_ns3__RobotYuntaiControl *const*)ptr, "ns3:RobotYuntaiControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotSpeedControlResponse:
		return soap_out_PointerTo_ns3__RobotSpeedControlResponse(soap, tag, id, (_ns3__RobotSpeedControlResponse *const*)ptr, "ns3:RobotSpeedControlResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotSpeedControl:
		return soap_out_PointerTo_ns3__RobotSpeedControl(soap, tag, id, (_ns3__RobotSpeedControl *const*)ptr, "ns3:RobotSpeedControl");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetControlModeResponse:
		return soap_out_PointerTo_ns3__GetControlModeResponse(soap, tag, id, (_ns3__GetControlModeResponse *const*)ptr, "ns3:GetControlModeResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetControlMode:
		return soap_out_PointerTo_ns3__GetControlMode(soap, tag, id, (_ns3__GetControlMode *const*)ptr, "ns3:GetControlMode");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetControlModeResponse:
		return soap_out_PointerTo_ns3__SetControlModeResponse(soap, tag, id, (_ns3__SetControlModeResponse *const*)ptr, "ns3:SetControlModeResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetControlMode:
		return soap_out_PointerTo_ns3__SetControlMode(soap, tag, id, (_ns3__SetControlMode *const*)ptr, "ns3:SetControlMode");
	case SOAP_TYPE_RobotData_PointerTo_ns3__ReleaseCurrentRobotResponse:
		return soap_out_PointerTo_ns3__ReleaseCurrentRobotResponse(soap, tag, id, (_ns3__ReleaseCurrentRobotResponse *const*)ptr, "ns3:ReleaseCurrentRobotResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__ReleaseCurrentRobot:
		return soap_out_PointerTo_ns3__ReleaseCurrentRobot(soap, tag, id, (_ns3__ReleaseCurrentRobot *const*)ptr, "ns3:ReleaseCurrentRobot");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetCurrentRobotResponse:
		return soap_out_PointerTo_ns3__SetCurrentRobotResponse(soap, tag, id, (_ns3__SetCurrentRobotResponse *const*)ptr, "ns3:SetCurrentRobotResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetCurrentRobot:
		return soap_out_PointerTo_ns3__SetCurrentRobot(soap, tag, id, (_ns3__SetCurrentRobot *const*)ptr, "ns3:SetCurrentRobot");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetRobotTimeResponse:
		return soap_out_PointerTo_ns3__SetRobotTimeResponse(soap, tag, id, (_ns3__SetRobotTimeResponse *const*)ptr, "ns3:SetRobotTimeResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetRobotTime:
		return soap_out_PointerTo_ns3__SetRobotTime(soap, tag, id, (_ns3__SetRobotTime *const*)ptr, "ns3:SetRobotTime");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTimeResponse:
		return soap_out_PointerTo_ns3__GetRobotTimeResponse(soap, tag, id, (_ns3__GetRobotTimeResponse *const*)ptr, "ns3:GetRobotTimeResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTime:
		return soap_out_PointerTo_ns3__GetRobotTime(soap, tag, id, (_ns3__GetRobotTime *const*)ptr, "ns3:GetRobotTime");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotInfoResponse:
		return soap_out_PointerTo_ns3__GetRobotInfoResponse(soap, tag, id, (_ns3__GetRobotInfoResponse *const*)ptr, "ns3:GetRobotInfoResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotInfo:
		return soap_out_PointerTo_ns3__GetRobotInfo(soap, tag, id, (_ns3__GetRobotInfo *const*)ptr, "ns3:GetRobotInfo");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotConnectResponse:
		return soap_out_PointerTo_ns3__GetRobotConnectResponse(soap, tag, id, (_ns3__GetRobotConnectResponse *const*)ptr, "ns3:GetRobotConnectResponse");
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotConnect:
		return soap_out_PointerTo_ns3__GetRobotConnect(soap, tag, id, (_ns3__GetRobotConnect *const*)ptr, "ns3:GetRobotConnect");
	case SOAP_TYPE_RobotData_PointerTons3__RobotAlarmInfos:
		return soap_out_PointerTons3__RobotAlarmInfos(soap, tag, id, (ns3__RobotAlarmInfos *const*)ptr, "ns3:RobotAlarmInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotGasInfos:
		return soap_out_PointerTons3__RobotGasInfos(soap, tag, id, (ns3__RobotGasInfos *const*)ptr, "ns3:RobotGasInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotMileageInfos:
		return soap_out_PointerTons3__RobotMileageInfos(soap, tag, id, (ns3__RobotMileageInfos *const*)ptr, "ns3:RobotMileageInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotYunTaiInfos:
		return soap_out_PointerTons3__RobotYunTaiInfos(soap, tag, id, (ns3__RobotYunTaiInfos *const*)ptr, "ns3:RobotYunTaiInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotPosInfos:
		return soap_out_PointerTons3__RobotPosInfos(soap, tag, id, (ns3__RobotPosInfos *const*)ptr, "ns3:RobotPosInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotTaskStates:
		return soap_out_PointerTons3__RobotTaskStates(soap, tag, id, (ns3__RobotTaskStates *const*)ptr, "ns3:RobotTaskStates");
	case SOAP_TYPE_RobotData_PointerTons3__SpeedInfos:
		return soap_out_PointerTons3__SpeedInfos(soap, tag, id, (ns3__SpeedInfos *const*)ptr, "ns3:SpeedInfos");
	case SOAP_TYPE_RobotData_PointerTons3__BatteryInfos:
		return soap_out_PointerTons3__BatteryInfos(soap, tag, id, (ns3__BatteryInfos *const*)ptr, "ns3:BatteryInfos");
	case SOAP_TYPE_RobotData_PointerTons3__RobotInfos:
		return soap_out_PointerTons3__RobotInfos(soap, tag, id, (ns3__RobotInfos *const*)ptr, "ns3:RobotInfos");
	case SOAP_TYPE_RobotData_PointerTons3__ConnectInfos:
		return soap_out_PointerTons3__ConnectInfos(soap, tag, id, (ns3__ConnectInfos *const*)ptr, "ns3:ConnectInfos");
	case SOAP_TYPE_RobotData_PointerTons3__TaskExcuteInfo:
		return soap_out_PointerTons3__TaskExcuteInfo(soap, tag, id, (ns3__TaskExcuteInfo *const*)ptr, "ns3:TaskExcuteInfo");
	case SOAP_TYPE_RobotData_PointerTons3__TaskFinishInfo:
		return soap_out_PointerTons3__TaskFinishInfo(soap, tag, id, (ns3__TaskFinishInfo *const*)ptr, "ns3:TaskFinishInfo");
	case SOAP_TYPE_RobotData_PointerTons3__TaskPathInfo:
		return soap_out_PointerTons3__TaskPathInfo(soap, tag, id, (ns3__TaskPathInfo *const*)ptr, "ns3:TaskPathInfo");
	case SOAP_TYPE_RobotData_PointerTons3__PatrolPointInfo:
		return soap_out_PointerTons3__PatrolPointInfo(soap, tag, id, (ns3__PatrolPointInfo *const*)ptr, "ns3:PatrolPointInfo");
	case SOAP_TYPE_RobotData_PointerTons3__DockPointInfo:
		return soap_out_PointerTons3__DockPointInfo(soap, tag, id, (ns3__DockPointInfo *const*)ptr, "ns3:DockPointInfo");
	case SOAP_TYPE_RobotData_PointerTons3__MapEdgeInfo:
		return soap_out_PointerTons3__MapEdgeInfo(soap, tag, id, (ns3__MapEdgeInfo *const*)ptr, "ns3:MapEdgeInfo");
	case SOAP_TYPE_RobotData_PointerTons3__PatrolAreaInfo:
		return soap_out_PointerTons3__PatrolAreaInfo(soap, tag, id, (ns3__PatrolAreaInfo *const*)ptr, "ns3:PatrolAreaInfo");
	case SOAP_TYPE_RobotData_PointerTons3__MapAreaInfo:
		return soap_out_PointerTons3__MapAreaInfo(soap, tag, id, (ns3__MapAreaInfo *const*)ptr, "ns3:MapAreaInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotAlarmInfo:
		return soap_out_PointerTons3__RobotAlarmInfo(soap, tag, id, (ns3__RobotAlarmInfo *const*)ptr, "ns3:RobotAlarmInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotGasInfo:
		return soap_out_PointerTons3__RobotGasInfo(soap, tag, id, (ns3__RobotGasInfo *const*)ptr, "ns3:RobotGasInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotMileageInfo:
		return soap_out_PointerTons3__RobotMileageInfo(soap, tag, id, (ns3__RobotMileageInfo *const*)ptr, "ns3:RobotMileageInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotYunTaiInfo:
		return soap_out_PointerTons3__RobotYunTaiInfo(soap, tag, id, (ns3__RobotYunTaiInfo *const*)ptr, "ns3:RobotYunTaiInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotPosInfo:
		return soap_out_PointerTons3__RobotPosInfo(soap, tag, id, (ns3__RobotPosInfo *const*)ptr, "ns3:RobotPosInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotTaskState:
		return soap_out_PointerTons3__RobotTaskState(soap, tag, id, (ns3__RobotTaskState *const*)ptr, "ns3:RobotTaskState");
	case SOAP_TYPE_RobotData_PointerTons3__SpeedInfo:
		return soap_out_PointerTons3__SpeedInfo(soap, tag, id, (ns3__SpeedInfo *const*)ptr, "ns3:SpeedInfo");
	case SOAP_TYPE_RobotData_PointerTons3__BatteryInfo:
		return soap_out_PointerTons3__BatteryInfo(soap, tag, id, (ns3__BatteryInfo *const*)ptr, "ns3:BatteryInfo");
	case SOAP_TYPE_RobotData_PointerTons3__RobotInfo:
		return soap_out_PointerTons3__RobotInfo(soap, tag, id, (ns3__RobotInfo *const*)ptr, "ns3:RobotInfo");
	case SOAP_TYPE_RobotData_PointerTons3__ConnectInfo:
		return soap_out_PointerTons3__ConnectInfo(soap, tag, id, (ns3__ConnectInfo *const*)ptr, "ns3:ConnectInfo");
	case SOAP_TYPE_RobotData__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_RobotData_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_RobotData_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse:
		((_ns3__GetRobotAlarmInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo:
		((_ns3__GetRobotAlarmInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse:
		((_ns3__GetRobotGasInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotGasInfo:
		((_ns3__GetRobotGasInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse:
		((_ns3__GetRobotMileageInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo:
		((_ns3__GetRobotMileageInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse:
		((_ns3__GetRobotYunTaiInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo:
		((_ns3__GetRobotYunTaiInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse:
		((_ns3__GetRobotPosInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotPosInfo:
		((_ns3__GetRobotPosInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse:
		((_ns3__GetRobotTaskStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotTaskState:
		((_ns3__GetRobotTaskState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse:
		((_ns3__GetRobotSpeedInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo:
		((_ns3__GetRobotSpeedInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse:
		((_ns3__GetRobotBatteryInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo:
		((_ns3__GetRobotBatteryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotPdControlResponse:
		((_ns3__RobotPdControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotPdControl:
		((_ns3__RobotPdControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse:
		((_ns3__RobotLifterControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotLifterControl:
		((_ns3__RobotLifterControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse:
		((_ns3__RobotFlirControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotFlirControl:
		((_ns3__RobotFlirControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse:
		((_ns3__RobotWiperControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotWiperControl:
		((_ns3__RobotWiperControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotLightControlResponse:
		((_ns3__RobotLightControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotLightControl:
		((_ns3__RobotLightControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse:
		((_ns3__RobotCameraControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotCameraControl:
		((_ns3__RobotCameraControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse:
		((_ns3__RobotYuntaiControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotYuntaiControl:
		((_ns3__RobotYuntaiControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse:
		((_ns3__RobotSpeedControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotSpeedControl:
		((_ns3__RobotSpeedControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetControlModeResponse:
		((_ns3__GetControlModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetControlMode:
		((_ns3__GetControlMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__SetControlModeResponse:
		((_ns3__SetControlModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__SetControlMode:
		((_ns3__SetControlMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse:
		((_ns3__ReleaseCurrentRobotResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot:
		((_ns3__ReleaseCurrentRobot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse:
		((_ns3__SetCurrentRobotResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__SetCurrentRobot:
		((_ns3__SetCurrentRobot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse:
		((_ns3__SetRobotTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__SetRobotTime:
		((_ns3__SetRobotTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse:
		((_ns3__GetRobotTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotTime:
		((_ns3__GetRobotTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse:
		((_ns3__GetRobotInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotInfo:
		((_ns3__GetRobotInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse:
		((_ns3__GetRobotConnectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotConnect:
		((_ns3__GetRobotConnect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfos:
		((ns3__TaskExcuteInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfo:
		((ns3__TaskExcuteInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfos:
		((ns3__TaskFinishInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfo:
		((ns3__TaskFinishInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskExcuteData:
		((ns3__TaskExcuteData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskPathInfos:
		((ns3__TaskPathInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskPathInfo:
		((ns3__TaskPathInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfos:
		((ns3__PatrolPointInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfo:
		((ns3__PatrolPointInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__DockPointInfos:
		((ns3__DockPointInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__DockPointInfo:
		((ns3__DockPointInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfos:
		((ns3__MapEdgeInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfo:
		((ns3__MapEdgeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfos:
		((ns3__PatrolAreaInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfo:
		((ns3__PatrolAreaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__MapAreaInfos:
		((ns3__MapAreaInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__MapAreaInfo:
		((ns3__MapAreaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfos:
		((ns3__RobotAlarmInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfo:
		((ns3__RobotAlarmInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotGasInfos:
		((ns3__RobotGasInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotGasInfo:
		((ns3__RobotGasInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfos:
		((ns3__RobotMileageInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfo:
		((ns3__RobotMileageInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos:
		((ns3__RobotYunTaiInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo:
		((ns3__RobotYunTaiInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotPosInfos:
		((ns3__RobotPosInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotPosInfo:
		((ns3__RobotPosInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotTaskStates:
		((ns3__RobotTaskStates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotTaskState:
		((ns3__RobotTaskState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__SpeedInfos:
		((ns3__SpeedInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__SpeedInfo:
		((ns3__SpeedInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__BatteryInfos:
		((ns3__BatteryInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__BatteryInfo:
		((ns3__BatteryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotInfos:
		((ns3__RobotInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotInfo:
		((ns3__RobotInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__ConnectInfos:
		((ns3__ConnectInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData_ns3__ConnectInfo:
		((ns3__ConnectInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotAlarmInfo:
		soap_serialize___ns1__GetRobotAlarmInfo(soap, (const struct __ns1__GetRobotAlarmInfo *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotGasInfo:
		soap_serialize___ns1__GetRobotGasInfo(soap, (const struct __ns1__GetRobotGasInfo *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotMileageInfo:
		soap_serialize___ns1__GetRobotMileageInfo(soap, (const struct __ns1__GetRobotMileageInfo *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotYunTaiInfo:
		soap_serialize___ns1__GetRobotYunTaiInfo(soap, (const struct __ns1__GetRobotYunTaiInfo *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotPosInfo:
		soap_serialize___ns1__GetRobotPosInfo(soap, (const struct __ns1__GetRobotPosInfo *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotTaskState:
		soap_serialize___ns1__GetRobotTaskState(soap, (const struct __ns1__GetRobotTaskState *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotSpeedInfo:
		soap_serialize___ns1__GetRobotSpeedInfo(soap, (const struct __ns1__GetRobotSpeedInfo *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotBatteryInfo:
		soap_serialize___ns1__GetRobotBatteryInfo(soap, (const struct __ns1__GetRobotBatteryInfo *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotPdControl:
		soap_serialize___ns1__RobotPdControl(soap, (const struct __ns1__RobotPdControl *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotLifterControl:
		soap_serialize___ns1__RobotLifterControl(soap, (const struct __ns1__RobotLifterControl *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotFlirControl:
		soap_serialize___ns1__RobotFlirControl(soap, (const struct __ns1__RobotFlirControl *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotWiperControl:
		soap_serialize___ns1__RobotWiperControl(soap, (const struct __ns1__RobotWiperControl *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotLightControl:
		soap_serialize___ns1__RobotLightControl(soap, (const struct __ns1__RobotLightControl *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotCameraControl:
		soap_serialize___ns1__RobotCameraControl(soap, (const struct __ns1__RobotCameraControl *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotYuntaiControl:
		soap_serialize___ns1__RobotYuntaiControl(soap, (const struct __ns1__RobotYuntaiControl *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotSpeedControl:
		soap_serialize___ns1__RobotSpeedControl(soap, (const struct __ns1__RobotSpeedControl *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetControlMode:
		soap_serialize___ns1__GetControlMode(soap, (const struct __ns1__GetControlMode *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__SetControlMode:
		soap_serialize___ns1__SetControlMode(soap, (const struct __ns1__SetControlMode *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__ReleaseCurrentRobot:
		soap_serialize___ns1__ReleaseCurrentRobot(soap, (const struct __ns1__ReleaseCurrentRobot *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__SetCurrentRobot:
		soap_serialize___ns1__SetCurrentRobot(soap, (const struct __ns1__SetCurrentRobot *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__SetRobotTime:
		soap_serialize___ns1__SetRobotTime(soap, (const struct __ns1__SetRobotTime *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotTime:
		soap_serialize___ns1__GetRobotTime(soap, (const struct __ns1__GetRobotTime *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotInfo:
		soap_serialize___ns1__GetRobotInfo(soap, (const struct __ns1__GetRobotInfo *)ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotConnect:
		soap_serialize___ns1__GetRobotConnect(soap, (const struct __ns1__GetRobotConnect *)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotAlarmInfoResponse:
		soap_serialize_PointerTo_ns3__GetRobotAlarmInfoResponse(soap, (_ns3__GetRobotAlarmInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotAlarmInfo:
		soap_serialize_PointerTo_ns3__GetRobotAlarmInfo(soap, (_ns3__GetRobotAlarmInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotGasInfoResponse:
		soap_serialize_PointerTo_ns3__GetRobotGasInfoResponse(soap, (_ns3__GetRobotGasInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotGasInfo:
		soap_serialize_PointerTo_ns3__GetRobotGasInfo(soap, (_ns3__GetRobotGasInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotMileageInfoResponse:
		soap_serialize_PointerTo_ns3__GetRobotMileageInfoResponse(soap, (_ns3__GetRobotMileageInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotMileageInfo:
		soap_serialize_PointerTo_ns3__GetRobotMileageInfo(soap, (_ns3__GetRobotMileageInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotYunTaiInfoResponse:
		soap_serialize_PointerTo_ns3__GetRobotYunTaiInfoResponse(soap, (_ns3__GetRobotYunTaiInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotYunTaiInfo:
		soap_serialize_PointerTo_ns3__GetRobotYunTaiInfo(soap, (_ns3__GetRobotYunTaiInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotPosInfoResponse:
		soap_serialize_PointerTo_ns3__GetRobotPosInfoResponse(soap, (_ns3__GetRobotPosInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotPosInfo:
		soap_serialize_PointerTo_ns3__GetRobotPosInfo(soap, (_ns3__GetRobotPosInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTaskStateResponse:
		soap_serialize_PointerTo_ns3__GetRobotTaskStateResponse(soap, (_ns3__GetRobotTaskStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTaskState:
		soap_serialize_PointerTo_ns3__GetRobotTaskState(soap, (_ns3__GetRobotTaskState *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotSpeedInfoResponse:
		soap_serialize_PointerTo_ns3__GetRobotSpeedInfoResponse(soap, (_ns3__GetRobotSpeedInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotSpeedInfo:
		soap_serialize_PointerTo_ns3__GetRobotSpeedInfo(soap, (_ns3__GetRobotSpeedInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotBatteryInfoResponse:
		soap_serialize_PointerTo_ns3__GetRobotBatteryInfoResponse(soap, (_ns3__GetRobotBatteryInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotBatteryInfo:
		soap_serialize_PointerTo_ns3__GetRobotBatteryInfo(soap, (_ns3__GetRobotBatteryInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotPdControlResponse:
		soap_serialize_PointerTo_ns3__RobotPdControlResponse(soap, (_ns3__RobotPdControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotPdControl:
		soap_serialize_PointerTo_ns3__RobotPdControl(soap, (_ns3__RobotPdControl *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLifterControlResponse:
		soap_serialize_PointerTo_ns3__RobotLifterControlResponse(soap, (_ns3__RobotLifterControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLifterControl:
		soap_serialize_PointerTo_ns3__RobotLifterControl(soap, (_ns3__RobotLifterControl *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotFlirControlResponse:
		soap_serialize_PointerTo_ns3__RobotFlirControlResponse(soap, (_ns3__RobotFlirControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotFlirControl:
		soap_serialize_PointerTo_ns3__RobotFlirControl(soap, (_ns3__RobotFlirControl *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotWiperControlResponse:
		soap_serialize_PointerTo_ns3__RobotWiperControlResponse(soap, (_ns3__RobotWiperControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotWiperControl:
		soap_serialize_PointerTo_ns3__RobotWiperControl(soap, (_ns3__RobotWiperControl *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLightControlResponse:
		soap_serialize_PointerTo_ns3__RobotLightControlResponse(soap, (_ns3__RobotLightControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotLightControl:
		soap_serialize_PointerTo_ns3__RobotLightControl(soap, (_ns3__RobotLightControl *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotCameraControlResponse:
		soap_serialize_PointerTo_ns3__RobotCameraControlResponse(soap, (_ns3__RobotCameraControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotCameraControl:
		soap_serialize_PointerTo_ns3__RobotCameraControl(soap, (_ns3__RobotCameraControl *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotYuntaiControlResponse:
		soap_serialize_PointerTo_ns3__RobotYuntaiControlResponse(soap, (_ns3__RobotYuntaiControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotYuntaiControl:
		soap_serialize_PointerTo_ns3__RobotYuntaiControl(soap, (_ns3__RobotYuntaiControl *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotSpeedControlResponse:
		soap_serialize_PointerTo_ns3__RobotSpeedControlResponse(soap, (_ns3__RobotSpeedControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__RobotSpeedControl:
		soap_serialize_PointerTo_ns3__RobotSpeedControl(soap, (_ns3__RobotSpeedControl *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetControlModeResponse:
		soap_serialize_PointerTo_ns3__GetControlModeResponse(soap, (_ns3__GetControlModeResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetControlMode:
		soap_serialize_PointerTo_ns3__GetControlMode(soap, (_ns3__GetControlMode *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetControlModeResponse:
		soap_serialize_PointerTo_ns3__SetControlModeResponse(soap, (_ns3__SetControlModeResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetControlMode:
		soap_serialize_PointerTo_ns3__SetControlMode(soap, (_ns3__SetControlMode *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__ReleaseCurrentRobotResponse:
		soap_serialize_PointerTo_ns3__ReleaseCurrentRobotResponse(soap, (_ns3__ReleaseCurrentRobotResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__ReleaseCurrentRobot:
		soap_serialize_PointerTo_ns3__ReleaseCurrentRobot(soap, (_ns3__ReleaseCurrentRobot *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetCurrentRobotResponse:
		soap_serialize_PointerTo_ns3__SetCurrentRobotResponse(soap, (_ns3__SetCurrentRobotResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetCurrentRobot:
		soap_serialize_PointerTo_ns3__SetCurrentRobot(soap, (_ns3__SetCurrentRobot *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetRobotTimeResponse:
		soap_serialize_PointerTo_ns3__SetRobotTimeResponse(soap, (_ns3__SetRobotTimeResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__SetRobotTime:
		soap_serialize_PointerTo_ns3__SetRobotTime(soap, (_ns3__SetRobotTime *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTimeResponse:
		soap_serialize_PointerTo_ns3__GetRobotTimeResponse(soap, (_ns3__GetRobotTimeResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTime:
		soap_serialize_PointerTo_ns3__GetRobotTime(soap, (_ns3__GetRobotTime *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotInfoResponse:
		soap_serialize_PointerTo_ns3__GetRobotInfoResponse(soap, (_ns3__GetRobotInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotInfo:
		soap_serialize_PointerTo_ns3__GetRobotInfo(soap, (_ns3__GetRobotInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotConnectResponse:
		soap_serialize_PointerTo_ns3__GetRobotConnectResponse(soap, (_ns3__GetRobotConnectResponse *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotConnect:
		soap_serialize_PointerTo_ns3__GetRobotConnect(soap, (_ns3__GetRobotConnect *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotAlarmInfos:
		soap_serialize_PointerTons3__RobotAlarmInfos(soap, (ns3__RobotAlarmInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotGasInfos:
		soap_serialize_PointerTons3__RobotGasInfos(soap, (ns3__RobotGasInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotMileageInfos:
		soap_serialize_PointerTons3__RobotMileageInfos(soap, (ns3__RobotMileageInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotYunTaiInfos:
		soap_serialize_PointerTons3__RobotYunTaiInfos(soap, (ns3__RobotYunTaiInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotPosInfos:
		soap_serialize_PointerTons3__RobotPosInfos(soap, (ns3__RobotPosInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotTaskStates:
		soap_serialize_PointerTons3__RobotTaskStates(soap, (ns3__RobotTaskStates *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__SpeedInfos:
		soap_serialize_PointerTons3__SpeedInfos(soap, (ns3__SpeedInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__BatteryInfos:
		soap_serialize_PointerTons3__BatteryInfos(soap, (ns3__BatteryInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotInfos:
		soap_serialize_PointerTons3__RobotInfos(soap, (ns3__RobotInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__ConnectInfos:
		soap_serialize_PointerTons3__ConnectInfos(soap, (ns3__ConnectInfos *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__TaskExcuteInfo:
		soap_serialize_PointerTons3__TaskExcuteInfo(soap, (ns3__TaskExcuteInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__TaskFinishInfo:
		soap_serialize_PointerTons3__TaskFinishInfo(soap, (ns3__TaskFinishInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__TaskPathInfo:
		soap_serialize_PointerTons3__TaskPathInfo(soap, (ns3__TaskPathInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__PatrolPointInfo:
		soap_serialize_PointerTons3__PatrolPointInfo(soap, (ns3__PatrolPointInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__DockPointInfo:
		soap_serialize_PointerTons3__DockPointInfo(soap, (ns3__DockPointInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__MapEdgeInfo:
		soap_serialize_PointerTons3__MapEdgeInfo(soap, (ns3__MapEdgeInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__PatrolAreaInfo:
		soap_serialize_PointerTons3__PatrolAreaInfo(soap, (ns3__PatrolAreaInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__MapAreaInfo:
		soap_serialize_PointerTons3__MapAreaInfo(soap, (ns3__MapAreaInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotAlarmInfo:
		soap_serialize_PointerTons3__RobotAlarmInfo(soap, (ns3__RobotAlarmInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotGasInfo:
		soap_serialize_PointerTons3__RobotGasInfo(soap, (ns3__RobotGasInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotMileageInfo:
		soap_serialize_PointerTons3__RobotMileageInfo(soap, (ns3__RobotMileageInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotYunTaiInfo:
		soap_serialize_PointerTons3__RobotYunTaiInfo(soap, (ns3__RobotYunTaiInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotPosInfo:
		soap_serialize_PointerTons3__RobotPosInfo(soap, (ns3__RobotPosInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotTaskState:
		soap_serialize_PointerTons3__RobotTaskState(soap, (ns3__RobotTaskState *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__SpeedInfo:
		soap_serialize_PointerTons3__SpeedInfo(soap, (ns3__SpeedInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__BatteryInfo:
		soap_serialize_PointerTons3__BatteryInfo(soap, (ns3__BatteryInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__RobotInfo:
		soap_serialize_PointerTons3__RobotInfo(soap, (ns3__RobotInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData_PointerTons3__ConnectInfo:
		soap_serialize_PointerTons3__ConnectInfo(soap, (ns3__ConnectInfo *const*)ptr);
		break;
	case SOAP_TYPE_RobotData__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_RobotData_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 RobotData_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_RobotData_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__ConnectInfo:
		return (void*)soap_instantiate_ns3__ConnectInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__ConnectInfos:
		return (void*)soap_instantiate_ns3__ConnectInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotInfo:
		return (void*)soap_instantiate_ns3__RobotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotInfos:
		return (void*)soap_instantiate_ns3__RobotInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__BatteryInfo:
		return (void*)soap_instantiate_ns3__BatteryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__BatteryInfos:
		return (void*)soap_instantiate_ns3__BatteryInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__SpeedInfo:
		return (void*)soap_instantiate_ns3__SpeedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__SpeedInfos:
		return (void*)soap_instantiate_ns3__SpeedInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotTaskState:
		return (void*)soap_instantiate_ns3__RobotTaskState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotTaskStates:
		return (void*)soap_instantiate_ns3__RobotTaskStates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotPosInfo:
		return (void*)soap_instantiate_ns3__RobotPosInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotPosInfos:
		return (void*)soap_instantiate_ns3__RobotPosInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo:
		return (void*)soap_instantiate_ns3__RobotYunTaiInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos:
		return (void*)soap_instantiate_ns3__RobotYunTaiInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfo:
		return (void*)soap_instantiate_ns3__RobotMileageInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfos:
		return (void*)soap_instantiate_ns3__RobotMileageInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotGasInfo:
		return (void*)soap_instantiate_ns3__RobotGasInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotGasInfos:
		return (void*)soap_instantiate_ns3__RobotGasInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfo:
		return (void*)soap_instantiate_ns3__RobotAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfos:
		return (void*)soap_instantiate_ns3__RobotAlarmInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__MapAreaInfo:
		return (void*)soap_instantiate_ns3__MapAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__MapAreaInfos:
		return (void*)soap_instantiate_ns3__MapAreaInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfo:
		return (void*)soap_instantiate_ns3__PatrolAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfos:
		return (void*)soap_instantiate_ns3__PatrolAreaInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfo:
		return (void*)soap_instantiate_ns3__MapEdgeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfos:
		return (void*)soap_instantiate_ns3__MapEdgeInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__DockPointInfo:
		return (void*)soap_instantiate_ns3__DockPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__DockPointInfos:
		return (void*)soap_instantiate_ns3__DockPointInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfo:
		return (void*)soap_instantiate_ns3__PatrolPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfos:
		return (void*)soap_instantiate_ns3__PatrolPointInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__TaskPathInfo:
		return (void*)soap_instantiate_ns3__TaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__TaskPathInfos:
		return (void*)soap_instantiate_ns3__TaskPathInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__TaskExcuteData:
		return (void*)soap_instantiate_ns3__TaskExcuteData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfo:
		return (void*)soap_instantiate_ns3__TaskFinishInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfos:
		return (void*)soap_instantiate_ns3__TaskFinishInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfo:
		return (void*)soap_instantiate_ns3__TaskExcuteInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfos:
		return (void*)soap_instantiate_ns3__TaskExcuteInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotConnect:
		return (void*)soap_instantiate__ns3__GetRobotConnect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse:
		return (void*)soap_instantiate__ns3__GetRobotConnectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotInfo:
		return (void*)soap_instantiate__ns3__GetRobotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse:
		return (void*)soap_instantiate__ns3__GetRobotInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotTime:
		return (void*)soap_instantiate__ns3__GetRobotTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse:
		return (void*)soap_instantiate__ns3__GetRobotTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__SetRobotTime:
		return (void*)soap_instantiate__ns3__SetRobotTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse:
		return (void*)soap_instantiate__ns3__SetRobotTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__SetCurrentRobot:
		return (void*)soap_instantiate__ns3__SetCurrentRobot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse:
		return (void*)soap_instantiate__ns3__SetCurrentRobotResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot:
		return (void*)soap_instantiate__ns3__ReleaseCurrentRobot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse:
		return (void*)soap_instantiate__ns3__ReleaseCurrentRobotResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__SetControlMode:
		return (void*)soap_instantiate__ns3__SetControlMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__SetControlModeResponse:
		return (void*)soap_instantiate__ns3__SetControlModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetControlMode:
		return (void*)soap_instantiate__ns3__GetControlMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetControlModeResponse:
		return (void*)soap_instantiate__ns3__GetControlModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotSpeedControl:
		return (void*)soap_instantiate__ns3__RobotSpeedControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse:
		return (void*)soap_instantiate__ns3__RobotSpeedControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotYuntaiControl:
		return (void*)soap_instantiate__ns3__RobotYuntaiControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse:
		return (void*)soap_instantiate__ns3__RobotYuntaiControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotCameraControl:
		return (void*)soap_instantiate__ns3__RobotCameraControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse:
		return (void*)soap_instantiate__ns3__RobotCameraControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotLightControl:
		return (void*)soap_instantiate__ns3__RobotLightControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotLightControlResponse:
		return (void*)soap_instantiate__ns3__RobotLightControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotWiperControl:
		return (void*)soap_instantiate__ns3__RobotWiperControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse:
		return (void*)soap_instantiate__ns3__RobotWiperControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotFlirControl:
		return (void*)soap_instantiate__ns3__RobotFlirControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse:
		return (void*)soap_instantiate__ns3__RobotFlirControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotLifterControl:
		return (void*)soap_instantiate__ns3__RobotLifterControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse:
		return (void*)soap_instantiate__ns3__RobotLifterControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotPdControl:
		return (void*)soap_instantiate__ns3__RobotPdControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__RobotPdControlResponse:
		return (void*)soap_instantiate__ns3__RobotPdControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo:
		return (void*)soap_instantiate__ns3__GetRobotBatteryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse:
		return (void*)soap_instantiate__ns3__GetRobotBatteryInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo:
		return (void*)soap_instantiate__ns3__GetRobotSpeedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse:
		return (void*)soap_instantiate__ns3__GetRobotSpeedInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotTaskState:
		return (void*)soap_instantiate__ns3__GetRobotTaskState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse:
		return (void*)soap_instantiate__ns3__GetRobotTaskStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotPosInfo:
		return (void*)soap_instantiate__ns3__GetRobotPosInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse:
		return (void*)soap_instantiate__ns3__GetRobotPosInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo:
		return (void*)soap_instantiate__ns3__GetRobotYunTaiInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse:
		return (void*)soap_instantiate__ns3__GetRobotYunTaiInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo:
		return (void*)soap_instantiate__ns3__GetRobotMileageInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse:
		return (void*)soap_instantiate__ns3__GetRobotMileageInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotGasInfo:
		return (void*)soap_instantiate__ns3__GetRobotGasInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse:
		return (void*)soap_instantiate__ns3__GetRobotGasInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo:
		return (void*)soap_instantiate__ns3__GetRobotAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse:
		return (void*)soap_instantiate__ns3__GetRobotAlarmInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotConnect:
		return (void*)soap_instantiate___ns1__GetRobotConnect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotInfo:
		return (void*)soap_instantiate___ns1__GetRobotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotTime:
		return (void*)soap_instantiate___ns1__GetRobotTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__SetRobotTime:
		return (void*)soap_instantiate___ns1__SetRobotTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__SetCurrentRobot:
		return (void*)soap_instantiate___ns1__SetCurrentRobot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__ReleaseCurrentRobot:
		return (void*)soap_instantiate___ns1__ReleaseCurrentRobot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__SetControlMode:
		return (void*)soap_instantiate___ns1__SetControlMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetControlMode:
		return (void*)soap_instantiate___ns1__GetControlMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__RobotSpeedControl:
		return (void*)soap_instantiate___ns1__RobotSpeedControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__RobotYuntaiControl:
		return (void*)soap_instantiate___ns1__RobotYuntaiControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__RobotCameraControl:
		return (void*)soap_instantiate___ns1__RobotCameraControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__RobotLightControl:
		return (void*)soap_instantiate___ns1__RobotLightControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__RobotWiperControl:
		return (void*)soap_instantiate___ns1__RobotWiperControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__RobotFlirControl:
		return (void*)soap_instantiate___ns1__RobotFlirControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__RobotLifterControl:
		return (void*)soap_instantiate___ns1__RobotLifterControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__RobotPdControl:
		return (void*)soap_instantiate___ns1__RobotPdControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotBatteryInfo:
		return (void*)soap_instantiate___ns1__GetRobotBatteryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotSpeedInfo:
		return (void*)soap_instantiate___ns1__GetRobotSpeedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotTaskState:
		return (void*)soap_instantiate___ns1__GetRobotTaskState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotPosInfo:
		return (void*)soap_instantiate___ns1__GetRobotPosInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotYunTaiInfo:
		return (void*)soap_instantiate___ns1__GetRobotYunTaiInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotMileageInfo:
		return (void*)soap_instantiate___ns1__GetRobotMileageInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotGasInfo:
		return (void*)soap_instantiate___ns1__GetRobotGasInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData___ns1__GetRobotAlarmInfo:
		return (void*)soap_instantiate___ns1__GetRobotAlarmInfo(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskExcuteInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskFinishInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__TaskFinishInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskPathInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__TaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolPointInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__PatrolPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__DockPointInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__DockPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapEdgeInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__MapEdgeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolAreaInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapAreaInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__MapAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotAlarmInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotGasInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__RobotGasInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotMileageInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__RobotMileageInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotPosInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__RobotPosInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotTaskState:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__RobotTaskState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__SpeedInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__SpeedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__BatteryInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__BatteryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__RobotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__ConnectInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__ConnectInfo(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 RobotData_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_RobotData_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__ConnectInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__ConnectInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__ConnectInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__ConnectInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__ConnectInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__ConnectInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__BatteryInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__BatteryInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__BatteryInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__BatteryInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__BatteryInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__BatteryInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__SpeedInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__SpeedInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__SpeedInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__SpeedInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__SpeedInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__SpeedInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotTaskState:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotTaskState*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotTaskState*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotTaskStates:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotTaskStates*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotTaskStates*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotPosInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotPosInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotPosInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotPosInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotPosInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotPosInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotYunTaiInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotYunTaiInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotYunTaiInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotYunTaiInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotMileageInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotMileageInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotMileageInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotMileageInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotMileageInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotGasInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotGasInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotGasInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotGasInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotGasInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotGasInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotAlarmInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotAlarmInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__RobotAlarmInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__RobotAlarmInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__RobotAlarmInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__MapAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__MapAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__MapAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__MapAreaInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__MapAreaInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__MapAreaInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__PatrolAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__PatrolAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__PatrolAreaInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__PatrolAreaInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__PatrolAreaInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__MapEdgeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__MapEdgeInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__MapEdgeInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__MapEdgeInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__MapEdgeInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__DockPointInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__DockPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__DockPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__DockPointInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__DockPointInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__DockPointInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__PatrolPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__PatrolPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__PatrolPointInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__PatrolPointInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__PatrolPointInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__TaskPathInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__TaskPathInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskPathInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__TaskPathInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__TaskPathInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskExcuteData:
		if (p->size < 0)
			SOAP_DELETE((ns3__TaskExcuteData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__TaskExcuteData*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__TaskFinishInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__TaskFinishInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskFinishInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__TaskFinishInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__TaskFinishInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfo:
		if (p->size < 0)
			SOAP_DELETE((ns3__TaskExcuteInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__TaskExcuteInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_ns3__TaskExcuteInfos:
		if (p->size < 0)
			SOAP_DELETE((ns3__TaskExcuteInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__TaskExcuteInfos*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotConnect:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotConnect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotConnect*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotConnectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotConnectResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotTime:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotTime*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__SetRobotTime:
		if (p->size < 0)
			SOAP_DELETE((_ns3__SetRobotTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__SetRobotTime*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__SetRobotTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__SetRobotTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__SetCurrentRobot:
		if (p->size < 0)
			SOAP_DELETE((_ns3__SetCurrentRobot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__SetCurrentRobot*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__SetCurrentRobotResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__SetCurrentRobotResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot:
		if (p->size < 0)
			SOAP_DELETE((_ns3__ReleaseCurrentRobot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__ReleaseCurrentRobot*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__ReleaseCurrentRobotResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__ReleaseCurrentRobotResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__SetControlMode:
		if (p->size < 0)
			SOAP_DELETE((_ns3__SetControlMode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__SetControlMode*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__SetControlModeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__SetControlModeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__SetControlModeResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetControlMode:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetControlMode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetControlMode*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetControlModeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetControlModeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetControlModeResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotSpeedControl:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotSpeedControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotSpeedControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotSpeedControlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotSpeedControlResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotYuntaiControl:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotYuntaiControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotYuntaiControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotYuntaiControlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotYuntaiControlResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotCameraControl:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotCameraControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotCameraControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotCameraControlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotCameraControlResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotLightControl:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotLightControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotLightControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotLightControlResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotLightControlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotLightControlResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotWiperControl:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotWiperControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotWiperControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotWiperControlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotWiperControlResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotFlirControl:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotFlirControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotFlirControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotFlirControlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotFlirControlResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotLifterControl:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotLifterControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotLifterControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotLifterControlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotLifterControlResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotPdControl:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotPdControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotPdControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__RobotPdControlResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__RobotPdControlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__RobotPdControlResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotBatteryInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotBatteryInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotBatteryInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotBatteryInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotSpeedInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotSpeedInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotSpeedInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotSpeedInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotTaskState:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotTaskState*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotTaskState*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotTaskStateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotTaskStateResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotPosInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotPosInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotPosInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotPosInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotPosInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotYunTaiInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotYunTaiInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotYunTaiInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotYunTaiInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotMileageInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotMileageInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotMileageInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotMileageInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotGasInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotGasInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotGasInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotGasInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotGasInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotAlarmInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotAlarmInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns3__GetRobotAlarmInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__GetRobotAlarmInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotConnect:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotConnect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotConnect*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotTime:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotTime*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__SetRobotTime:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetRobotTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetRobotTime*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__SetCurrentRobot:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetCurrentRobot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetCurrentRobot*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__ReleaseCurrentRobot:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ReleaseCurrentRobot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ReleaseCurrentRobot*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__SetControlMode:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetControlMode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetControlMode*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetControlMode:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetControlMode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetControlMode*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotSpeedControl:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotSpeedControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotSpeedControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotYuntaiControl:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotYuntaiControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotYuntaiControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotCameraControl:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotCameraControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotCameraControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotLightControl:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotLightControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotLightControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotWiperControl:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotWiperControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotWiperControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotFlirControl:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotFlirControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotFlirControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotLifterControl:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotLifterControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotLifterControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__RobotPdControl:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotPdControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotPdControl*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotBatteryInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotBatteryInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotBatteryInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotSpeedInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotSpeedInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotSpeedInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotTaskState:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotTaskState*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotTaskState*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotPosInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotPosInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotPosInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotYunTaiInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotYunTaiInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotYunTaiInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotMileageInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotMileageInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotMileageInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotGasInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotGasInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotGasInfo*)p->ptr);
		break;
	case SOAP_TYPE_RobotData___ns1__GetRobotAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRobotAlarmInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRobotAlarmInfo*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_RobotData_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskExcuteInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__TaskExcuteInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__TaskExcuteInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskFinishInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__TaskFinishInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__TaskFinishInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__TaskPathInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__TaskPathInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolPointInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__PatrolPointInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__PatrolPointInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__DockPointInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__DockPointInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__DockPointInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapEdgeInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__MapEdgeInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__MapEdgeInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__PatrolAreaInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__PatrolAreaInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__MapAreaInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__MapAreaInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__RobotAlarmInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__RobotAlarmInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotGasInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__RobotGasInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__RobotGasInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotMileageInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__RobotMileageInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__RobotMileageInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__RobotYunTaiInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__RobotYunTaiInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotPosInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__RobotPosInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__RobotPosInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotTaskState:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__RobotTaskState * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__RobotTaskState * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__SpeedInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__SpeedInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__SpeedInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__BatteryInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__BatteryInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__BatteryInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__RobotInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__RobotInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__ConnectInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__ConnectInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__ConnectInfo * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, RobotData_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, RobotData_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 RobotData_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskExcuteInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__TaskExcuteInfo * >*)p)[len] = *(ns3__TaskExcuteInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskFinishInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__TaskFinishInfo * >*)p)[len] = *(ns3__TaskFinishInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskPathInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__TaskPathInfo * >*)p)[len] = *(ns3__TaskPathInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolPointInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__PatrolPointInfo * >*)p)[len] = *(ns3__PatrolPointInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__DockPointInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__DockPointInfo * >*)p)[len] = *(ns3__DockPointInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapEdgeInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__MapEdgeInfo * >*)p)[len] = *(ns3__MapEdgeInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolAreaInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__PatrolAreaInfo * >*)p)[len] = *(ns3__PatrolAreaInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapAreaInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__MapAreaInfo * >*)p)[len] = *(ns3__MapAreaInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotAlarmInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__RobotAlarmInfo * >*)p)[len] = *(ns3__RobotAlarmInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotGasInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__RobotGasInfo * >*)p)[len] = *(ns3__RobotGasInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotMileageInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__RobotMileageInfo * >*)p)[len] = *(ns3__RobotMileageInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__RobotYunTaiInfo * >*)p)[len] = *(ns3__RobotYunTaiInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotPosInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__RobotPosInfo * >*)p)[len] = *(ns3__RobotPosInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotTaskState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__RobotTaskState * >*)p)[len] = *(ns3__RobotTaskState **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__SpeedInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__SpeedInfo * >*)p)[len] = *(ns3__SpeedInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__BatteryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__BatteryInfo * >*)p)[len] = *(ns3__BatteryInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__RobotInfo * >*)p)[len] = *(ns3__RobotInfo **)q;
		break;
	case SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__ConnectInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container RobotData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__ConnectInfo * >*)p)[len] = *(ns3__ConnectInfo **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_RobotData_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_RobotData_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_RobotData_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_RobotData_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_RobotData_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_RobotData_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__ControlTaskType(struct soap *soap, enum ns3__ControlTaskType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__ControlTaskType
	*a = SOAP_DEFAULT_ns3__ControlTaskType;
#else
	*a = (enum ns3__ControlTaskType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__ControlTaskType[] =
{	{ (long)ns3__ControlTaskType__CancelTask, "CancelTask" },
	{ (long)ns3__ControlTaskType__PauseTask, "PauseTask" },
	{ (long)ns3__ControlTaskType__ResumeTask, "ResumeTask" },
	{ (long)ns3__ControlTaskType__ChargeTask, "ChargeTask" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__ControlTaskType2s(struct soap *soap, enum ns3__ControlTaskType n)
{	const char *s = soap_code_str(soap_codes_ns3__ControlTaskType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ControlTaskType(struct soap *soap, const char *tag, int id, const enum ns3__ControlTaskType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__ControlTaskType), type) || soap_send(soap, soap_ns3__ControlTaskType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__ControlTaskType(struct soap *soap, const char *s, enum ns3__ControlTaskType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__ControlTaskType, s);
	if (map)
		*a = (enum ns3__ControlTaskType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__ControlTaskType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__ControlTaskType * SOAP_FMAC4 soap_in_ns3__ControlTaskType(struct soap *soap, const char *tag, enum ns3__ControlTaskType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__ControlTaskType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__ControlTaskType, sizeof(enum ns3__ControlTaskType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__ControlTaskType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__ControlTaskType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__ControlTaskType, 0, sizeof(enum ns3__ControlTaskType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__ControlTaskType(struct soap *soap, const enum ns3__ControlTaskType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__ControlTaskType);
	if (soap_out_ns3__ControlTaskType(soap, tag?tag:"ns3:ControlTaskType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__ControlTaskType * SOAP_FMAC4 soap_get_ns3__ControlTaskType(struct soap *soap, enum ns3__ControlTaskType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ControlTaskType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__PdControlType(struct soap *soap, enum ns3__PdControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__PdControlType
	*a = SOAP_DEFAULT_ns3__PdControlType;
#else
	*a = (enum ns3__PdControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__PdControlType[] =
{	{ (long)ns3__PdControlType__PdForWard, "PdForWard" },
	{ (long)ns3__PdControlType__PdBackWord, "PdBackWord" },
	{ (long)ns3__PdControlType__PdStop, "PdStop" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__PdControlType2s(struct soap *soap, enum ns3__PdControlType n)
{	const char *s = soap_code_str(soap_codes_ns3__PdControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PdControlType(struct soap *soap, const char *tag, int id, const enum ns3__PdControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__PdControlType), type) || soap_send(soap, soap_ns3__PdControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__PdControlType(struct soap *soap, const char *s, enum ns3__PdControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__PdControlType, s);
	if (map)
		*a = (enum ns3__PdControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__PdControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__PdControlType * SOAP_FMAC4 soap_in_ns3__PdControlType(struct soap *soap, const char *tag, enum ns3__PdControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__PdControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__PdControlType, sizeof(enum ns3__PdControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__PdControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__PdControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__PdControlType, 0, sizeof(enum ns3__PdControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__PdControlType(struct soap *soap, const enum ns3__PdControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__PdControlType);
	if (soap_out_ns3__PdControlType(soap, tag?tag:"ns3:PdControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__PdControlType * SOAP_FMAC4 soap_get_ns3__PdControlType(struct soap *soap, enum ns3__PdControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PdControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__LifterControlType(struct soap *soap, enum ns3__LifterControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__LifterControlType
	*a = SOAP_DEFAULT_ns3__LifterControlType;
#else
	*a = (enum ns3__LifterControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__LifterControlType[] =
{	{ (long)ns3__LifterControlType__LifterUp, "LifterUp" },
	{ (long)ns3__LifterControlType__LifterDown, "LifterDown" },
	{ (long)ns3__LifterControlType__LifterStop, "LifterStop" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__LifterControlType2s(struct soap *soap, enum ns3__LifterControlType n)
{	const char *s = soap_code_str(soap_codes_ns3__LifterControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__LifterControlType(struct soap *soap, const char *tag, int id, const enum ns3__LifterControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__LifterControlType), type) || soap_send(soap, soap_ns3__LifterControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__LifterControlType(struct soap *soap, const char *s, enum ns3__LifterControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__LifterControlType, s);
	if (map)
		*a = (enum ns3__LifterControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__LifterControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__LifterControlType * SOAP_FMAC4 soap_in_ns3__LifterControlType(struct soap *soap, const char *tag, enum ns3__LifterControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__LifterControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__LifterControlType, sizeof(enum ns3__LifterControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__LifterControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__LifterControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__LifterControlType, 0, sizeof(enum ns3__LifterControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__LifterControlType(struct soap *soap, const enum ns3__LifterControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__LifterControlType);
	if (soap_out_ns3__LifterControlType(soap, tag?tag:"ns3:LifterControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__LifterControlType * SOAP_FMAC4 soap_get_ns3__LifterControlType(struct soap *soap, enum ns3__LifterControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__LifterControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__FilrControlType(struct soap *soap, enum ns3__FilrControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__FilrControlType
	*a = SOAP_DEFAULT_ns3__FilrControlType;
#else
	*a = (enum ns3__FilrControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__FilrControlType[] =
{	{ (long)ns3__FilrControlType__FocusUp, "FocusUp" },
	{ (long)ns3__FilrControlType__FocusDown, "FocusDown" },
	{ (long)ns3__FilrControlType__AutoFocus, "AutoFocus" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__FilrControlType2s(struct soap *soap, enum ns3__FilrControlType n)
{	const char *s = soap_code_str(soap_codes_ns3__FilrControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FilrControlType(struct soap *soap, const char *tag, int id, const enum ns3__FilrControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__FilrControlType), type) || soap_send(soap, soap_ns3__FilrControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__FilrControlType(struct soap *soap, const char *s, enum ns3__FilrControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__FilrControlType, s);
	if (map)
		*a = (enum ns3__FilrControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__FilrControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__FilrControlType * SOAP_FMAC4 soap_in_ns3__FilrControlType(struct soap *soap, const char *tag, enum ns3__FilrControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__FilrControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__FilrControlType, sizeof(enum ns3__FilrControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__FilrControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__FilrControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__FilrControlType, 0, sizeof(enum ns3__FilrControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__FilrControlType(struct soap *soap, const enum ns3__FilrControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__FilrControlType);
	if (soap_out_ns3__FilrControlType(soap, tag?tag:"ns3:FilrControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__FilrControlType * SOAP_FMAC4 soap_get_ns3__FilrControlType(struct soap *soap, enum ns3__FilrControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FilrControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__WiperControlType(struct soap *soap, enum ns3__WiperControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__WiperControlType
	*a = SOAP_DEFAULT_ns3__WiperControlType;
#else
	*a = (enum ns3__WiperControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__WiperControlType[] =
{	{ (long)ns3__WiperControlType__WiperOn, "WiperOn" },
	{ (long)ns3__WiperControlType__WiperOff, "WiperOff" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__WiperControlType2s(struct soap *soap, enum ns3__WiperControlType n)
{	const char *s = soap_code_str(soap_codes_ns3__WiperControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__WiperControlType(struct soap *soap, const char *tag, int id, const enum ns3__WiperControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__WiperControlType), type) || soap_send(soap, soap_ns3__WiperControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__WiperControlType(struct soap *soap, const char *s, enum ns3__WiperControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__WiperControlType, s);
	if (map)
		*a = (enum ns3__WiperControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__WiperControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__WiperControlType * SOAP_FMAC4 soap_in_ns3__WiperControlType(struct soap *soap, const char *tag, enum ns3__WiperControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__WiperControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__WiperControlType, sizeof(enum ns3__WiperControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__WiperControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__WiperControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__WiperControlType, 0, sizeof(enum ns3__WiperControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__WiperControlType(struct soap *soap, const enum ns3__WiperControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__WiperControlType);
	if (soap_out_ns3__WiperControlType(soap, tag?tag:"ns3:WiperControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__WiperControlType * SOAP_FMAC4 soap_get_ns3__WiperControlType(struct soap *soap, enum ns3__WiperControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__WiperControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__LightControlType(struct soap *soap, enum ns3__LightControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__LightControlType
	*a = SOAP_DEFAULT_ns3__LightControlType;
#else
	*a = (enum ns3__LightControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__LightControlType[] =
{	{ (long)ns3__LightControlType__LightOn, "LightOn" },
	{ (long)ns3__LightControlType__LightOff, "LightOff" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__LightControlType2s(struct soap *soap, enum ns3__LightControlType n)
{	const char *s = soap_code_str(soap_codes_ns3__LightControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__LightControlType(struct soap *soap, const char *tag, int id, const enum ns3__LightControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__LightControlType), type) || soap_send(soap, soap_ns3__LightControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__LightControlType(struct soap *soap, const char *s, enum ns3__LightControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__LightControlType, s);
	if (map)
		*a = (enum ns3__LightControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__LightControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__LightControlType * SOAP_FMAC4 soap_in_ns3__LightControlType(struct soap *soap, const char *tag, enum ns3__LightControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__LightControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__LightControlType, sizeof(enum ns3__LightControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__LightControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__LightControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__LightControlType, 0, sizeof(enum ns3__LightControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__LightControlType(struct soap *soap, const enum ns3__LightControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__LightControlType);
	if (soap_out_ns3__LightControlType(soap, tag?tag:"ns3:LightControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__LightControlType * SOAP_FMAC4 soap_get_ns3__LightControlType(struct soap *soap, enum ns3__LightControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__LightControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CameraControlType(struct soap *soap, enum ns3__CameraControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__CameraControlType
	*a = SOAP_DEFAULT_ns3__CameraControlType;
#else
	*a = (enum ns3__CameraControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__CameraControlType[] =
{	{ (long)ns3__CameraControlType__ZoomUp, "ZoomUp" },
	{ (long)ns3__CameraControlType__ZoomUpStop, "ZoomUpStop" },
	{ (long)ns3__CameraControlType__ZoomDown, "ZoomDown" },
	{ (long)ns3__CameraControlType__ZoomDownStop, "ZoomDownStop" },
	{ (long)ns3__CameraControlType__FocusNear, "FocusNear" },
	{ (long)ns3__CameraControlType__FocusNearStop, "FocusNearStop" },
	{ (long)ns3__CameraControlType__FocusFar, "FocusFar" },
	{ (long)ns3__CameraControlType__FocusFarStop, "FocusFarStop" },
	{ (long)ns3__CameraControlType__CameraReset, "CameraReset" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__CameraControlType2s(struct soap *soap, enum ns3__CameraControlType n)
{	const char *s = soap_code_str(soap_codes_ns3__CameraControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CameraControlType(struct soap *soap, const char *tag, int id, const enum ns3__CameraControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__CameraControlType), type) || soap_send(soap, soap_ns3__CameraControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__CameraControlType(struct soap *soap, const char *s, enum ns3__CameraControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__CameraControlType, s);
	if (map)
		*a = (enum ns3__CameraControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__CameraControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__CameraControlType * SOAP_FMAC4 soap_in_ns3__CameraControlType(struct soap *soap, const char *tag, enum ns3__CameraControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__CameraControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__CameraControlType, sizeof(enum ns3__CameraControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__CameraControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__CameraControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__CameraControlType, 0, sizeof(enum ns3__CameraControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CameraControlType(struct soap *soap, const enum ns3__CameraControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__CameraControlType);
	if (soap_out_ns3__CameraControlType(soap, tag?tag:"ns3:CameraControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__CameraControlType * SOAP_FMAC4 soap_get_ns3__CameraControlType(struct soap *soap, enum ns3__CameraControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CameraControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__YuntaiControlType(struct soap *soap, enum ns3__YuntaiControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__YuntaiControlType
	*a = SOAP_DEFAULT_ns3__YuntaiControlType;
#else
	*a = (enum ns3__YuntaiControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__YuntaiControlType[] =
{	{ (long)ns3__YuntaiControlType__TurnUp, "TurnUp" },
	{ (long)ns3__YuntaiControlType__TurnDown, "TurnDown" },
	{ (long)ns3__YuntaiControlType__TurnLeft, "TurnLeft" },
	{ (long)ns3__YuntaiControlType__TurnRight, "TurnRight" },
	{ (long)ns3__YuntaiControlType__TurnStop, "TurnStop" },
	{ (long)ns3__YuntaiControlType__TurnReset, "TurnReset" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__YuntaiControlType2s(struct soap *soap, enum ns3__YuntaiControlType n)
{	const char *s = soap_code_str(soap_codes_ns3__YuntaiControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__YuntaiControlType(struct soap *soap, const char *tag, int id, const enum ns3__YuntaiControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__YuntaiControlType), type) || soap_send(soap, soap_ns3__YuntaiControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__YuntaiControlType(struct soap *soap, const char *s, enum ns3__YuntaiControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__YuntaiControlType, s);
	if (map)
		*a = (enum ns3__YuntaiControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__YuntaiControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__YuntaiControlType * SOAP_FMAC4 soap_in_ns3__YuntaiControlType(struct soap *soap, const char *tag, enum ns3__YuntaiControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__YuntaiControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__YuntaiControlType, sizeof(enum ns3__YuntaiControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__YuntaiControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__YuntaiControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__YuntaiControlType, 0, sizeof(enum ns3__YuntaiControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__YuntaiControlType(struct soap *soap, const enum ns3__YuntaiControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__YuntaiControlType);
	if (soap_out_ns3__YuntaiControlType(soap, tag?tag:"ns3:YuntaiControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__YuntaiControlType * SOAP_FMAC4 soap_get_ns3__YuntaiControlType(struct soap *soap, enum ns3__YuntaiControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__YuntaiControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_RobotData_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_RobotData_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_RobotData_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_RobotData_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__string, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns3__GetRobotAlarmInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotAlarmInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotAlarmInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__RobotAlarmInfos(soap, &this->_ns3__GetRobotAlarmInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotAlarmInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotAlarmInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotAlarmInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotAlarmInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotAlarmInfoResponse::Data)
	{	if (soap_out_PointerTons3__RobotAlarmInfos(soap, "Data", -1, &a->_ns3__GetRobotAlarmInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotAlarmInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotAlarmInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotAlarmInfoResponse * SOAP_FMAC4 soap_in__ns3__GetRobotAlarmInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotAlarmInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotAlarmInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse, sizeof(_ns3__GetRobotAlarmInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotAlarmInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__RobotAlarmInfos(soap, "Data", &(a->_ns3__GetRobotAlarmInfoResponse::Data), "ns3:RobotAlarmInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotAlarmInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse, 0, sizeof(_ns3__GetRobotAlarmInfoResponse), 0, soap_copy__ns3__GetRobotAlarmInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotAlarmInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotAlarmInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotAlarmInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotAlarmInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotAlarmInfoResponse * SOAP_FMAC4 soap_get__ns3__GetRobotAlarmInfoResponse(struct soap *soap, _ns3__GetRobotAlarmInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotAlarmInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotAlarmInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotAlarmInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotAlarmInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotAlarmInfoResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotAlarmInfoResponse);
		((_ns3__GetRobotAlarmInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotAlarmInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotAlarmInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotAlarmInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotAlarmInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotAlarmInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotAlarmInfoResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotAlarmInfoResponse*)p = *(_ns3__GetRobotAlarmInfoResponse*)q;
}

void _ns3__GetRobotAlarmInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__GetRobotAlarmInfo::NeedAll);
	/* transient soap skipped */
}

void _ns3__GetRobotAlarmInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotAlarmInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotAlarmInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotAlarmInfo(struct soap *soap, const char *tag, int id, const _ns3__GetRobotAlarmInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo), type))
		return soap->error;
	if (soap_out_bool(soap, "NeedAll", -1, &(a->_ns3__GetRobotAlarmInfo::NeedAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotAlarmInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotAlarmInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotAlarmInfo * SOAP_FMAC4 soap_in__ns3__GetRobotAlarmInfo(struct soap *soap, const char *tag, _ns3__GetRobotAlarmInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotAlarmInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo, sizeof(_ns3__GetRobotAlarmInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotAlarmInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NeedAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NeedAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "NeedAll", &(a->_ns3__GetRobotAlarmInfo::NeedAll), "xsd:boolean"))
				{	soap_flag_NeedAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotAlarmInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo, 0, sizeof(_ns3__GetRobotAlarmInfo), 0, soap_copy__ns3__GetRobotAlarmInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NeedAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotAlarmInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotAlarmInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotAlarmInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotAlarmInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotAlarmInfo * SOAP_FMAC4 soap_get__ns3__GetRobotAlarmInfo(struct soap *soap, _ns3__GetRobotAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotAlarmInfo * SOAP_FMAC2 soap_instantiate__ns3__GetRobotAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotAlarmInfo);
		if (size)
			*size = sizeof(_ns3__GetRobotAlarmInfo);
		((_ns3__GetRobotAlarmInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotAlarmInfo, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotAlarmInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotAlarmInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotAlarmInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotAlarmInfo %p -> %p\n", q, p));
	*(_ns3__GetRobotAlarmInfo*)p = *(_ns3__GetRobotAlarmInfo*)q;
}

void _ns3__GetRobotGasInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotGasInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotGasInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__RobotGasInfos(soap, &this->_ns3__GetRobotGasInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotGasInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotGasInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotGasInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotGasInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotGasInfoResponse::Data)
	{	if (soap_out_PointerTons3__RobotGasInfos(soap, "Data", -1, &a->_ns3__GetRobotGasInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotGasInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotGasInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotGasInfoResponse * SOAP_FMAC4 soap_in__ns3__GetRobotGasInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotGasInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotGasInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse, sizeof(_ns3__GetRobotGasInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotGasInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__RobotGasInfos(soap, "Data", &(a->_ns3__GetRobotGasInfoResponse::Data), "ns3:RobotGasInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotGasInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse, 0, sizeof(_ns3__GetRobotGasInfoResponse), 0, soap_copy__ns3__GetRobotGasInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotGasInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotGasInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotGasInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotGasInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotGasInfoResponse * SOAP_FMAC4 soap_get__ns3__GetRobotGasInfoResponse(struct soap *soap, _ns3__GetRobotGasInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotGasInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotGasInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotGasInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotGasInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotGasInfoResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotGasInfoResponse);
		((_ns3__GetRobotGasInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotGasInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotGasInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotGasInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotGasInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotGasInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotGasInfoResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotGasInfoResponse*)p = *(_ns3__GetRobotGasInfoResponse*)q;
}

void _ns3__GetRobotGasInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__GetRobotGasInfo::NeedAll);
	/* transient soap skipped */
}

void _ns3__GetRobotGasInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotGasInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotGasInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotGasInfo(struct soap *soap, const char *tag, int id, const _ns3__GetRobotGasInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotGasInfo), type))
		return soap->error;
	if (soap_out_bool(soap, "NeedAll", -1, &(a->_ns3__GetRobotGasInfo::NeedAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotGasInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotGasInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotGasInfo * SOAP_FMAC4 soap_in__ns3__GetRobotGasInfo(struct soap *soap, const char *tag, _ns3__GetRobotGasInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotGasInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotGasInfo, sizeof(_ns3__GetRobotGasInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotGasInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotGasInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NeedAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NeedAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "NeedAll", &(a->_ns3__GetRobotGasInfo::NeedAll), "xsd:boolean"))
				{	soap_flag_NeedAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotGasInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotGasInfo, 0, sizeof(_ns3__GetRobotGasInfo), 0, soap_copy__ns3__GetRobotGasInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NeedAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotGasInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotGasInfo);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotGasInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotGasInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotGasInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotGasInfo * SOAP_FMAC4 soap_get__ns3__GetRobotGasInfo(struct soap *soap, _ns3__GetRobotGasInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotGasInfo * SOAP_FMAC2 soap_instantiate__ns3__GetRobotGasInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotGasInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotGasInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotGasInfo);
		if (size)
			*size = sizeof(_ns3__GetRobotGasInfo);
		((_ns3__GetRobotGasInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotGasInfo, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotGasInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotGasInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotGasInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotGasInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotGasInfo %p -> %p\n", q, p));
	*(_ns3__GetRobotGasInfo*)p = *(_ns3__GetRobotGasInfo*)q;
}

void _ns3__GetRobotMileageInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotMileageInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotMileageInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__RobotMileageInfos(soap, &this->_ns3__GetRobotMileageInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotMileageInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotMileageInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotMileageInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotMileageInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotMileageInfoResponse::Data)
	{	if (soap_out_PointerTons3__RobotMileageInfos(soap, "Data", -1, &a->_ns3__GetRobotMileageInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotMileageInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotMileageInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotMileageInfoResponse * SOAP_FMAC4 soap_in__ns3__GetRobotMileageInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotMileageInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotMileageInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse, sizeof(_ns3__GetRobotMileageInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotMileageInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__RobotMileageInfos(soap, "Data", &(a->_ns3__GetRobotMileageInfoResponse::Data), "ns3:RobotMileageInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotMileageInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse, 0, sizeof(_ns3__GetRobotMileageInfoResponse), 0, soap_copy__ns3__GetRobotMileageInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotMileageInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotMileageInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotMileageInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotMileageInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotMileageInfoResponse * SOAP_FMAC4 soap_get__ns3__GetRobotMileageInfoResponse(struct soap *soap, _ns3__GetRobotMileageInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotMileageInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotMileageInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotMileageInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotMileageInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotMileageInfoResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotMileageInfoResponse);
		((_ns3__GetRobotMileageInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotMileageInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotMileageInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotMileageInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotMileageInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotMileageInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotMileageInfoResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotMileageInfoResponse*)p = *(_ns3__GetRobotMileageInfoResponse*)q;
}

void _ns3__GetRobotMileageInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__GetRobotMileageInfo::NeedAll);
	/* transient soap skipped */
}

void _ns3__GetRobotMileageInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotMileageInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotMileageInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotMileageInfo(struct soap *soap, const char *tag, int id, const _ns3__GetRobotMileageInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo), type))
		return soap->error;
	if (soap_out_bool(soap, "NeedAll", -1, &(a->_ns3__GetRobotMileageInfo::NeedAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotMileageInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotMileageInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotMileageInfo * SOAP_FMAC4 soap_in__ns3__GetRobotMileageInfo(struct soap *soap, const char *tag, _ns3__GetRobotMileageInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotMileageInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo, sizeof(_ns3__GetRobotMileageInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotMileageInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NeedAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NeedAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "NeedAll", &(a->_ns3__GetRobotMileageInfo::NeedAll), "xsd:boolean"))
				{	soap_flag_NeedAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotMileageInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo, 0, sizeof(_ns3__GetRobotMileageInfo), 0, soap_copy__ns3__GetRobotMileageInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NeedAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotMileageInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotMileageInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotMileageInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotMileageInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotMileageInfo * SOAP_FMAC4 soap_get__ns3__GetRobotMileageInfo(struct soap *soap, _ns3__GetRobotMileageInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotMileageInfo * SOAP_FMAC2 soap_instantiate__ns3__GetRobotMileageInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotMileageInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotMileageInfo);
		if (size)
			*size = sizeof(_ns3__GetRobotMileageInfo);
		((_ns3__GetRobotMileageInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotMileageInfo, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotMileageInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotMileageInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotMileageInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotMileageInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotMileageInfo %p -> %p\n", q, p));
	*(_ns3__GetRobotMileageInfo*)p = *(_ns3__GetRobotMileageInfo*)q;
}

void _ns3__GetRobotYunTaiInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotYunTaiInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotYunTaiInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__RobotYunTaiInfos(soap, &this->_ns3__GetRobotYunTaiInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotYunTaiInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotYunTaiInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotYunTaiInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotYunTaiInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotYunTaiInfoResponse::Data)
	{	if (soap_out_PointerTons3__RobotYunTaiInfos(soap, "Data", -1, &a->_ns3__GetRobotYunTaiInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotYunTaiInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotYunTaiInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotYunTaiInfoResponse * SOAP_FMAC4 soap_in__ns3__GetRobotYunTaiInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotYunTaiInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotYunTaiInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse, sizeof(_ns3__GetRobotYunTaiInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotYunTaiInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__RobotYunTaiInfos(soap, "Data", &(a->_ns3__GetRobotYunTaiInfoResponse::Data), "ns3:RobotYunTaiInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotYunTaiInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse, 0, sizeof(_ns3__GetRobotYunTaiInfoResponse), 0, soap_copy__ns3__GetRobotYunTaiInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotYunTaiInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotYunTaiInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotYunTaiInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotYunTaiInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotYunTaiInfoResponse * SOAP_FMAC4 soap_get__ns3__GetRobotYunTaiInfoResponse(struct soap *soap, _ns3__GetRobotYunTaiInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotYunTaiInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotYunTaiInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotYunTaiInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotYunTaiInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotYunTaiInfoResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotYunTaiInfoResponse);
		((_ns3__GetRobotYunTaiInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotYunTaiInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotYunTaiInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotYunTaiInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotYunTaiInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotYunTaiInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotYunTaiInfoResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotYunTaiInfoResponse*)p = *(_ns3__GetRobotYunTaiInfoResponse*)q;
}

void _ns3__GetRobotYunTaiInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__GetRobotYunTaiInfo::NeedAll);
	/* transient soap skipped */
}

void _ns3__GetRobotYunTaiInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotYunTaiInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotYunTaiInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotYunTaiInfo(struct soap *soap, const char *tag, int id, const _ns3__GetRobotYunTaiInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo), type))
		return soap->error;
	if (soap_out_bool(soap, "NeedAll", -1, &(a->_ns3__GetRobotYunTaiInfo::NeedAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotYunTaiInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotYunTaiInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotYunTaiInfo * SOAP_FMAC4 soap_in__ns3__GetRobotYunTaiInfo(struct soap *soap, const char *tag, _ns3__GetRobotYunTaiInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotYunTaiInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo, sizeof(_ns3__GetRobotYunTaiInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotYunTaiInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NeedAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NeedAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "NeedAll", &(a->_ns3__GetRobotYunTaiInfo::NeedAll), "xsd:boolean"))
				{	soap_flag_NeedAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotYunTaiInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo, 0, sizeof(_ns3__GetRobotYunTaiInfo), 0, soap_copy__ns3__GetRobotYunTaiInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NeedAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotYunTaiInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotYunTaiInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotYunTaiInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotYunTaiInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotYunTaiInfo * SOAP_FMAC4 soap_get__ns3__GetRobotYunTaiInfo(struct soap *soap, _ns3__GetRobotYunTaiInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotYunTaiInfo * SOAP_FMAC2 soap_instantiate__ns3__GetRobotYunTaiInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotYunTaiInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotYunTaiInfo);
		if (size)
			*size = sizeof(_ns3__GetRobotYunTaiInfo);
		((_ns3__GetRobotYunTaiInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotYunTaiInfo, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotYunTaiInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotYunTaiInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotYunTaiInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotYunTaiInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotYunTaiInfo %p -> %p\n", q, p));
	*(_ns3__GetRobotYunTaiInfo*)p = *(_ns3__GetRobotYunTaiInfo*)q;
}

void _ns3__GetRobotPosInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotPosInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotPosInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__RobotPosInfos(soap, &this->_ns3__GetRobotPosInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotPosInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotPosInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotPosInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotPosInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotPosInfoResponse::Data)
	{	if (soap_out_PointerTons3__RobotPosInfos(soap, "Data", -1, &a->_ns3__GetRobotPosInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotPosInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotPosInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotPosInfoResponse * SOAP_FMAC4 soap_in__ns3__GetRobotPosInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotPosInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotPosInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse, sizeof(_ns3__GetRobotPosInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotPosInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__RobotPosInfos(soap, "Data", &(a->_ns3__GetRobotPosInfoResponse::Data), "ns3:RobotPosInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotPosInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse, 0, sizeof(_ns3__GetRobotPosInfoResponse), 0, soap_copy__ns3__GetRobotPosInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotPosInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotPosInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotPosInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotPosInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotPosInfoResponse * SOAP_FMAC4 soap_get__ns3__GetRobotPosInfoResponse(struct soap *soap, _ns3__GetRobotPosInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotPosInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotPosInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotPosInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotPosInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotPosInfoResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotPosInfoResponse);
		((_ns3__GetRobotPosInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotPosInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotPosInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotPosInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotPosInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotPosInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotPosInfoResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotPosInfoResponse*)p = *(_ns3__GetRobotPosInfoResponse*)q;
}

void _ns3__GetRobotPosInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__GetRobotPosInfo::NeedAll);
	/* transient soap skipped */
}

void _ns3__GetRobotPosInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotPosInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotPosInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotPosInfo(struct soap *soap, const char *tag, int id, const _ns3__GetRobotPosInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotPosInfo), type))
		return soap->error;
	if (soap_out_bool(soap, "NeedAll", -1, &(a->_ns3__GetRobotPosInfo::NeedAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotPosInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotPosInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotPosInfo * SOAP_FMAC4 soap_in__ns3__GetRobotPosInfo(struct soap *soap, const char *tag, _ns3__GetRobotPosInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotPosInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotPosInfo, sizeof(_ns3__GetRobotPosInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotPosInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotPosInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NeedAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NeedAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "NeedAll", &(a->_ns3__GetRobotPosInfo::NeedAll), "xsd:boolean"))
				{	soap_flag_NeedAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotPosInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotPosInfo, 0, sizeof(_ns3__GetRobotPosInfo), 0, soap_copy__ns3__GetRobotPosInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NeedAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotPosInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotPosInfo);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotPosInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotPosInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotPosInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotPosInfo * SOAP_FMAC4 soap_get__ns3__GetRobotPosInfo(struct soap *soap, _ns3__GetRobotPosInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotPosInfo * SOAP_FMAC2 soap_instantiate__ns3__GetRobotPosInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotPosInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotPosInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotPosInfo);
		if (size)
			*size = sizeof(_ns3__GetRobotPosInfo);
		((_ns3__GetRobotPosInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotPosInfo, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotPosInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotPosInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotPosInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotPosInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotPosInfo %p -> %p\n", q, p));
	*(_ns3__GetRobotPosInfo*)p = *(_ns3__GetRobotPosInfo*)q;
}

void _ns3__GetRobotTaskStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotTaskStateResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotTaskStateResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__RobotTaskStates(soap, &this->_ns3__GetRobotTaskStateResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotTaskStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotTaskStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotTaskStateResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotTaskStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotTaskStateResponse::Data)
	{	if (soap_out_PointerTons3__RobotTaskStates(soap, "Data", -1, &a->_ns3__GetRobotTaskStateResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotTaskStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotTaskStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotTaskStateResponse * SOAP_FMAC4 soap_in__ns3__GetRobotTaskStateResponse(struct soap *soap, const char *tag, _ns3__GetRobotTaskStateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotTaskStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse, sizeof(_ns3__GetRobotTaskStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotTaskStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__RobotTaskStates(soap, "Data", &(a->_ns3__GetRobotTaskStateResponse::Data), "ns3:RobotTaskStates"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotTaskStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse, 0, sizeof(_ns3__GetRobotTaskStateResponse), 0, soap_copy__ns3__GetRobotTaskStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotTaskStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotTaskStateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotTaskStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotTaskStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotTaskStateResponse * SOAP_FMAC4 soap_get__ns3__GetRobotTaskStateResponse(struct soap *soap, _ns3__GetRobotTaskStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotTaskStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotTaskStateResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotTaskStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotTaskStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotTaskStateResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotTaskStateResponse);
		((_ns3__GetRobotTaskStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotTaskStateResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotTaskStateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotTaskStateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotTaskStateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotTaskStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotTaskStateResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotTaskStateResponse*)p = *(_ns3__GetRobotTaskStateResponse*)q;
}

void _ns3__GetRobotTaskState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__GetRobotTaskState::NeedAll);
	/* transient soap skipped */
}

void _ns3__GetRobotTaskState::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotTaskState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotTaskState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotTaskState(struct soap *soap, const char *tag, int id, const _ns3__GetRobotTaskState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotTaskState), type))
		return soap->error;
	if (soap_out_bool(soap, "NeedAll", -1, &(a->_ns3__GetRobotTaskState::NeedAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotTaskState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotTaskState(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotTaskState * SOAP_FMAC4 soap_in__ns3__GetRobotTaskState(struct soap *soap, const char *tag, _ns3__GetRobotTaskState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotTaskState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotTaskState, sizeof(_ns3__GetRobotTaskState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotTaskState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotTaskState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NeedAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NeedAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "NeedAll", &(a->_ns3__GetRobotTaskState::NeedAll), "xsd:boolean"))
				{	soap_flag_NeedAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotTaskState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotTaskState, 0, sizeof(_ns3__GetRobotTaskState), 0, soap_copy__ns3__GetRobotTaskState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NeedAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotTaskState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotTaskState);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotTaskState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotTaskState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotTaskState(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotTaskState * SOAP_FMAC4 soap_get__ns3__GetRobotTaskState(struct soap *soap, _ns3__GetRobotTaskState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotTaskState * SOAP_FMAC2 soap_instantiate__ns3__GetRobotTaskState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotTaskState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotTaskState, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotTaskState);
		if (size)
			*size = sizeof(_ns3__GetRobotTaskState);
		((_ns3__GetRobotTaskState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotTaskState, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotTaskState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotTaskState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotTaskState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotTaskState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotTaskState %p -> %p\n", q, p));
	*(_ns3__GetRobotTaskState*)p = *(_ns3__GetRobotTaskState*)q;
}

void _ns3__GetRobotSpeedInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotSpeedInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotSpeedInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__SpeedInfos(soap, &this->_ns3__GetRobotSpeedInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotSpeedInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotSpeedInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotSpeedInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotSpeedInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotSpeedInfoResponse::Data)
	{	if (soap_out_PointerTons3__SpeedInfos(soap, "Data", -1, &a->_ns3__GetRobotSpeedInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotSpeedInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotSpeedInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotSpeedInfoResponse * SOAP_FMAC4 soap_in__ns3__GetRobotSpeedInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotSpeedInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotSpeedInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse, sizeof(_ns3__GetRobotSpeedInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotSpeedInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__SpeedInfos(soap, "Data", &(a->_ns3__GetRobotSpeedInfoResponse::Data), "ns3:SpeedInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotSpeedInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse, 0, sizeof(_ns3__GetRobotSpeedInfoResponse), 0, soap_copy__ns3__GetRobotSpeedInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotSpeedInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotSpeedInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotSpeedInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotSpeedInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotSpeedInfoResponse * SOAP_FMAC4 soap_get__ns3__GetRobotSpeedInfoResponse(struct soap *soap, _ns3__GetRobotSpeedInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotSpeedInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotSpeedInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotSpeedInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotSpeedInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotSpeedInfoResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotSpeedInfoResponse);
		((_ns3__GetRobotSpeedInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotSpeedInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotSpeedInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotSpeedInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotSpeedInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotSpeedInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotSpeedInfoResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotSpeedInfoResponse*)p = *(_ns3__GetRobotSpeedInfoResponse*)q;
}

void _ns3__GetRobotSpeedInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__GetRobotSpeedInfo::NeedAll);
	/* transient soap skipped */
}

void _ns3__GetRobotSpeedInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotSpeedInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotSpeedInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotSpeedInfo(struct soap *soap, const char *tag, int id, const _ns3__GetRobotSpeedInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo), type))
		return soap->error;
	if (soap_out_bool(soap, "NeedAll", -1, &(a->_ns3__GetRobotSpeedInfo::NeedAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotSpeedInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotSpeedInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotSpeedInfo * SOAP_FMAC4 soap_in__ns3__GetRobotSpeedInfo(struct soap *soap, const char *tag, _ns3__GetRobotSpeedInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotSpeedInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo, sizeof(_ns3__GetRobotSpeedInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotSpeedInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NeedAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NeedAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "NeedAll", &(a->_ns3__GetRobotSpeedInfo::NeedAll), "xsd:boolean"))
				{	soap_flag_NeedAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotSpeedInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo, 0, sizeof(_ns3__GetRobotSpeedInfo), 0, soap_copy__ns3__GetRobotSpeedInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NeedAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotSpeedInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotSpeedInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotSpeedInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotSpeedInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotSpeedInfo * SOAP_FMAC4 soap_get__ns3__GetRobotSpeedInfo(struct soap *soap, _ns3__GetRobotSpeedInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotSpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotSpeedInfo * SOAP_FMAC2 soap_instantiate__ns3__GetRobotSpeedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotSpeedInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotSpeedInfo);
		if (size)
			*size = sizeof(_ns3__GetRobotSpeedInfo);
		((_ns3__GetRobotSpeedInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotSpeedInfo, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotSpeedInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotSpeedInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotSpeedInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotSpeedInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotSpeedInfo %p -> %p\n", q, p));
	*(_ns3__GetRobotSpeedInfo*)p = *(_ns3__GetRobotSpeedInfo*)q;
}

void _ns3__GetRobotBatteryInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotBatteryInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotBatteryInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__BatteryInfos(soap, &this->_ns3__GetRobotBatteryInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotBatteryInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotBatteryInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotBatteryInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotBatteryInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotBatteryInfoResponse::Data)
	{	if (soap_out_PointerTons3__BatteryInfos(soap, "Data", -1, &a->_ns3__GetRobotBatteryInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotBatteryInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotBatteryInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotBatteryInfoResponse * SOAP_FMAC4 soap_in__ns3__GetRobotBatteryInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotBatteryInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotBatteryInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse, sizeof(_ns3__GetRobotBatteryInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotBatteryInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__BatteryInfos(soap, "Data", &(a->_ns3__GetRobotBatteryInfoResponse::Data), "ns3:BatteryInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotBatteryInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse, 0, sizeof(_ns3__GetRobotBatteryInfoResponse), 0, soap_copy__ns3__GetRobotBatteryInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotBatteryInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotBatteryInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotBatteryInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotBatteryInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotBatteryInfoResponse * SOAP_FMAC4 soap_get__ns3__GetRobotBatteryInfoResponse(struct soap *soap, _ns3__GetRobotBatteryInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotBatteryInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotBatteryInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotBatteryInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotBatteryInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotBatteryInfoResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotBatteryInfoResponse);
		((_ns3__GetRobotBatteryInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotBatteryInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotBatteryInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotBatteryInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotBatteryInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotBatteryInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotBatteryInfoResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotBatteryInfoResponse*)p = *(_ns3__GetRobotBatteryInfoResponse*)q;
}

void _ns3__GetRobotBatteryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__GetRobotBatteryInfo::NeedAll);
	/* transient soap skipped */
}

void _ns3__GetRobotBatteryInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotBatteryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotBatteryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotBatteryInfo(struct soap *soap, const char *tag, int id, const _ns3__GetRobotBatteryInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo), type))
		return soap->error;
	if (soap_out_bool(soap, "NeedAll", -1, &(a->_ns3__GetRobotBatteryInfo::NeedAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotBatteryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotBatteryInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotBatteryInfo * SOAP_FMAC4 soap_in__ns3__GetRobotBatteryInfo(struct soap *soap, const char *tag, _ns3__GetRobotBatteryInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotBatteryInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo, sizeof(_ns3__GetRobotBatteryInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotBatteryInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NeedAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NeedAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "NeedAll", &(a->_ns3__GetRobotBatteryInfo::NeedAll), "xsd:boolean"))
				{	soap_flag_NeedAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotBatteryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo, 0, sizeof(_ns3__GetRobotBatteryInfo), 0, soap_copy__ns3__GetRobotBatteryInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NeedAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotBatteryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotBatteryInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotBatteryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotBatteryInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotBatteryInfo * SOAP_FMAC4 soap_get__ns3__GetRobotBatteryInfo(struct soap *soap, _ns3__GetRobotBatteryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotBatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotBatteryInfo * SOAP_FMAC2 soap_instantiate__ns3__GetRobotBatteryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotBatteryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotBatteryInfo);
		if (size)
			*size = sizeof(_ns3__GetRobotBatteryInfo);
		((_ns3__GetRobotBatteryInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotBatteryInfo, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotBatteryInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotBatteryInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotBatteryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotBatteryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotBatteryInfo %p -> %p\n", q, p));
	*(_ns3__GetRobotBatteryInfo*)p = *(_ns3__GetRobotBatteryInfo*)q;
}

void _ns3__RobotPdControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__RobotPdControlResponse::Result);
	/* transient soap skipped */
}

void _ns3__RobotPdControlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotPdControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotPdControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotPdControlResponse(struct soap *soap, const char *tag, int id, const _ns3__RobotPdControlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotPdControlResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__RobotPdControlResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotPdControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotPdControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotPdControlResponse * SOAP_FMAC4 soap_in__ns3__RobotPdControlResponse(struct soap *soap, const char *tag, _ns3__RobotPdControlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotPdControlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotPdControlResponse, sizeof(_ns3__RobotPdControlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotPdControlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotPdControlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__RobotPdControlResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotPdControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotPdControlResponse, 0, sizeof(_ns3__RobotPdControlResponse), 0, soap_copy__ns3__RobotPdControlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotPdControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotPdControlResponse);
	if (this->soap_out(soap, tag?tag:"ns3:RobotPdControlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotPdControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotPdControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotPdControlResponse * SOAP_FMAC4 soap_get__ns3__RobotPdControlResponse(struct soap *soap, _ns3__RobotPdControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotPdControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotPdControlResponse * SOAP_FMAC2 soap_instantiate__ns3__RobotPdControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotPdControlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotPdControlResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotPdControlResponse);
		if (size)
			*size = sizeof(_ns3__RobotPdControlResponse);
		((_ns3__RobotPdControlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotPdControlResponse, n);
		if (size)
			*size = n * sizeof(_ns3__RobotPdControlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotPdControlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotPdControlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotPdControlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotPdControlResponse %p -> %p\n", q, p));
	*(_ns3__RobotPdControlResponse*)p = *(_ns3__RobotPdControlResponse*)q;
}

void _ns3__RobotPdControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__PdControlType(soap, &this->_ns3__RobotPdControl::Type);
	/* transient soap skipped */
}

void _ns3__RobotPdControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotPdControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotPdControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotPdControl(struct soap *soap, const char *tag, int id, const _ns3__RobotPdControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotPdControl), type))
		return soap->error;
	if (soap_out_ns3__PdControlType(soap, "Type", -1, &(a->_ns3__RobotPdControl::Type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotPdControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotPdControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotPdControl * SOAP_FMAC4 soap_in__ns3__RobotPdControl(struct soap *soap, const char *tag, _ns3__RobotPdControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotPdControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotPdControl, sizeof(_ns3__RobotPdControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotPdControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotPdControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns3__PdControlType(soap, "Type", &(a->_ns3__RobotPdControl::Type), "ns3:PdControlType"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotPdControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotPdControl, 0, sizeof(_ns3__RobotPdControl), 0, soap_copy__ns3__RobotPdControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotPdControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotPdControl);
	if (this->soap_out(soap, tag?tag:"ns3:RobotPdControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotPdControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotPdControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotPdControl * SOAP_FMAC4 soap_get__ns3__RobotPdControl(struct soap *soap, _ns3__RobotPdControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotPdControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotPdControl * SOAP_FMAC2 soap_instantiate__ns3__RobotPdControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotPdControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotPdControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotPdControl);
		if (size)
			*size = sizeof(_ns3__RobotPdControl);
		((_ns3__RobotPdControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotPdControl, n);
		if (size)
			*size = n * sizeof(_ns3__RobotPdControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotPdControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotPdControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotPdControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotPdControl %p -> %p\n", q, p));
	*(_ns3__RobotPdControl*)p = *(_ns3__RobotPdControl*)q;
}

void _ns3__RobotLifterControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__RobotLifterControlResponse::Result);
	/* transient soap skipped */
}

void _ns3__RobotLifterControlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotLifterControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotLifterControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotLifterControlResponse(struct soap *soap, const char *tag, int id, const _ns3__RobotLifterControlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__RobotLifterControlResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotLifterControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotLifterControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotLifterControlResponse * SOAP_FMAC4 soap_in__ns3__RobotLifterControlResponse(struct soap *soap, const char *tag, _ns3__RobotLifterControlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotLifterControlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse, sizeof(_ns3__RobotLifterControlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotLifterControlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__RobotLifterControlResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotLifterControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse, 0, sizeof(_ns3__RobotLifterControlResponse), 0, soap_copy__ns3__RobotLifterControlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotLifterControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse);
	if (this->soap_out(soap, tag?tag:"ns3:RobotLifterControlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotLifterControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotLifterControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotLifterControlResponse * SOAP_FMAC4 soap_get__ns3__RobotLifterControlResponse(struct soap *soap, _ns3__RobotLifterControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotLifterControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotLifterControlResponse * SOAP_FMAC2 soap_instantiate__ns3__RobotLifterControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotLifterControlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotLifterControlResponse);
		if (size)
			*size = sizeof(_ns3__RobotLifterControlResponse);
		((_ns3__RobotLifterControlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotLifterControlResponse, n);
		if (size)
			*size = n * sizeof(_ns3__RobotLifterControlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotLifterControlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotLifterControlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotLifterControlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotLifterControlResponse %p -> %p\n", q, p));
	*(_ns3__RobotLifterControlResponse*)p = *(_ns3__RobotLifterControlResponse*)q;
}

void _ns3__RobotLifterControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__LifterControlType(soap, &this->_ns3__RobotLifterControl::Type);
	/* transient soap skipped */
}

void _ns3__RobotLifterControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotLifterControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotLifterControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotLifterControl(struct soap *soap, const char *tag, int id, const _ns3__RobotLifterControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotLifterControl), type))
		return soap->error;
	if (soap_out_ns3__LifterControlType(soap, "Type", -1, &(a->_ns3__RobotLifterControl::Type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotLifterControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotLifterControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotLifterControl * SOAP_FMAC4 soap_in__ns3__RobotLifterControl(struct soap *soap, const char *tag, _ns3__RobotLifterControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotLifterControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotLifterControl, sizeof(_ns3__RobotLifterControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotLifterControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotLifterControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns3__LifterControlType(soap, "Type", &(a->_ns3__RobotLifterControl::Type), "ns3:LifterControlType"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotLifterControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotLifterControl, 0, sizeof(_ns3__RobotLifterControl), 0, soap_copy__ns3__RobotLifterControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotLifterControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotLifterControl);
	if (this->soap_out(soap, tag?tag:"ns3:RobotLifterControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotLifterControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotLifterControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotLifterControl * SOAP_FMAC4 soap_get__ns3__RobotLifterControl(struct soap *soap, _ns3__RobotLifterControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotLifterControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotLifterControl * SOAP_FMAC2 soap_instantiate__ns3__RobotLifterControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotLifterControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotLifterControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotLifterControl);
		if (size)
			*size = sizeof(_ns3__RobotLifterControl);
		((_ns3__RobotLifterControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotLifterControl, n);
		if (size)
			*size = n * sizeof(_ns3__RobotLifterControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotLifterControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotLifterControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotLifterControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotLifterControl %p -> %p\n", q, p));
	*(_ns3__RobotLifterControl*)p = *(_ns3__RobotLifterControl*)q;
}

void _ns3__RobotFlirControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__RobotFlirControlResponse::Result);
	/* transient soap skipped */
}

void _ns3__RobotFlirControlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotFlirControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotFlirControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotFlirControlResponse(struct soap *soap, const char *tag, int id, const _ns3__RobotFlirControlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__RobotFlirControlResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotFlirControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotFlirControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotFlirControlResponse * SOAP_FMAC4 soap_in__ns3__RobotFlirControlResponse(struct soap *soap, const char *tag, _ns3__RobotFlirControlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotFlirControlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse, sizeof(_ns3__RobotFlirControlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotFlirControlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__RobotFlirControlResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotFlirControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse, 0, sizeof(_ns3__RobotFlirControlResponse), 0, soap_copy__ns3__RobotFlirControlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotFlirControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse);
	if (this->soap_out(soap, tag?tag:"ns3:RobotFlirControlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotFlirControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotFlirControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotFlirControlResponse * SOAP_FMAC4 soap_get__ns3__RobotFlirControlResponse(struct soap *soap, _ns3__RobotFlirControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotFlirControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotFlirControlResponse * SOAP_FMAC2 soap_instantiate__ns3__RobotFlirControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotFlirControlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotFlirControlResponse);
		if (size)
			*size = sizeof(_ns3__RobotFlirControlResponse);
		((_ns3__RobotFlirControlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotFlirControlResponse, n);
		if (size)
			*size = n * sizeof(_ns3__RobotFlirControlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotFlirControlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotFlirControlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotFlirControlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotFlirControlResponse %p -> %p\n", q, p));
	*(_ns3__RobotFlirControlResponse*)p = *(_ns3__RobotFlirControlResponse*)q;
}

void _ns3__RobotFlirControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__FilrControlType(soap, &this->_ns3__RobotFlirControl::Type);
	/* transient soap skipped */
}

void _ns3__RobotFlirControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotFlirControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotFlirControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotFlirControl(struct soap *soap, const char *tag, int id, const _ns3__RobotFlirControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotFlirControl), type))
		return soap->error;
	if (soap_out_ns3__FilrControlType(soap, "Type", -1, &(a->_ns3__RobotFlirControl::Type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotFlirControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotFlirControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotFlirControl * SOAP_FMAC4 soap_in__ns3__RobotFlirControl(struct soap *soap, const char *tag, _ns3__RobotFlirControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotFlirControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotFlirControl, sizeof(_ns3__RobotFlirControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotFlirControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotFlirControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns3__FilrControlType(soap, "Type", &(a->_ns3__RobotFlirControl::Type), "ns3:FilrControlType"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotFlirControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotFlirControl, 0, sizeof(_ns3__RobotFlirControl), 0, soap_copy__ns3__RobotFlirControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotFlirControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotFlirControl);
	if (this->soap_out(soap, tag?tag:"ns3:RobotFlirControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotFlirControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotFlirControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotFlirControl * SOAP_FMAC4 soap_get__ns3__RobotFlirControl(struct soap *soap, _ns3__RobotFlirControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotFlirControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotFlirControl * SOAP_FMAC2 soap_instantiate__ns3__RobotFlirControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotFlirControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotFlirControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotFlirControl);
		if (size)
			*size = sizeof(_ns3__RobotFlirControl);
		((_ns3__RobotFlirControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotFlirControl, n);
		if (size)
			*size = n * sizeof(_ns3__RobotFlirControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotFlirControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotFlirControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotFlirControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotFlirControl %p -> %p\n", q, p));
	*(_ns3__RobotFlirControl*)p = *(_ns3__RobotFlirControl*)q;
}

void _ns3__RobotWiperControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__RobotWiperControlResponse::Result);
	/* transient soap skipped */
}

void _ns3__RobotWiperControlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotWiperControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotWiperControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotWiperControlResponse(struct soap *soap, const char *tag, int id, const _ns3__RobotWiperControlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__RobotWiperControlResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotWiperControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotWiperControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotWiperControlResponse * SOAP_FMAC4 soap_in__ns3__RobotWiperControlResponse(struct soap *soap, const char *tag, _ns3__RobotWiperControlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotWiperControlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse, sizeof(_ns3__RobotWiperControlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotWiperControlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__RobotWiperControlResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotWiperControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse, 0, sizeof(_ns3__RobotWiperControlResponse), 0, soap_copy__ns3__RobotWiperControlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotWiperControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse);
	if (this->soap_out(soap, tag?tag:"ns3:RobotWiperControlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotWiperControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotWiperControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotWiperControlResponse * SOAP_FMAC4 soap_get__ns3__RobotWiperControlResponse(struct soap *soap, _ns3__RobotWiperControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotWiperControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotWiperControlResponse * SOAP_FMAC2 soap_instantiate__ns3__RobotWiperControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotWiperControlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotWiperControlResponse);
		if (size)
			*size = sizeof(_ns3__RobotWiperControlResponse);
		((_ns3__RobotWiperControlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotWiperControlResponse, n);
		if (size)
			*size = n * sizeof(_ns3__RobotWiperControlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotWiperControlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotWiperControlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotWiperControlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotWiperControlResponse %p -> %p\n", q, p));
	*(_ns3__RobotWiperControlResponse*)p = *(_ns3__RobotWiperControlResponse*)q;
}

void _ns3__RobotWiperControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__WiperControlType(soap, &this->_ns3__RobotWiperControl::Type);
	/* transient soap skipped */
}

void _ns3__RobotWiperControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotWiperControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotWiperControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotWiperControl(struct soap *soap, const char *tag, int id, const _ns3__RobotWiperControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotWiperControl), type))
		return soap->error;
	if (soap_out_ns3__WiperControlType(soap, "Type", -1, &(a->_ns3__RobotWiperControl::Type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotWiperControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotWiperControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotWiperControl * SOAP_FMAC4 soap_in__ns3__RobotWiperControl(struct soap *soap, const char *tag, _ns3__RobotWiperControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotWiperControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotWiperControl, sizeof(_ns3__RobotWiperControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotWiperControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotWiperControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns3__WiperControlType(soap, "Type", &(a->_ns3__RobotWiperControl::Type), "ns3:WiperControlType"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotWiperControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotWiperControl, 0, sizeof(_ns3__RobotWiperControl), 0, soap_copy__ns3__RobotWiperControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotWiperControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotWiperControl);
	if (this->soap_out(soap, tag?tag:"ns3:RobotWiperControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotWiperControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotWiperControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotWiperControl * SOAP_FMAC4 soap_get__ns3__RobotWiperControl(struct soap *soap, _ns3__RobotWiperControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotWiperControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotWiperControl * SOAP_FMAC2 soap_instantiate__ns3__RobotWiperControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotWiperControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotWiperControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotWiperControl);
		if (size)
			*size = sizeof(_ns3__RobotWiperControl);
		((_ns3__RobotWiperControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotWiperControl, n);
		if (size)
			*size = n * sizeof(_ns3__RobotWiperControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotWiperControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotWiperControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotWiperControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotWiperControl %p -> %p\n", q, p));
	*(_ns3__RobotWiperControl*)p = *(_ns3__RobotWiperControl*)q;
}

void _ns3__RobotLightControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__RobotLightControlResponse::Result);
	/* transient soap skipped */
}

void _ns3__RobotLightControlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotLightControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotLightControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotLightControlResponse(struct soap *soap, const char *tag, int id, const _ns3__RobotLightControlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotLightControlResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__RobotLightControlResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotLightControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotLightControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotLightControlResponse * SOAP_FMAC4 soap_in__ns3__RobotLightControlResponse(struct soap *soap, const char *tag, _ns3__RobotLightControlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotLightControlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotLightControlResponse, sizeof(_ns3__RobotLightControlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotLightControlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotLightControlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__RobotLightControlResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotLightControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotLightControlResponse, 0, sizeof(_ns3__RobotLightControlResponse), 0, soap_copy__ns3__RobotLightControlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotLightControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotLightControlResponse);
	if (this->soap_out(soap, tag?tag:"ns3:RobotLightControlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotLightControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotLightControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotLightControlResponse * SOAP_FMAC4 soap_get__ns3__RobotLightControlResponse(struct soap *soap, _ns3__RobotLightControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotLightControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotLightControlResponse * SOAP_FMAC2 soap_instantiate__ns3__RobotLightControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotLightControlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotLightControlResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotLightControlResponse);
		if (size)
			*size = sizeof(_ns3__RobotLightControlResponse);
		((_ns3__RobotLightControlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotLightControlResponse, n);
		if (size)
			*size = n * sizeof(_ns3__RobotLightControlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotLightControlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotLightControlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotLightControlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotLightControlResponse %p -> %p\n", q, p));
	*(_ns3__RobotLightControlResponse*)p = *(_ns3__RobotLightControlResponse*)q;
}

void _ns3__RobotLightControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__LightControlType(soap, &this->_ns3__RobotLightControl::Type);
	/* transient soap skipped */
}

void _ns3__RobotLightControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotLightControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotLightControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotLightControl(struct soap *soap, const char *tag, int id, const _ns3__RobotLightControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotLightControl), type))
		return soap->error;
	if (soap_out_ns3__LightControlType(soap, "Type", -1, &(a->_ns3__RobotLightControl::Type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotLightControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotLightControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotLightControl * SOAP_FMAC4 soap_in__ns3__RobotLightControl(struct soap *soap, const char *tag, _ns3__RobotLightControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotLightControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotLightControl, sizeof(_ns3__RobotLightControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotLightControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotLightControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns3__LightControlType(soap, "Type", &(a->_ns3__RobotLightControl::Type), "ns3:LightControlType"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotLightControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotLightControl, 0, sizeof(_ns3__RobotLightControl), 0, soap_copy__ns3__RobotLightControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotLightControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotLightControl);
	if (this->soap_out(soap, tag?tag:"ns3:RobotLightControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotLightControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotLightControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotLightControl * SOAP_FMAC4 soap_get__ns3__RobotLightControl(struct soap *soap, _ns3__RobotLightControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotLightControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotLightControl * SOAP_FMAC2 soap_instantiate__ns3__RobotLightControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotLightControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotLightControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotLightControl);
		if (size)
			*size = sizeof(_ns3__RobotLightControl);
		((_ns3__RobotLightControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotLightControl, n);
		if (size)
			*size = n * sizeof(_ns3__RobotLightControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotLightControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotLightControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotLightControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotLightControl %p -> %p\n", q, p));
	*(_ns3__RobotLightControl*)p = *(_ns3__RobotLightControl*)q;
}

void _ns3__RobotCameraControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__RobotCameraControlResponse::Result);
	/* transient soap skipped */
}

void _ns3__RobotCameraControlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotCameraControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotCameraControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotCameraControlResponse(struct soap *soap, const char *tag, int id, const _ns3__RobotCameraControlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__RobotCameraControlResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotCameraControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotCameraControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotCameraControlResponse * SOAP_FMAC4 soap_in__ns3__RobotCameraControlResponse(struct soap *soap, const char *tag, _ns3__RobotCameraControlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotCameraControlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse, sizeof(_ns3__RobotCameraControlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotCameraControlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__RobotCameraControlResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotCameraControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse, 0, sizeof(_ns3__RobotCameraControlResponse), 0, soap_copy__ns3__RobotCameraControlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotCameraControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse);
	if (this->soap_out(soap, tag?tag:"ns3:RobotCameraControlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotCameraControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotCameraControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotCameraControlResponse * SOAP_FMAC4 soap_get__ns3__RobotCameraControlResponse(struct soap *soap, _ns3__RobotCameraControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotCameraControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotCameraControlResponse * SOAP_FMAC2 soap_instantiate__ns3__RobotCameraControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotCameraControlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotCameraControlResponse);
		if (size)
			*size = sizeof(_ns3__RobotCameraControlResponse);
		((_ns3__RobotCameraControlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotCameraControlResponse, n);
		if (size)
			*size = n * sizeof(_ns3__RobotCameraControlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotCameraControlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotCameraControlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotCameraControlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotCameraControlResponse %p -> %p\n", q, p));
	*(_ns3__RobotCameraControlResponse*)p = *(_ns3__RobotCameraControlResponse*)q;
}

void _ns3__RobotCameraControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__CameraControlType(soap, &this->_ns3__RobotCameraControl::Type);
	/* transient soap skipped */
}

void _ns3__RobotCameraControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotCameraControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotCameraControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotCameraControl(struct soap *soap, const char *tag, int id, const _ns3__RobotCameraControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotCameraControl), type))
		return soap->error;
	if (soap_out_ns3__CameraControlType(soap, "Type", -1, &(a->_ns3__RobotCameraControl::Type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotCameraControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotCameraControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotCameraControl * SOAP_FMAC4 soap_in__ns3__RobotCameraControl(struct soap *soap, const char *tag, _ns3__RobotCameraControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotCameraControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotCameraControl, sizeof(_ns3__RobotCameraControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotCameraControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotCameraControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns3__CameraControlType(soap, "Type", &(a->_ns3__RobotCameraControl::Type), "ns3:CameraControlType"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotCameraControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotCameraControl, 0, sizeof(_ns3__RobotCameraControl), 0, soap_copy__ns3__RobotCameraControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotCameraControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotCameraControl);
	if (this->soap_out(soap, tag?tag:"ns3:RobotCameraControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotCameraControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotCameraControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotCameraControl * SOAP_FMAC4 soap_get__ns3__RobotCameraControl(struct soap *soap, _ns3__RobotCameraControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotCameraControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotCameraControl * SOAP_FMAC2 soap_instantiate__ns3__RobotCameraControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotCameraControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotCameraControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotCameraControl);
		if (size)
			*size = sizeof(_ns3__RobotCameraControl);
		((_ns3__RobotCameraControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotCameraControl, n);
		if (size)
			*size = n * sizeof(_ns3__RobotCameraControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotCameraControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotCameraControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotCameraControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotCameraControl %p -> %p\n", q, p));
	*(_ns3__RobotCameraControl*)p = *(_ns3__RobotCameraControl*)q;
}

void _ns3__RobotYuntaiControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__RobotYuntaiControlResponse::Result);
	/* transient soap skipped */
}

void _ns3__RobotYuntaiControlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotYuntaiControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotYuntaiControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotYuntaiControlResponse(struct soap *soap, const char *tag, int id, const _ns3__RobotYuntaiControlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__RobotYuntaiControlResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotYuntaiControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotYuntaiControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotYuntaiControlResponse * SOAP_FMAC4 soap_in__ns3__RobotYuntaiControlResponse(struct soap *soap, const char *tag, _ns3__RobotYuntaiControlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotYuntaiControlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse, sizeof(_ns3__RobotYuntaiControlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotYuntaiControlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__RobotYuntaiControlResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotYuntaiControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse, 0, sizeof(_ns3__RobotYuntaiControlResponse), 0, soap_copy__ns3__RobotYuntaiControlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotYuntaiControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse);
	if (this->soap_out(soap, tag?tag:"ns3:RobotYuntaiControlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotYuntaiControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotYuntaiControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotYuntaiControlResponse * SOAP_FMAC4 soap_get__ns3__RobotYuntaiControlResponse(struct soap *soap, _ns3__RobotYuntaiControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotYuntaiControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotYuntaiControlResponse * SOAP_FMAC2 soap_instantiate__ns3__RobotYuntaiControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotYuntaiControlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotYuntaiControlResponse);
		if (size)
			*size = sizeof(_ns3__RobotYuntaiControlResponse);
		((_ns3__RobotYuntaiControlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotYuntaiControlResponse, n);
		if (size)
			*size = n * sizeof(_ns3__RobotYuntaiControlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotYuntaiControlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotYuntaiControlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotYuntaiControlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotYuntaiControlResponse %p -> %p\n", q, p));
	*(_ns3__RobotYuntaiControlResponse*)p = *(_ns3__RobotYuntaiControlResponse*)q;
}

void _ns3__RobotYuntaiControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__YuntaiControlType(soap, &this->_ns3__RobotYuntaiControl::Type);
	/* transient soap skipped */
}

void _ns3__RobotYuntaiControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotYuntaiControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotYuntaiControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotYuntaiControl(struct soap *soap, const char *tag, int id, const _ns3__RobotYuntaiControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotYuntaiControl), type))
		return soap->error;
	if (soap_out_ns3__YuntaiControlType(soap, "Type", -1, &(a->_ns3__RobotYuntaiControl::Type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotYuntaiControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotYuntaiControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotYuntaiControl * SOAP_FMAC4 soap_in__ns3__RobotYuntaiControl(struct soap *soap, const char *tag, _ns3__RobotYuntaiControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotYuntaiControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotYuntaiControl, sizeof(_ns3__RobotYuntaiControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotYuntaiControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotYuntaiControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns3__YuntaiControlType(soap, "Type", &(a->_ns3__RobotYuntaiControl::Type), "ns3:YuntaiControlType"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotYuntaiControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotYuntaiControl, 0, sizeof(_ns3__RobotYuntaiControl), 0, soap_copy__ns3__RobotYuntaiControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotYuntaiControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotYuntaiControl);
	if (this->soap_out(soap, tag?tag:"ns3:RobotYuntaiControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotYuntaiControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotYuntaiControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotYuntaiControl * SOAP_FMAC4 soap_get__ns3__RobotYuntaiControl(struct soap *soap, _ns3__RobotYuntaiControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotYuntaiControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotYuntaiControl * SOAP_FMAC2 soap_instantiate__ns3__RobotYuntaiControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotYuntaiControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotYuntaiControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotYuntaiControl);
		if (size)
			*size = sizeof(_ns3__RobotYuntaiControl);
		((_ns3__RobotYuntaiControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotYuntaiControl, n);
		if (size)
			*size = n * sizeof(_ns3__RobotYuntaiControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotYuntaiControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotYuntaiControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotYuntaiControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotYuntaiControl %p -> %p\n", q, p));
	*(_ns3__RobotYuntaiControl*)p = *(_ns3__RobotYuntaiControl*)q;
}

void _ns3__RobotSpeedControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__RobotSpeedControlResponse::Result);
	/* transient soap skipped */
}

void _ns3__RobotSpeedControlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotSpeedControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotSpeedControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotSpeedControlResponse(struct soap *soap, const char *tag, int id, const _ns3__RobotSpeedControlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__RobotSpeedControlResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotSpeedControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotSpeedControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotSpeedControlResponse * SOAP_FMAC4 soap_in__ns3__RobotSpeedControlResponse(struct soap *soap, const char *tag, _ns3__RobotSpeedControlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotSpeedControlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse, sizeof(_ns3__RobotSpeedControlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotSpeedControlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__RobotSpeedControlResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotSpeedControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse, 0, sizeof(_ns3__RobotSpeedControlResponse), 0, soap_copy__ns3__RobotSpeedControlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotSpeedControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse);
	if (this->soap_out(soap, tag?tag:"ns3:RobotSpeedControlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotSpeedControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotSpeedControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotSpeedControlResponse * SOAP_FMAC4 soap_get__ns3__RobotSpeedControlResponse(struct soap *soap, _ns3__RobotSpeedControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotSpeedControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotSpeedControlResponse * SOAP_FMAC2 soap_instantiate__ns3__RobotSpeedControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotSpeedControlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotSpeedControlResponse);
		if (size)
			*size = sizeof(_ns3__RobotSpeedControlResponse);
		((_ns3__RobotSpeedControlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotSpeedControlResponse, n);
		if (size)
			*size = n * sizeof(_ns3__RobotSpeedControlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotSpeedControlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotSpeedControlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotSpeedControlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotSpeedControlResponse %p -> %p\n", q, p));
	*(_ns3__RobotSpeedControlResponse*)p = *(_ns3__RobotSpeedControlResponse*)q;
}

void _ns3__RobotSpeedControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->_ns3__RobotSpeedControl::LinearVelocity);
	soap_default_double(soap, &this->_ns3__RobotSpeedControl::AngularVelocity);
	/* transient soap skipped */
}

void _ns3__RobotSpeedControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__RobotSpeedControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RobotSpeedControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RobotSpeedControl(struct soap *soap, const char *tag, int id, const _ns3__RobotSpeedControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__RobotSpeedControl), type))
		return soap->error;
	if (soap_out_double(soap, "LinearVelocity", -1, &(a->_ns3__RobotSpeedControl::LinearVelocity), ""))
		return soap->error;
	if (soap_out_double(soap, "AngularVelocity", -1, &(a->_ns3__RobotSpeedControl::AngularVelocity), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RobotSpeedControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RobotSpeedControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RobotSpeedControl * SOAP_FMAC4 soap_in__ns3__RobotSpeedControl(struct soap *soap, const char *tag, _ns3__RobotSpeedControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RobotSpeedControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__RobotSpeedControl, sizeof(_ns3__RobotSpeedControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__RobotSpeedControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RobotSpeedControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LinearVelocity1 = 1;
	size_t soap_flag_AngularVelocity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LinearVelocity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "LinearVelocity", &(a->_ns3__RobotSpeedControl::LinearVelocity), "xsd:double"))
				{	soap_flag_LinearVelocity1--;
					continue;
				}
			if (soap_flag_AngularVelocity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "AngularVelocity", &(a->_ns3__RobotSpeedControl::AngularVelocity), "xsd:double"))
				{	soap_flag_AngularVelocity1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RobotSpeedControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__RobotSpeedControl, 0, sizeof(_ns3__RobotSpeedControl), 0, soap_copy__ns3__RobotSpeedControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LinearVelocity1 > 0 || soap_flag_AngularVelocity1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__RobotSpeedControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__RobotSpeedControl);
	if (this->soap_out(soap, tag?tag:"ns3:RobotSpeedControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RobotSpeedControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RobotSpeedControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RobotSpeedControl * SOAP_FMAC4 soap_get__ns3__RobotSpeedControl(struct soap *soap, _ns3__RobotSpeedControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RobotSpeedControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__RobotSpeedControl * SOAP_FMAC2 soap_instantiate__ns3__RobotSpeedControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RobotSpeedControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__RobotSpeedControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__RobotSpeedControl);
		if (size)
			*size = sizeof(_ns3__RobotSpeedControl);
		((_ns3__RobotSpeedControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__RobotSpeedControl, n);
		if (size)
			*size = n * sizeof(_ns3__RobotSpeedControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__RobotSpeedControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__RobotSpeedControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RobotSpeedControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RobotSpeedControl %p -> %p\n", q, p));
	*(_ns3__RobotSpeedControl*)p = *(_ns3__RobotSpeedControl*)q;
}

void _ns3__GetControlModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__GetControlModeResponse::ControlType);
	/* transient soap skipped */
}

void _ns3__GetControlModeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetControlModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetControlModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetControlModeResponse(struct soap *soap, const char *tag, int id, const _ns3__GetControlModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetControlModeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "ControlType", -1, &(a->_ns3__GetControlModeResponse::ControlType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetControlModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetControlModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetControlModeResponse * SOAP_FMAC4 soap_in__ns3__GetControlModeResponse(struct soap *soap, const char *tag, _ns3__GetControlModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetControlModeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetControlModeResponse, sizeof(_ns3__GetControlModeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetControlModeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetControlModeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ControlType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ControlType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ControlType", &(a->_ns3__GetControlModeResponse::ControlType), "xsd:int"))
				{	soap_flag_ControlType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetControlModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetControlModeResponse, 0, sizeof(_ns3__GetControlModeResponse), 0, soap_copy__ns3__GetControlModeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ControlType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetControlModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetControlModeResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetControlModeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetControlModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetControlModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetControlModeResponse * SOAP_FMAC4 soap_get__ns3__GetControlModeResponse(struct soap *soap, _ns3__GetControlModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetControlModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetControlModeResponse * SOAP_FMAC2 soap_instantiate__ns3__GetControlModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetControlModeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetControlModeResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetControlModeResponse);
		if (size)
			*size = sizeof(_ns3__GetControlModeResponse);
		((_ns3__GetControlModeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetControlModeResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetControlModeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetControlModeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetControlModeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetControlModeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetControlModeResponse %p -> %p\n", q, p));
	*(_ns3__GetControlModeResponse*)p = *(_ns3__GetControlModeResponse*)q;
}

void _ns3__GetControlMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__GetControlMode::RobotIp);
	/* transient soap skipped */
}

void _ns3__GetControlMode::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns3__GetControlMode::RobotIp);
	/* transient soap skipped */
#endif
}

int _ns3__GetControlMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetControlMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetControlMode(struct soap *soap, const char *tag, int id, const _ns3__GetControlMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetControlMode), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->_ns3__GetControlMode::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetControlMode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetControlMode(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetControlMode * SOAP_FMAC4 soap_in__ns3__GetControlMode(struct soap *soap, const char *tag, _ns3__GetControlMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetControlMode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetControlMode, sizeof(_ns3__GetControlMode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetControlMode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetControlMode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->_ns3__GetControlMode::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetControlMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetControlMode, 0, sizeof(_ns3__GetControlMode), 0, soap_copy__ns3__GetControlMode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetControlMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetControlMode);
	if (this->soap_out(soap, tag?tag:"ns3:GetControlMode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetControlMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetControlMode(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetControlMode * SOAP_FMAC4 soap_get__ns3__GetControlMode(struct soap *soap, _ns3__GetControlMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetControlMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetControlMode * SOAP_FMAC2 soap_instantiate__ns3__GetControlMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetControlMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetControlMode, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetControlMode);
		if (size)
			*size = sizeof(_ns3__GetControlMode);
		((_ns3__GetControlMode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetControlMode, n);
		if (size)
			*size = n * sizeof(_ns3__GetControlMode);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetControlMode*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetControlMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetControlMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetControlMode %p -> %p\n", q, p));
	*(_ns3__GetControlMode*)p = *(_ns3__GetControlMode*)q;
}

void _ns3__SetControlModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__SetControlModeResponse::Result);
	/* transient soap skipped */
}

void _ns3__SetControlModeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__SetControlModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SetControlModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SetControlModeResponse(struct soap *soap, const char *tag, int id, const _ns3__SetControlModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__SetControlModeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__SetControlModeResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__SetControlModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SetControlModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SetControlModeResponse * SOAP_FMAC4 soap_in__ns3__SetControlModeResponse(struct soap *soap, const char *tag, _ns3__SetControlModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SetControlModeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__SetControlModeResponse, sizeof(_ns3__SetControlModeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__SetControlModeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__SetControlModeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__SetControlModeResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__SetControlModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__SetControlModeResponse, 0, sizeof(_ns3__SetControlModeResponse), 0, soap_copy__ns3__SetControlModeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__SetControlModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__SetControlModeResponse);
	if (this->soap_out(soap, tag?tag:"ns3:SetControlModeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__SetControlModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SetControlModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SetControlModeResponse * SOAP_FMAC4 soap_get__ns3__SetControlModeResponse(struct soap *soap, _ns3__SetControlModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SetControlModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__SetControlModeResponse * SOAP_FMAC2 soap_instantiate__ns3__SetControlModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SetControlModeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__SetControlModeResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__SetControlModeResponse);
		if (size)
			*size = sizeof(_ns3__SetControlModeResponse);
		((_ns3__SetControlModeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__SetControlModeResponse, n);
		if (size)
			*size = n * sizeof(_ns3__SetControlModeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__SetControlModeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__SetControlModeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__SetControlModeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__SetControlModeResponse %p -> %p\n", q, p));
	*(_ns3__SetControlModeResponse*)p = *(_ns3__SetControlModeResponse*)q;
}

void _ns3__SetControlMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__SetControlMode::RobotIp);
	soap_default_int(soap, &this->_ns3__SetControlMode::ControlType);
	/* transient soap skipped */
}

void _ns3__SetControlMode::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns3__SetControlMode::RobotIp);
	/* transient soap skipped */
#endif
}

int _ns3__SetControlMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SetControlMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SetControlMode(struct soap *soap, const char *tag, int id, const _ns3__SetControlMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__SetControlMode), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->_ns3__SetControlMode::RobotIp), ""))
		return soap->error;
	if (soap_out_int(soap, "ControlType", -1, &(a->_ns3__SetControlMode::ControlType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__SetControlMode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SetControlMode(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SetControlMode * SOAP_FMAC4 soap_in__ns3__SetControlMode(struct soap *soap, const char *tag, _ns3__SetControlMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SetControlMode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__SetControlMode, sizeof(_ns3__SetControlMode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__SetControlMode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__SetControlMode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_ControlType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->_ns3__SetControlMode::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_ControlType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ControlType", &(a->_ns3__SetControlMode::ControlType), "xsd:int"))
				{	soap_flag_ControlType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__SetControlMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__SetControlMode, 0, sizeof(_ns3__SetControlMode), 0, soap_copy__ns3__SetControlMode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_ControlType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__SetControlMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__SetControlMode);
	if (this->soap_out(soap, tag?tag:"ns3:SetControlMode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__SetControlMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SetControlMode(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SetControlMode * SOAP_FMAC4 soap_get__ns3__SetControlMode(struct soap *soap, _ns3__SetControlMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SetControlMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__SetControlMode * SOAP_FMAC2 soap_instantiate__ns3__SetControlMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SetControlMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__SetControlMode, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__SetControlMode);
		if (size)
			*size = sizeof(_ns3__SetControlMode);
		((_ns3__SetControlMode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__SetControlMode, n);
		if (size)
			*size = n * sizeof(_ns3__SetControlMode);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__SetControlMode*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__SetControlMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__SetControlMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__SetControlMode %p -> %p\n", q, p));
	*(_ns3__SetControlMode*)p = *(_ns3__SetControlMode*)q;
}

void _ns3__ReleaseCurrentRobotResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__ReleaseCurrentRobotResponse::Result);
	/* transient soap skipped */
}

void _ns3__ReleaseCurrentRobotResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__ReleaseCurrentRobotResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ReleaseCurrentRobotResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ReleaseCurrentRobotResponse(struct soap *soap, const char *tag, int id, const _ns3__ReleaseCurrentRobotResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__ReleaseCurrentRobotResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__ReleaseCurrentRobotResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__ReleaseCurrentRobotResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ReleaseCurrentRobotResponse * SOAP_FMAC4 soap_in__ns3__ReleaseCurrentRobotResponse(struct soap *soap, const char *tag, _ns3__ReleaseCurrentRobotResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ReleaseCurrentRobotResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse, sizeof(_ns3__ReleaseCurrentRobotResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__ReleaseCurrentRobotResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__ReleaseCurrentRobotResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ReleaseCurrentRobotResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse, 0, sizeof(_ns3__ReleaseCurrentRobotResponse), 0, soap_copy__ns3__ReleaseCurrentRobotResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__ReleaseCurrentRobotResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse);
	if (this->soap_out(soap, tag?tag:"ns3:ReleaseCurrentRobotResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__ReleaseCurrentRobotResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ReleaseCurrentRobotResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ReleaseCurrentRobotResponse * SOAP_FMAC4 soap_get__ns3__ReleaseCurrentRobotResponse(struct soap *soap, _ns3__ReleaseCurrentRobotResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ReleaseCurrentRobotResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__ReleaseCurrentRobotResponse * SOAP_FMAC2 soap_instantiate__ns3__ReleaseCurrentRobotResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ReleaseCurrentRobotResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__ReleaseCurrentRobotResponse);
		if (size)
			*size = sizeof(_ns3__ReleaseCurrentRobotResponse);
		((_ns3__ReleaseCurrentRobotResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__ReleaseCurrentRobotResponse, n);
		if (size)
			*size = n * sizeof(_ns3__ReleaseCurrentRobotResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__ReleaseCurrentRobotResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__ReleaseCurrentRobotResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__ReleaseCurrentRobotResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__ReleaseCurrentRobotResponse %p -> %p\n", q, p));
	*(_ns3__ReleaseCurrentRobotResponse*)p = *(_ns3__ReleaseCurrentRobotResponse*)q;
}

void _ns3__ReleaseCurrentRobot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__ReleaseCurrentRobot::RobotIp);
	/* transient soap skipped */
}

void _ns3__ReleaseCurrentRobot::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns3__ReleaseCurrentRobot::RobotIp);
	/* transient soap skipped */
#endif
}

int _ns3__ReleaseCurrentRobot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ReleaseCurrentRobot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ReleaseCurrentRobot(struct soap *soap, const char *tag, int id, const _ns3__ReleaseCurrentRobot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->_ns3__ReleaseCurrentRobot::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__ReleaseCurrentRobot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__ReleaseCurrentRobot(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ReleaseCurrentRobot * SOAP_FMAC4 soap_in__ns3__ReleaseCurrentRobot(struct soap *soap, const char *tag, _ns3__ReleaseCurrentRobot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ReleaseCurrentRobot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot, sizeof(_ns3__ReleaseCurrentRobot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__ReleaseCurrentRobot *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->_ns3__ReleaseCurrentRobot::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ReleaseCurrentRobot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot, 0, sizeof(_ns3__ReleaseCurrentRobot), 0, soap_copy__ns3__ReleaseCurrentRobot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__ReleaseCurrentRobot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot);
	if (this->soap_out(soap, tag?tag:"ns3:ReleaseCurrentRobot", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__ReleaseCurrentRobot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ReleaseCurrentRobot(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ReleaseCurrentRobot * SOAP_FMAC4 soap_get__ns3__ReleaseCurrentRobot(struct soap *soap, _ns3__ReleaseCurrentRobot *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ReleaseCurrentRobot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__ReleaseCurrentRobot * SOAP_FMAC2 soap_instantiate__ns3__ReleaseCurrentRobot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ReleaseCurrentRobot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__ReleaseCurrentRobot);
		if (size)
			*size = sizeof(_ns3__ReleaseCurrentRobot);
		((_ns3__ReleaseCurrentRobot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__ReleaseCurrentRobot, n);
		if (size)
			*size = n * sizeof(_ns3__ReleaseCurrentRobot);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__ReleaseCurrentRobot*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__ReleaseCurrentRobot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__ReleaseCurrentRobot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__ReleaseCurrentRobot %p -> %p\n", q, p));
	*(_ns3__ReleaseCurrentRobot*)p = *(_ns3__ReleaseCurrentRobot*)q;
}

void _ns3__SetCurrentRobotResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__SetCurrentRobotResponse::Result);
	/* transient soap skipped */
}

void _ns3__SetCurrentRobotResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__SetCurrentRobotResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SetCurrentRobotResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SetCurrentRobotResponse(struct soap *soap, const char *tag, int id, const _ns3__SetCurrentRobotResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__SetCurrentRobotResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__SetCurrentRobotResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SetCurrentRobotResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SetCurrentRobotResponse * SOAP_FMAC4 soap_in__ns3__SetCurrentRobotResponse(struct soap *soap, const char *tag, _ns3__SetCurrentRobotResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SetCurrentRobotResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse, sizeof(_ns3__SetCurrentRobotResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__SetCurrentRobotResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__SetCurrentRobotResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__SetCurrentRobotResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse, 0, sizeof(_ns3__SetCurrentRobotResponse), 0, soap_copy__ns3__SetCurrentRobotResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__SetCurrentRobotResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse);
	if (this->soap_out(soap, tag?tag:"ns3:SetCurrentRobotResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__SetCurrentRobotResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SetCurrentRobotResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SetCurrentRobotResponse * SOAP_FMAC4 soap_get__ns3__SetCurrentRobotResponse(struct soap *soap, _ns3__SetCurrentRobotResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SetCurrentRobotResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__SetCurrentRobotResponse * SOAP_FMAC2 soap_instantiate__ns3__SetCurrentRobotResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SetCurrentRobotResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__SetCurrentRobotResponse);
		if (size)
			*size = sizeof(_ns3__SetCurrentRobotResponse);
		((_ns3__SetCurrentRobotResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__SetCurrentRobotResponse, n);
		if (size)
			*size = n * sizeof(_ns3__SetCurrentRobotResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__SetCurrentRobotResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__SetCurrentRobotResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__SetCurrentRobotResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__SetCurrentRobotResponse %p -> %p\n", q, p));
	*(_ns3__SetCurrentRobotResponse*)p = *(_ns3__SetCurrentRobotResponse*)q;
}

void _ns3__SetCurrentRobot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__SetCurrentRobot::RobotIp);
	/* transient soap skipped */
}

void _ns3__SetCurrentRobot::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns3__SetCurrentRobot::RobotIp);
	/* transient soap skipped */
#endif
}

int _ns3__SetCurrentRobot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SetCurrentRobot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SetCurrentRobot(struct soap *soap, const char *tag, int id, const _ns3__SetCurrentRobot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__SetCurrentRobot), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->_ns3__SetCurrentRobot::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__SetCurrentRobot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SetCurrentRobot(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SetCurrentRobot * SOAP_FMAC4 soap_in__ns3__SetCurrentRobot(struct soap *soap, const char *tag, _ns3__SetCurrentRobot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SetCurrentRobot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__SetCurrentRobot, sizeof(_ns3__SetCurrentRobot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__SetCurrentRobot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__SetCurrentRobot *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->_ns3__SetCurrentRobot::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__SetCurrentRobot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__SetCurrentRobot, 0, sizeof(_ns3__SetCurrentRobot), 0, soap_copy__ns3__SetCurrentRobot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__SetCurrentRobot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__SetCurrentRobot);
	if (this->soap_out(soap, tag?tag:"ns3:SetCurrentRobot", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__SetCurrentRobot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SetCurrentRobot(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SetCurrentRobot * SOAP_FMAC4 soap_get__ns3__SetCurrentRobot(struct soap *soap, _ns3__SetCurrentRobot *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SetCurrentRobot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__SetCurrentRobot * SOAP_FMAC2 soap_instantiate__ns3__SetCurrentRobot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SetCurrentRobot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__SetCurrentRobot, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__SetCurrentRobot);
		if (size)
			*size = sizeof(_ns3__SetCurrentRobot);
		((_ns3__SetCurrentRobot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__SetCurrentRobot, n);
		if (size)
			*size = n * sizeof(_ns3__SetCurrentRobot);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__SetCurrentRobot*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__SetCurrentRobot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__SetCurrentRobot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__SetCurrentRobot %p -> %p\n", q, p));
	*(_ns3__SetCurrentRobot*)p = *(_ns3__SetCurrentRobot*)q;
}

void _ns3__SetRobotTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns3__SetRobotTimeResponse::Result);
	/* transient soap skipped */
}

void _ns3__SetRobotTimeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__SetRobotTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SetRobotTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SetRobotTimeResponse(struct soap *soap, const char *tag, int id, const _ns3__SetRobotTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns3__SetRobotTimeResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__SetRobotTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SetRobotTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SetRobotTimeResponse * SOAP_FMAC4 soap_in__ns3__SetRobotTimeResponse(struct soap *soap, const char *tag, _ns3__SetRobotTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SetRobotTimeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse, sizeof(_ns3__SetRobotTimeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__SetRobotTimeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns3__SetRobotTimeResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__SetRobotTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse, 0, sizeof(_ns3__SetRobotTimeResponse), 0, soap_copy__ns3__SetRobotTimeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__SetRobotTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse);
	if (this->soap_out(soap, tag?tag:"ns3:SetRobotTimeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__SetRobotTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SetRobotTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SetRobotTimeResponse * SOAP_FMAC4 soap_get__ns3__SetRobotTimeResponse(struct soap *soap, _ns3__SetRobotTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SetRobotTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__SetRobotTimeResponse * SOAP_FMAC2 soap_instantiate__ns3__SetRobotTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SetRobotTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__SetRobotTimeResponse);
		if (size)
			*size = sizeof(_ns3__SetRobotTimeResponse);
		((_ns3__SetRobotTimeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__SetRobotTimeResponse, n);
		if (size)
			*size = n * sizeof(_ns3__SetRobotTimeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__SetRobotTimeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__SetRobotTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__SetRobotTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__SetRobotTimeResponse %p -> %p\n", q, p));
	*(_ns3__SetRobotTimeResponse*)p = *(_ns3__SetRobotTimeResponse*)q;
}

void _ns3__SetRobotTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__SetRobotTime::RobotTime);
	/* transient soap skipped */
}

void _ns3__SetRobotTime::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns3__SetRobotTime::RobotTime);
	/* transient soap skipped */
#endif
}

int _ns3__SetRobotTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SetRobotTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SetRobotTime(struct soap *soap, const char *tag, int id, const _ns3__SetRobotTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__SetRobotTime), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotTime", -1, &(a->_ns3__SetRobotTime::RobotTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__SetRobotTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SetRobotTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SetRobotTime * SOAP_FMAC4 soap_in__ns3__SetRobotTime(struct soap *soap, const char *tag, _ns3__SetRobotTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SetRobotTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__SetRobotTime, sizeof(_ns3__SetRobotTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__SetRobotTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__SetRobotTime *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotTime", &(a->_ns3__SetRobotTime::RobotTime), "xsd:string"))
				{	soap_flag_RobotTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__SetRobotTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__SetRobotTime, 0, sizeof(_ns3__SetRobotTime), 0, soap_copy__ns3__SetRobotTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__SetRobotTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__SetRobotTime);
	if (this->soap_out(soap, tag?tag:"ns3:SetRobotTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__SetRobotTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SetRobotTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SetRobotTime * SOAP_FMAC4 soap_get__ns3__SetRobotTime(struct soap *soap, _ns3__SetRobotTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SetRobotTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__SetRobotTime * SOAP_FMAC2 soap_instantiate__ns3__SetRobotTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SetRobotTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__SetRobotTime, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__SetRobotTime);
		if (size)
			*size = sizeof(_ns3__SetRobotTime);
		((_ns3__SetRobotTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__SetRobotTime, n);
		if (size)
			*size = n * sizeof(_ns3__SetRobotTime);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__SetRobotTime*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__SetRobotTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__SetRobotTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__SetRobotTime %p -> %p\n", q, p));
	*(_ns3__SetRobotTime*)p = *(_ns3__SetRobotTime*)q;
}

void _ns3__GetRobotTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns3__GetRobotTimeResponse::RobotTime);
	/* transient soap skipped */
}

void _ns3__GetRobotTimeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns3__GetRobotTimeResponse::RobotTime);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotTimeResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotTime", -1, &(a->_ns3__GetRobotTimeResponse::RobotTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotTimeResponse * SOAP_FMAC4 soap_in__ns3__GetRobotTimeResponse(struct soap *soap, const char *tag, _ns3__GetRobotTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotTimeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse, sizeof(_ns3__GetRobotTimeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotTimeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotTime", &(a->_ns3__GetRobotTimeResponse::RobotTime), "xsd:string"))
				{	soap_flag_RobotTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse, 0, sizeof(_ns3__GetRobotTimeResponse), 0, soap_copy__ns3__GetRobotTimeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotTimeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotTimeResponse * SOAP_FMAC4 soap_get__ns3__GetRobotTimeResponse(struct soap *soap, _ns3__GetRobotTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotTimeResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotTimeResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotTimeResponse);
		((_ns3__GetRobotTimeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotTimeResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotTimeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotTimeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotTimeResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotTimeResponse*)p = *(_ns3__GetRobotTimeResponse*)q;
}

void _ns3__GetRobotTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__GetRobotTime::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotTime(struct soap *soap, const char *tag, int id, const _ns3__GetRobotTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotTime), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotTime * SOAP_FMAC4 soap_in__ns3__GetRobotTime(struct soap *soap, const char *tag, _ns3__GetRobotTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotTime, sizeof(_ns3__GetRobotTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotTime *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotTime, 0, sizeof(_ns3__GetRobotTime), 0, soap_copy__ns3__GetRobotTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__GetRobotTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotTime);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotTime * SOAP_FMAC4 soap_get__ns3__GetRobotTime(struct soap *soap, _ns3__GetRobotTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotTime * SOAP_FMAC2 soap_instantiate__ns3__GetRobotTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotTime, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotTime);
		if (size)
			*size = sizeof(_ns3__GetRobotTime);
		((_ns3__GetRobotTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotTime, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotTime);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotTime*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotTime %p -> %p\n", q, p));
	*(_ns3__GetRobotTime*)p = *(_ns3__GetRobotTime*)q;
}

void _ns3__GetRobotInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__RobotInfos(soap, &this->_ns3__GetRobotInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotInfoResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotInfoResponse::Data)
	{	if (soap_out_PointerTons3__RobotInfos(soap, "Data", -1, &a->_ns3__GetRobotInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotInfoResponse * SOAP_FMAC4 soap_in__ns3__GetRobotInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse, sizeof(_ns3__GetRobotInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__RobotInfos(soap, "Data", &(a->_ns3__GetRobotInfoResponse::Data), "ns3:RobotInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse, 0, sizeof(_ns3__GetRobotInfoResponse), 0, soap_copy__ns3__GetRobotInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotInfoResponse * SOAP_FMAC4 soap_get__ns3__GetRobotInfoResponse(struct soap *soap, _ns3__GetRobotInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotInfoResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotInfoResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotInfoResponse);
		((_ns3__GetRobotInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotInfoResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotInfoResponse*)p = *(_ns3__GetRobotInfoResponse*)q;
}

void _ns3__GetRobotInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__GetRobotInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotInfo(struct soap *soap, const char *tag, int id, const _ns3__GetRobotInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotInfo * SOAP_FMAC4 soap_in__ns3__GetRobotInfo(struct soap *soap, const char *tag, _ns3__GetRobotInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotInfo, sizeof(_ns3__GetRobotInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotInfo, 0, sizeof(_ns3__GetRobotInfo), 0, soap_copy__ns3__GetRobotInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__GetRobotInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotInfo);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotInfo * SOAP_FMAC4 soap_get__ns3__GetRobotInfo(struct soap *soap, _ns3__GetRobotInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotInfo * SOAP_FMAC2 soap_instantiate__ns3__GetRobotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotInfo);
		if (size)
			*size = sizeof(_ns3__GetRobotInfo);
		((_ns3__GetRobotInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotInfo, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotInfo %p -> %p\n", q, p));
	*(_ns3__GetRobotInfo*)p = *(_ns3__GetRobotInfo*)q;
}

void _ns3__GetRobotConnectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRobotConnectResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns3__GetRobotConnectResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ConnectInfos(soap, &this->_ns3__GetRobotConnectResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotConnectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotConnectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotConnectResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRobotConnectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse), type))
		return soap->error;
	if (a->_ns3__GetRobotConnectResponse::Data)
	{	if (soap_out_PointerTons3__ConnectInfos(soap, "Data", -1, &a->_ns3__GetRobotConnectResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotConnectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotConnectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotConnectResponse * SOAP_FMAC4 soap_in__ns3__GetRobotConnectResponse(struct soap *soap, const char *tag, _ns3__GetRobotConnectResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotConnectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse, sizeof(_ns3__GetRobotConnectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotConnectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ConnectInfos(soap, "Data", &(a->_ns3__GetRobotConnectResponse::Data), "ns3:ConnectInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotConnectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse, 0, sizeof(_ns3__GetRobotConnectResponse), 0, soap_copy__ns3__GetRobotConnectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__GetRobotConnectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotConnectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotConnectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotConnectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotConnectResponse * SOAP_FMAC4 soap_get__ns3__GetRobotConnectResponse(struct soap *soap, _ns3__GetRobotConnectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotConnectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotConnectResponse * SOAP_FMAC2 soap_instantiate__ns3__GetRobotConnectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotConnectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotConnectResponse);
		if (size)
			*size = sizeof(_ns3__GetRobotConnectResponse);
		((_ns3__GetRobotConnectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotConnectResponse, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotConnectResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotConnectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotConnectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotConnectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotConnectResponse %p -> %p\n", q, p));
	*(_ns3__GetRobotConnectResponse*)p = *(_ns3__GetRobotConnectResponse*)q;
}

void _ns3__GetRobotConnect::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__GetRobotConnect::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns3__GetRobotConnect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRobotConnect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRobotConnect(struct soap *soap, const char *tag, int id, const _ns3__GetRobotConnect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData__ns3__GetRobotConnect), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRobotConnect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRobotConnect(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRobotConnect * SOAP_FMAC4 soap_in__ns3__GetRobotConnect(struct soap *soap, const char *tag, _ns3__GetRobotConnect *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRobotConnect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData__ns3__GetRobotConnect, sizeof(_ns3__GetRobotConnect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData__ns3__GetRobotConnect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRobotConnect *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRobotConnect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData__ns3__GetRobotConnect, 0, sizeof(_ns3__GetRobotConnect), 0, soap_copy__ns3__GetRobotConnect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns3__GetRobotConnect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData__ns3__GetRobotConnect);
	if (this->soap_out(soap, tag?tag:"ns3:GetRobotConnect", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetRobotConnect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRobotConnect(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRobotConnect * SOAP_FMAC4 soap_get__ns3__GetRobotConnect(struct soap *soap, _ns3__GetRobotConnect *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRobotConnect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__GetRobotConnect * SOAP_FMAC2 soap_instantiate__ns3__GetRobotConnect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRobotConnect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData__ns3__GetRobotConnect, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__GetRobotConnect);
		if (size)
			*size = sizeof(_ns3__GetRobotConnect);
		((_ns3__GetRobotConnect*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns3__GetRobotConnect, n);
		if (size)
			*size = n * sizeof(_ns3__GetRobotConnect);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns3__GetRobotConnect*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns3__GetRobotConnect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRobotConnect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRobotConnect %p -> %p\n", q, p));
	*(_ns3__GetRobotConnect*)p = *(_ns3__GetRobotConnect*)q;
}

void ns3__TaskExcuteInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(soap, &this->ns3__TaskExcuteInfos::Infos);
	/* transient soap skipped */
}

void ns3__TaskExcuteInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(soap, &this->ns3__TaskExcuteInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__TaskExcuteInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskExcuteInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskExcuteInfos(struct soap *soap, const char *tag, int id, const ns3__TaskExcuteInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__TaskExcuteInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(soap, "Infos", -1, &(a->ns3__TaskExcuteInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskExcuteInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskExcuteInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskExcuteInfos * SOAP_FMAC4 soap_in_ns3__TaskExcuteInfos(struct soap *soap, const char *tag, ns3__TaskExcuteInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskExcuteInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__TaskExcuteInfos, sizeof(ns3__TaskExcuteInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__TaskExcuteInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskExcuteInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(soap, "Infos", &(a->ns3__TaskExcuteInfos::Infos), "ns3:TaskExcuteInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskExcuteInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__TaskExcuteInfos, 0, sizeof(ns3__TaskExcuteInfos), 0, soap_copy_ns3__TaskExcuteInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__TaskExcuteInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__TaskExcuteInfos);
	if (this->soap_out(soap, tag?tag:"ns3:TaskExcuteInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TaskExcuteInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskExcuteInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskExcuteInfos * SOAP_FMAC4 soap_get_ns3__TaskExcuteInfos(struct soap *soap, ns3__TaskExcuteInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskExcuteInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__TaskExcuteInfos * SOAP_FMAC2 soap_instantiate_ns3__TaskExcuteInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskExcuteInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__TaskExcuteInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__TaskExcuteInfos);
		if (size)
			*size = sizeof(ns3__TaskExcuteInfos);
		((ns3__TaskExcuteInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__TaskExcuteInfos, n);
		if (size)
			*size = n * sizeof(ns3__TaskExcuteInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__TaskExcuteInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__TaskExcuteInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskExcuteInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskExcuteInfos %p -> %p\n", q, p));
	*(ns3__TaskExcuteInfos*)p = *(ns3__TaskExcuteInfos*)q;
}

void ns3__TaskExcuteInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::TaskId);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::TaskName);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::TaskType);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::TaskPathId);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::TargetId);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::PointId);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::PointName);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::PointType);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteTime);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteValue);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteUnit);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteState);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteDesc);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::HDPicture);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::InfraredPicture);
	soap_default_std__string(soap, &this->ns3__TaskExcuteInfo::OtherFile);
	/* transient soap skipped */
}

void ns3__TaskExcuteInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::TaskId);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::TaskName);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::TaskType);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::TaskPathId);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::TargetId);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::PointId);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::PointName);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::PointType);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteTime);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteValue);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteUnit);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteState);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::ExcuteDesc);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::HDPicture);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::InfraredPicture);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteInfo::OtherFile);
	/* transient soap skipped */
#endif
}

int ns3__TaskExcuteInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskExcuteInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskExcuteInfo(struct soap *soap, const char *tag, int id, const ns3__TaskExcuteInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__TaskExcuteInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns3__TaskExcuteInfo::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns3__TaskExcuteInfo::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns3__TaskExcuteInfo::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns3__TaskExcuteInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TargetId", -1, &(a->ns3__TaskExcuteInfo::TargetId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointId", -1, &(a->ns3__TaskExcuteInfo::PointId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointName", -1, &(a->ns3__TaskExcuteInfo::PointName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointType", -1, &(a->ns3__TaskExcuteInfo::PointType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteTime", -1, &(a->ns3__TaskExcuteInfo::ExcuteTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteValue", -1, &(a->ns3__TaskExcuteInfo::ExcuteValue), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteUnit", -1, &(a->ns3__TaskExcuteInfo::ExcuteUnit), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteState", -1, &(a->ns3__TaskExcuteInfo::ExcuteState), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteDesc", -1, &(a->ns3__TaskExcuteInfo::ExcuteDesc), ""))
		return soap->error;
	if (soap_out_std__string(soap, "HDPicture", -1, &(a->ns3__TaskExcuteInfo::HDPicture), ""))
		return soap->error;
	if (soap_out_std__string(soap, "InfraredPicture", -1, &(a->ns3__TaskExcuteInfo::InfraredPicture), ""))
		return soap->error;
	if (soap_out_std__string(soap, "OtherFile", -1, &(a->ns3__TaskExcuteInfo::OtherFile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskExcuteInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskExcuteInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskExcuteInfo * SOAP_FMAC4 soap_in_ns3__TaskExcuteInfo(struct soap *soap, const char *tag, ns3__TaskExcuteInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskExcuteInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__TaskExcuteInfo, sizeof(ns3__TaskExcuteInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__TaskExcuteInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskExcuteInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_TargetId1 = 1;
	size_t soap_flag_PointId1 = 1;
	size_t soap_flag_PointName1 = 1;
	size_t soap_flag_PointType1 = 1;
	size_t soap_flag_ExcuteTime1 = 1;
	size_t soap_flag_ExcuteValue1 = 1;
	size_t soap_flag_ExcuteUnit1 = 1;
	size_t soap_flag_ExcuteState1 = 1;
	size_t soap_flag_ExcuteDesc1 = 1;
	size_t soap_flag_HDPicture1 = 1;
	size_t soap_flag_InfraredPicture1 = 1;
	size_t soap_flag_OtherFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns3__TaskExcuteInfo::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns3__TaskExcuteInfo::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns3__TaskExcuteInfo::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns3__TaskExcuteInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap_flag_TargetId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TargetId", &(a->ns3__TaskExcuteInfo::TargetId), "xsd:string"))
				{	soap_flag_TargetId1--;
					continue;
				}
			if (soap_flag_PointId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointId", &(a->ns3__TaskExcuteInfo::PointId), "xsd:string"))
				{	soap_flag_PointId1--;
					continue;
				}
			if (soap_flag_PointName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointName", &(a->ns3__TaskExcuteInfo::PointName), "xsd:string"))
				{	soap_flag_PointName1--;
					continue;
				}
			if (soap_flag_PointType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointType", &(a->ns3__TaskExcuteInfo::PointType), "xsd:string"))
				{	soap_flag_PointType1--;
					continue;
				}
			if (soap_flag_ExcuteTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteTime", &(a->ns3__TaskExcuteInfo::ExcuteTime), "xsd:string"))
				{	soap_flag_ExcuteTime1--;
					continue;
				}
			if (soap_flag_ExcuteValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteValue", &(a->ns3__TaskExcuteInfo::ExcuteValue), "xsd:string"))
				{	soap_flag_ExcuteValue1--;
					continue;
				}
			if (soap_flag_ExcuteUnit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteUnit", &(a->ns3__TaskExcuteInfo::ExcuteUnit), "xsd:string"))
				{	soap_flag_ExcuteUnit1--;
					continue;
				}
			if (soap_flag_ExcuteState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteState", &(a->ns3__TaskExcuteInfo::ExcuteState), "xsd:string"))
				{	soap_flag_ExcuteState1--;
					continue;
				}
			if (soap_flag_ExcuteDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteDesc", &(a->ns3__TaskExcuteInfo::ExcuteDesc), "xsd:string"))
				{	soap_flag_ExcuteDesc1--;
					continue;
				}
			if (soap_flag_HDPicture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HDPicture", &(a->ns3__TaskExcuteInfo::HDPicture), "xsd:string"))
				{	soap_flag_HDPicture1--;
					continue;
				}
			if (soap_flag_InfraredPicture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "InfraredPicture", &(a->ns3__TaskExcuteInfo::InfraredPicture), "xsd:string"))
				{	soap_flag_InfraredPicture1--;
					continue;
				}
			if (soap_flag_OtherFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "OtherFile", &(a->ns3__TaskExcuteInfo::OtherFile), "xsd:string"))
				{	soap_flag_OtherFile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskExcuteInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__TaskExcuteInfo, 0, sizeof(ns3__TaskExcuteInfo), 0, soap_copy_ns3__TaskExcuteInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskPathId1 > 0 || soap_flag_TargetId1 > 0 || soap_flag_PointId1 > 0 || soap_flag_PointName1 > 0 || soap_flag_PointType1 > 0 || soap_flag_ExcuteTime1 > 0 || soap_flag_ExcuteValue1 > 0 || soap_flag_ExcuteUnit1 > 0 || soap_flag_ExcuteState1 > 0 || soap_flag_ExcuteDesc1 > 0 || soap_flag_HDPicture1 > 0 || soap_flag_InfraredPicture1 > 0 || soap_flag_OtherFile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__TaskExcuteInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__TaskExcuteInfo);
	if (this->soap_out(soap, tag?tag:"ns3:TaskExcuteInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TaskExcuteInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskExcuteInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskExcuteInfo * SOAP_FMAC4 soap_get_ns3__TaskExcuteInfo(struct soap *soap, ns3__TaskExcuteInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskExcuteInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__TaskExcuteInfo * SOAP_FMAC2 soap_instantiate_ns3__TaskExcuteInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskExcuteInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__TaskExcuteInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__TaskExcuteInfo);
		if (size)
			*size = sizeof(ns3__TaskExcuteInfo);
		((ns3__TaskExcuteInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__TaskExcuteInfo, n);
		if (size)
			*size = n * sizeof(ns3__TaskExcuteInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__TaskExcuteInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__TaskExcuteInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskExcuteInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskExcuteInfo %p -> %p\n", q, p));
	*(ns3__TaskExcuteInfo*)p = *(ns3__TaskExcuteInfo*)q;
}

void ns3__TaskFinishInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__TaskFinishInfo(soap, &this->ns3__TaskFinishInfos::Infos);
	/* transient soap skipped */
}

void ns3__TaskFinishInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__TaskFinishInfo(soap, &this->ns3__TaskFinishInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__TaskFinishInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskFinishInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskFinishInfos(struct soap *soap, const char *tag, int id, const ns3__TaskFinishInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__TaskFinishInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__TaskFinishInfo(soap, "Infos", -1, &(a->ns3__TaskFinishInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskFinishInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskFinishInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskFinishInfos * SOAP_FMAC4 soap_in_ns3__TaskFinishInfos(struct soap *soap, const char *tag, ns3__TaskFinishInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskFinishInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__TaskFinishInfos, sizeof(ns3__TaskFinishInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__TaskFinishInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskFinishInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__TaskFinishInfo(soap, "Infos", &(a->ns3__TaskFinishInfos::Infos), "ns3:TaskFinishInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskFinishInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__TaskFinishInfos, 0, sizeof(ns3__TaskFinishInfos), 0, soap_copy_ns3__TaskFinishInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__TaskFinishInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__TaskFinishInfos);
	if (this->soap_out(soap, tag?tag:"ns3:TaskFinishInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TaskFinishInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskFinishInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskFinishInfos * SOAP_FMAC4 soap_get_ns3__TaskFinishInfos(struct soap *soap, ns3__TaskFinishInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskFinishInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__TaskFinishInfos * SOAP_FMAC2 soap_instantiate_ns3__TaskFinishInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskFinishInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__TaskFinishInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__TaskFinishInfos);
		if (size)
			*size = sizeof(ns3__TaskFinishInfos);
		((ns3__TaskFinishInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__TaskFinishInfos, n);
		if (size)
			*size = n * sizeof(ns3__TaskFinishInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__TaskFinishInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__TaskFinishInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskFinishInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskFinishInfos %p -> %p\n", q, p));
	*(ns3__TaskFinishInfos*)p = *(ns3__TaskFinishInfos*)q;
}

void ns3__TaskFinishInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__TaskFinishInfo::TaskId);
	soap_default_std__string(soap, &this->ns3__TaskFinishInfo::TaskName);
	soap_default_std__string(soap, &this->ns3__TaskFinishInfo::TaskType);
	soap_default_std__string(soap, &this->ns3__TaskFinishInfo::TaskPathId);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns3__TaskFinishInfo::PointList);
	soap_default_std__string(soap, &this->ns3__TaskFinishInfo::StartTime);
	soap_default_std__string(soap, &this->ns3__TaskFinishInfo::EndTime);
	soap_default_std__string(soap, &this->ns3__TaskFinishInfo::FinishState);
	soap_default_std__string(soap, &this->ns3__TaskFinishInfo::ExcuteRobot);
	/* transient soap skipped */
}

void ns3__TaskFinishInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__TaskFinishInfo::TaskId);
	soap_serialize_std__string(soap, &this->ns3__TaskFinishInfo::TaskName);
	soap_serialize_std__string(soap, &this->ns3__TaskFinishInfo::TaskType);
	soap_serialize_std__string(soap, &this->ns3__TaskFinishInfo::TaskPathId);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns3__TaskFinishInfo::PointList);
	soap_serialize_std__string(soap, &this->ns3__TaskFinishInfo::StartTime);
	soap_serialize_std__string(soap, &this->ns3__TaskFinishInfo::EndTime);
	soap_serialize_std__string(soap, &this->ns3__TaskFinishInfo::FinishState);
	soap_serialize_std__string(soap, &this->ns3__TaskFinishInfo::ExcuteRobot);
	/* transient soap skipped */
#endif
}

int ns3__TaskFinishInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskFinishInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskFinishInfo(struct soap *soap, const char *tag, int id, const ns3__TaskFinishInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__TaskFinishInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns3__TaskFinishInfo::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns3__TaskFinishInfo::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns3__TaskFinishInfo::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns3__TaskFinishInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns3__TaskFinishInfo::PointList), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartTime", -1, &(a->ns3__TaskFinishInfo::StartTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndTime", -1, &(a->ns3__TaskFinishInfo::EndTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FinishState", -1, &(a->ns3__TaskFinishInfo::FinishState), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteRobot", -1, &(a->ns3__TaskFinishInfo::ExcuteRobot), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskFinishInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskFinishInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskFinishInfo * SOAP_FMAC4 soap_in_ns3__TaskFinishInfo(struct soap *soap, const char *tag, ns3__TaskFinishInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskFinishInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__TaskFinishInfo, sizeof(ns3__TaskFinishInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__TaskFinishInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskFinishInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_StartTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	size_t soap_flag_FinishState1 = 1;
	size_t soap_flag_ExcuteRobot1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns3__TaskFinishInfo::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns3__TaskFinishInfo::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns3__TaskFinishInfo::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns3__TaskFinishInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns3__TaskFinishInfo::PointList), "xsd:string"))
					continue;
			if (soap_flag_StartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartTime", &(a->ns3__TaskFinishInfo::StartTime), "xsd:string"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag_EndTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndTime", &(a->ns3__TaskFinishInfo::EndTime), "xsd:string"))
				{	soap_flag_EndTime1--;
					continue;
				}
			if (soap_flag_FinishState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FinishState", &(a->ns3__TaskFinishInfo::FinishState), "xsd:string"))
				{	soap_flag_FinishState1--;
					continue;
				}
			if (soap_flag_ExcuteRobot1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteRobot", &(a->ns3__TaskFinishInfo::ExcuteRobot), "xsd:string"))
				{	soap_flag_ExcuteRobot1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskFinishInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__TaskFinishInfo, 0, sizeof(ns3__TaskFinishInfo), 0, soap_copy_ns3__TaskFinishInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskPathId1 > 0 || soap_flag_StartTime1 > 0 || soap_flag_EndTime1 > 0 || soap_flag_FinishState1 > 0 || soap_flag_ExcuteRobot1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__TaskFinishInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__TaskFinishInfo);
	if (this->soap_out(soap, tag?tag:"ns3:TaskFinishInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TaskFinishInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskFinishInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskFinishInfo * SOAP_FMAC4 soap_get_ns3__TaskFinishInfo(struct soap *soap, ns3__TaskFinishInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskFinishInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__TaskFinishInfo * SOAP_FMAC2 soap_instantiate_ns3__TaskFinishInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskFinishInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__TaskFinishInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__TaskFinishInfo);
		if (size)
			*size = sizeof(ns3__TaskFinishInfo);
		((ns3__TaskFinishInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__TaskFinishInfo, n);
		if (size)
			*size = n * sizeof(ns3__TaskFinishInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__TaskFinishInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__TaskFinishInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskFinishInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskFinishInfo %p -> %p\n", q, p));
	*(ns3__TaskFinishInfo*)p = *(ns3__TaskFinishInfo*)q;
}

void ns3__TaskExcuteData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__TaskExcuteData::RobotIp);
	soap_default_std__string(soap, &this->ns3__TaskExcuteData::TaskType);
	soap_default_std__string(soap, &this->ns3__TaskExcuteData::TaskId);
	soap_default_std__string(soap, &this->ns3__TaskExcuteData::TaskName);
	soap_default_std__string(soap, &this->ns3__TaskExcuteData::PatrolDeviceName);
	soap_default_std__string(soap, &this->ns3__TaskExcuteData::PatrolDeviceId);
	soap_default_int(soap, &this->ns3__TaskExcuteData::TotalDeviceSize);
	soap_default_int(soap, &this->ns3__TaskExcuteData::ErrorDeviceSize);
	soap_default_int(soap, &this->ns3__TaskExcuteData::FinishDeviceSize);
	soap_default_int(soap, &this->ns3__TaskExcuteData::TaskFinishPercentage);
	/* transient soap skipped */
}

void ns3__TaskExcuteData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteData::RobotIp);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteData::TaskType);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteData::TaskId);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteData::TaskName);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteData::PatrolDeviceName);
	soap_serialize_std__string(soap, &this->ns3__TaskExcuteData::PatrolDeviceId);
	/* transient soap skipped */
#endif
}

int ns3__TaskExcuteData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskExcuteData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskExcuteData(struct soap *soap, const char *tag, int id, const ns3__TaskExcuteData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__TaskExcuteData), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__TaskExcuteData::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns3__TaskExcuteData::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns3__TaskExcuteData::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns3__TaskExcuteData::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PatrolDeviceName", -1, &(a->ns3__TaskExcuteData::PatrolDeviceName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PatrolDeviceId", -1, &(a->ns3__TaskExcuteData::PatrolDeviceId), ""))
		return soap->error;
	if (soap_out_int(soap, "TotalDeviceSize", -1, &(a->ns3__TaskExcuteData::TotalDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "ErrorDeviceSize", -1, &(a->ns3__TaskExcuteData::ErrorDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "FinishDeviceSize", -1, &(a->ns3__TaskExcuteData::FinishDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "TaskFinishPercentage", -1, &(a->ns3__TaskExcuteData::TaskFinishPercentage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskExcuteData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskExcuteData(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskExcuteData * SOAP_FMAC4 soap_in_ns3__TaskExcuteData(struct soap *soap, const char *tag, ns3__TaskExcuteData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskExcuteData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__TaskExcuteData, sizeof(ns3__TaskExcuteData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__TaskExcuteData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskExcuteData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_PatrolDeviceName1 = 1;
	size_t soap_flag_PatrolDeviceId1 = 1;
	size_t soap_flag_TotalDeviceSize1 = 1;
	size_t soap_flag_ErrorDeviceSize1 = 1;
	size_t soap_flag_FinishDeviceSize1 = 1;
	size_t soap_flag_TaskFinishPercentage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__TaskExcuteData::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns3__TaskExcuteData::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns3__TaskExcuteData::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns3__TaskExcuteData::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_PatrolDeviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PatrolDeviceName", &(a->ns3__TaskExcuteData::PatrolDeviceName), "xsd:string"))
				{	soap_flag_PatrolDeviceName1--;
					continue;
				}
			if (soap_flag_PatrolDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PatrolDeviceId", &(a->ns3__TaskExcuteData::PatrolDeviceId), "xsd:string"))
				{	soap_flag_PatrolDeviceId1--;
					continue;
				}
			if (soap_flag_TotalDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TotalDeviceSize", &(a->ns3__TaskExcuteData::TotalDeviceSize), "xsd:int"))
				{	soap_flag_TotalDeviceSize1--;
					continue;
				}
			if (soap_flag_ErrorDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ErrorDeviceSize", &(a->ns3__TaskExcuteData::ErrorDeviceSize), "xsd:int"))
				{	soap_flag_ErrorDeviceSize1--;
					continue;
				}
			if (soap_flag_FinishDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FinishDeviceSize", &(a->ns3__TaskExcuteData::FinishDeviceSize), "xsd:int"))
				{	soap_flag_FinishDeviceSize1--;
					continue;
				}
			if (soap_flag_TaskFinishPercentage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TaskFinishPercentage", &(a->ns3__TaskExcuteData::TaskFinishPercentage), "xsd:int"))
				{	soap_flag_TaskFinishPercentage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskExcuteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__TaskExcuteData, 0, sizeof(ns3__TaskExcuteData), 0, soap_copy_ns3__TaskExcuteData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_PatrolDeviceName1 > 0 || soap_flag_PatrolDeviceId1 > 0 || soap_flag_TotalDeviceSize1 > 0 || soap_flag_ErrorDeviceSize1 > 0 || soap_flag_FinishDeviceSize1 > 0 || soap_flag_TaskFinishPercentage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__TaskExcuteData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__TaskExcuteData);
	if (this->soap_out(soap, tag?tag:"ns3:TaskExcuteData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TaskExcuteData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskExcuteData(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskExcuteData * SOAP_FMAC4 soap_get_ns3__TaskExcuteData(struct soap *soap, ns3__TaskExcuteData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskExcuteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__TaskExcuteData * SOAP_FMAC2 soap_instantiate_ns3__TaskExcuteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskExcuteData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__TaskExcuteData, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__TaskExcuteData);
		if (size)
			*size = sizeof(ns3__TaskExcuteData);
		((ns3__TaskExcuteData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__TaskExcuteData, n);
		if (size)
			*size = n * sizeof(ns3__TaskExcuteData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__TaskExcuteData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__TaskExcuteData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskExcuteData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskExcuteData %p -> %p\n", q, p));
	*(ns3__TaskExcuteData*)p = *(ns3__TaskExcuteData*)q;
}

void ns3__TaskPathInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__TaskPathInfo(soap, &this->ns3__TaskPathInfos::Infos);
	/* transient soap skipped */
}

void ns3__TaskPathInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__TaskPathInfo(soap, &this->ns3__TaskPathInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__TaskPathInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskPathInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskPathInfos(struct soap *soap, const char *tag, int id, const ns3__TaskPathInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__TaskPathInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__TaskPathInfo(soap, "Infos", -1, &(a->ns3__TaskPathInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskPathInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskPathInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskPathInfos * SOAP_FMAC4 soap_in_ns3__TaskPathInfos(struct soap *soap, const char *tag, ns3__TaskPathInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskPathInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__TaskPathInfos, sizeof(ns3__TaskPathInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__TaskPathInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskPathInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__TaskPathInfo(soap, "Infos", &(a->ns3__TaskPathInfos::Infos), "ns3:TaskPathInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskPathInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__TaskPathInfos, 0, sizeof(ns3__TaskPathInfos), 0, soap_copy_ns3__TaskPathInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__TaskPathInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__TaskPathInfos);
	if (this->soap_out(soap, tag?tag:"ns3:TaskPathInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TaskPathInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskPathInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskPathInfos * SOAP_FMAC4 soap_get_ns3__TaskPathInfos(struct soap *soap, ns3__TaskPathInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskPathInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__TaskPathInfos * SOAP_FMAC2 soap_instantiate_ns3__TaskPathInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskPathInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__TaskPathInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__TaskPathInfos);
		if (size)
			*size = sizeof(ns3__TaskPathInfos);
		((ns3__TaskPathInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__TaskPathInfos, n);
		if (size)
			*size = n * sizeof(ns3__TaskPathInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__TaskPathInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__TaskPathInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskPathInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskPathInfos %p -> %p\n", q, p));
	*(ns3__TaskPathInfos*)p = *(ns3__TaskPathInfos*)q;
}

void ns3__TaskPathInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__TaskPathInfo::TaskPathId);
	soap_default_std__string(soap, &this->ns3__TaskPathInfo::TaskPathName);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns3__TaskPathInfo::PointList);
	soap_default_std__string(soap, &this->ns3__TaskPathInfo::TaskPathType);
	soap_default_std__string(soap, &this->ns3__TaskPathInfo::CreateTime);
	soap_default_int(soap, &this->ns3__TaskPathInfo::FinishAction);
	/* transient soap skipped */
}

void ns3__TaskPathInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__TaskPathInfo::TaskPathId);
	soap_serialize_std__string(soap, &this->ns3__TaskPathInfo::TaskPathName);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns3__TaskPathInfo::PointList);
	soap_serialize_std__string(soap, &this->ns3__TaskPathInfo::TaskPathType);
	soap_serialize_std__string(soap, &this->ns3__TaskPathInfo::CreateTime);
	/* transient soap skipped */
#endif
}

int ns3__TaskPathInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskPathInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskPathInfo(struct soap *soap, const char *tag, int id, const ns3__TaskPathInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__TaskPathInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns3__TaskPathInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathName", -1, &(a->ns3__TaskPathInfo::TaskPathName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns3__TaskPathInfo::PointList), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathType", -1, &(a->ns3__TaskPathInfo::TaskPathType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CreateTime", -1, &(a->ns3__TaskPathInfo::CreateTime), ""))
		return soap->error;
	if (soap_out_int(soap, "FinishAction", -1, &(a->ns3__TaskPathInfo::FinishAction), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskPathInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskPathInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskPathInfo * SOAP_FMAC4 soap_in_ns3__TaskPathInfo(struct soap *soap, const char *tag, ns3__TaskPathInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskPathInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__TaskPathInfo, sizeof(ns3__TaskPathInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__TaskPathInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskPathInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_TaskPathName1 = 1;
	size_t soap_flag_TaskPathType1 = 1;
	size_t soap_flag_CreateTime1 = 1;
	size_t soap_flag_FinishAction1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns3__TaskPathInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap_flag_TaskPathName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathName", &(a->ns3__TaskPathInfo::TaskPathName), "xsd:string"))
				{	soap_flag_TaskPathName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns3__TaskPathInfo::PointList), "xsd:string"))
					continue;
			if (soap_flag_TaskPathType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathType", &(a->ns3__TaskPathInfo::TaskPathType), "xsd:string"))
				{	soap_flag_TaskPathType1--;
					continue;
				}
			if (soap_flag_CreateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CreateTime", &(a->ns3__TaskPathInfo::CreateTime), "xsd:string"))
				{	soap_flag_CreateTime1--;
					continue;
				}
			if (soap_flag_FinishAction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FinishAction", &(a->ns3__TaskPathInfo::FinishAction), "xsd:int"))
				{	soap_flag_FinishAction1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskPathInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__TaskPathInfo, 0, sizeof(ns3__TaskPathInfo), 0, soap_copy_ns3__TaskPathInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskPathId1 > 0 || soap_flag_TaskPathName1 > 0 || soap_flag_TaskPathType1 > 0 || soap_flag_CreateTime1 > 0 || soap_flag_FinishAction1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__TaskPathInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__TaskPathInfo);
	if (this->soap_out(soap, tag?tag:"ns3:TaskPathInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TaskPathInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskPathInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskPathInfo * SOAP_FMAC4 soap_get_ns3__TaskPathInfo(struct soap *soap, ns3__TaskPathInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__TaskPathInfo * SOAP_FMAC2 soap_instantiate_ns3__TaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__TaskPathInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__TaskPathInfo);
		if (size)
			*size = sizeof(ns3__TaskPathInfo);
		((ns3__TaskPathInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__TaskPathInfo, n);
		if (size)
			*size = n * sizeof(ns3__TaskPathInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__TaskPathInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__TaskPathInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskPathInfo %p -> %p\n", q, p));
	*(ns3__TaskPathInfo*)p = *(ns3__TaskPathInfo*)q;
}

void ns3__PatrolPointInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__PatrolPointInfo(soap, &this->ns3__PatrolPointInfos::Infos);
	/* transient soap skipped */
}

void ns3__PatrolPointInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__PatrolPointInfo(soap, &this->ns3__PatrolPointInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__PatrolPointInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PatrolPointInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PatrolPointInfos(struct soap *soap, const char *tag, int id, const ns3__PatrolPointInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__PatrolPointInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__PatrolPointInfo(soap, "Infos", -1, &(a->ns3__PatrolPointInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__PatrolPointInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__PatrolPointInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PatrolPointInfos * SOAP_FMAC4 soap_in_ns3__PatrolPointInfos(struct soap *soap, const char *tag, ns3__PatrolPointInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PatrolPointInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__PatrolPointInfos, sizeof(ns3__PatrolPointInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__PatrolPointInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__PatrolPointInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__PatrolPointInfo(soap, "Infos", &(a->ns3__PatrolPointInfos::Infos), "ns3:PatrolPointInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__PatrolPointInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__PatrolPointInfos, 0, sizeof(ns3__PatrolPointInfos), 0, soap_copy_ns3__PatrolPointInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__PatrolPointInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__PatrolPointInfos);
	if (this->soap_out(soap, tag?tag:"ns3:PatrolPointInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PatrolPointInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PatrolPointInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PatrolPointInfos * SOAP_FMAC4 soap_get_ns3__PatrolPointInfos(struct soap *soap, ns3__PatrolPointInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PatrolPointInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__PatrolPointInfos * SOAP_FMAC2 soap_instantiate_ns3__PatrolPointInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PatrolPointInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__PatrolPointInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__PatrolPointInfos);
		if (size)
			*size = sizeof(ns3__PatrolPointInfos);
		((ns3__PatrolPointInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__PatrolPointInfos, n);
		if (size)
			*size = n * sizeof(ns3__PatrolPointInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__PatrolPointInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__PatrolPointInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__PatrolPointInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__PatrolPointInfos %p -> %p\n", q, p));
	*(ns3__PatrolPointInfos*)p = *(ns3__PatrolPointInfos*)q;
}

void ns3__PatrolPointInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__PatrolPointInfo::PointId);
	soap_default_std__string(soap, &this->ns3__PatrolPointInfo::PointName);
	soap_default_std__string(soap, &this->ns3__PatrolPointInfo::PointType);
	soap_default_std__string(soap, &this->ns3__PatrolPointInfo::DeviceType);
	soap_default_std__string(soap, &this->ns3__PatrolPointInfo::AreaId);
	soap_default_std__string(soap, &this->ns3__PatrolPointInfo::DockId);
	soap_default_std__string(soap, &this->ns3__PatrolPointInfo::RobotIp);
	/* transient soap skipped */
}

void ns3__PatrolPointInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__PatrolPointInfo::PointId);
	soap_serialize_std__string(soap, &this->ns3__PatrolPointInfo::PointName);
	soap_serialize_std__string(soap, &this->ns3__PatrolPointInfo::PointType);
	soap_serialize_std__string(soap, &this->ns3__PatrolPointInfo::DeviceType);
	soap_serialize_std__string(soap, &this->ns3__PatrolPointInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns3__PatrolPointInfo::DockId);
	soap_serialize_std__string(soap, &this->ns3__PatrolPointInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns3__PatrolPointInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PatrolPointInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PatrolPointInfo(struct soap *soap, const char *tag, int id, const ns3__PatrolPointInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__PatrolPointInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "PointId", -1, &(a->ns3__PatrolPointInfo::PointId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointName", -1, &(a->ns3__PatrolPointInfo::PointName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointType", -1, &(a->ns3__PatrolPointInfo::PointType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DeviceType", -1, &(a->ns3__PatrolPointInfo::DeviceType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns3__PatrolPointInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockId", -1, &(a->ns3__PatrolPointInfo::DockId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__PatrolPointInfo::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__PatrolPointInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__PatrolPointInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PatrolPointInfo * SOAP_FMAC4 soap_in_ns3__PatrolPointInfo(struct soap *soap, const char *tag, ns3__PatrolPointInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PatrolPointInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__PatrolPointInfo, sizeof(ns3__PatrolPointInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__PatrolPointInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__PatrolPointInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PointId1 = 1;
	size_t soap_flag_PointName1 = 1;
	size_t soap_flag_PointType1 = 1;
	size_t soap_flag_DeviceType1 = 1;
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_DockId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PointId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointId", &(a->ns3__PatrolPointInfo::PointId), "xsd:string"))
				{	soap_flag_PointId1--;
					continue;
				}
			if (soap_flag_PointName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointName", &(a->ns3__PatrolPointInfo::PointName), "xsd:string"))
				{	soap_flag_PointName1--;
					continue;
				}
			if (soap_flag_PointType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointType", &(a->ns3__PatrolPointInfo::PointType), "xsd:string"))
				{	soap_flag_PointType1--;
					continue;
				}
			if (soap_flag_DeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DeviceType", &(a->ns3__PatrolPointInfo::DeviceType), "xsd:string"))
				{	soap_flag_DeviceType1--;
					continue;
				}
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns3__PatrolPointInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_DockId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockId", &(a->ns3__PatrolPointInfo::DockId), "xsd:string"))
				{	soap_flag_DockId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__PatrolPointInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__PatrolPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__PatrolPointInfo, 0, sizeof(ns3__PatrolPointInfo), 0, soap_copy_ns3__PatrolPointInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PointId1 > 0 || soap_flag_PointName1 > 0 || soap_flag_PointType1 > 0 || soap_flag_DeviceType1 > 0 || soap_flag_AreaId1 > 0 || soap_flag_DockId1 > 0 || soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__PatrolPointInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__PatrolPointInfo);
	if (this->soap_out(soap, tag?tag:"ns3:PatrolPointInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PatrolPointInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PatrolPointInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PatrolPointInfo * SOAP_FMAC4 soap_get_ns3__PatrolPointInfo(struct soap *soap, ns3__PatrolPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__PatrolPointInfo * SOAP_FMAC2 soap_instantiate_ns3__PatrolPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PatrolPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__PatrolPointInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__PatrolPointInfo);
		if (size)
			*size = sizeof(ns3__PatrolPointInfo);
		((ns3__PatrolPointInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__PatrolPointInfo, n);
		if (size)
			*size = n * sizeof(ns3__PatrolPointInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__PatrolPointInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__PatrolPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__PatrolPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__PatrolPointInfo %p -> %p\n", q, p));
	*(ns3__PatrolPointInfo*)p = *(ns3__PatrolPointInfo*)q;
}

void ns3__DockPointInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__DockPointInfo(soap, &this->ns3__DockPointInfos::Infos);
	/* transient soap skipped */
}

void ns3__DockPointInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__DockPointInfo(soap, &this->ns3__DockPointInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__DockPointInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DockPointInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DockPointInfos(struct soap *soap, const char *tag, int id, const ns3__DockPointInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__DockPointInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__DockPointInfo(soap, "Infos", -1, &(a->ns3__DockPointInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__DockPointInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__DockPointInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DockPointInfos * SOAP_FMAC4 soap_in_ns3__DockPointInfos(struct soap *soap, const char *tag, ns3__DockPointInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DockPointInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__DockPointInfos, sizeof(ns3__DockPointInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__DockPointInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__DockPointInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__DockPointInfo(soap, "Infos", &(a->ns3__DockPointInfos::Infos), "ns3:DockPointInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DockPointInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__DockPointInfos, 0, sizeof(ns3__DockPointInfos), 0, soap_copy_ns3__DockPointInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__DockPointInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__DockPointInfos);
	if (this->soap_out(soap, tag?tag:"ns3:DockPointInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__DockPointInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DockPointInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DockPointInfos * SOAP_FMAC4 soap_get_ns3__DockPointInfos(struct soap *soap, ns3__DockPointInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DockPointInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__DockPointInfos * SOAP_FMAC2 soap_instantiate_ns3__DockPointInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DockPointInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__DockPointInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__DockPointInfos);
		if (size)
			*size = sizeof(ns3__DockPointInfos);
		((ns3__DockPointInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__DockPointInfos, n);
		if (size)
			*size = n * sizeof(ns3__DockPointInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__DockPointInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__DockPointInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__DockPointInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__DockPointInfos %p -> %p\n", q, p));
	*(ns3__DockPointInfos*)p = *(ns3__DockPointInfos*)q;
}

void ns3__DockPointInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__DockPointInfo::DockId);
	soap_default_std__string(soap, &this->ns3__DockPointInfo::DockX);
	soap_default_std__string(soap, &this->ns3__DockPointInfo::DockY);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns3__DockPointInfo::PointList);
	/* transient soap skipped */
}

void ns3__DockPointInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__DockPointInfo::DockId);
	soap_serialize_std__string(soap, &this->ns3__DockPointInfo::DockX);
	soap_serialize_std__string(soap, &this->ns3__DockPointInfo::DockY);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns3__DockPointInfo::PointList);
	/* transient soap skipped */
#endif
}

int ns3__DockPointInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DockPointInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DockPointInfo(struct soap *soap, const char *tag, int id, const ns3__DockPointInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__DockPointInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "DockId", -1, &(a->ns3__DockPointInfo::DockId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockX", -1, &(a->ns3__DockPointInfo::DockX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockY", -1, &(a->ns3__DockPointInfo::DockY), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns3__DockPointInfo::PointList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__DockPointInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__DockPointInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DockPointInfo * SOAP_FMAC4 soap_in_ns3__DockPointInfo(struct soap *soap, const char *tag, ns3__DockPointInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DockPointInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__DockPointInfo, sizeof(ns3__DockPointInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__DockPointInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__DockPointInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DockId1 = 1;
	size_t soap_flag_DockX1 = 1;
	size_t soap_flag_DockY1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DockId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockId", &(a->ns3__DockPointInfo::DockId), "xsd:string"))
				{	soap_flag_DockId1--;
					continue;
				}
			if (soap_flag_DockX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockX", &(a->ns3__DockPointInfo::DockX), "xsd:string"))
				{	soap_flag_DockX1--;
					continue;
				}
			if (soap_flag_DockY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockY", &(a->ns3__DockPointInfo::DockY), "xsd:string"))
				{	soap_flag_DockY1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns3__DockPointInfo::PointList), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DockPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__DockPointInfo, 0, sizeof(ns3__DockPointInfo), 0, soap_copy_ns3__DockPointInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DockId1 > 0 || soap_flag_DockX1 > 0 || soap_flag_DockY1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__DockPointInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__DockPointInfo);
	if (this->soap_out(soap, tag?tag:"ns3:DockPointInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__DockPointInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DockPointInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DockPointInfo * SOAP_FMAC4 soap_get_ns3__DockPointInfo(struct soap *soap, ns3__DockPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__DockPointInfo * SOAP_FMAC2 soap_instantiate_ns3__DockPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DockPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__DockPointInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__DockPointInfo);
		if (size)
			*size = sizeof(ns3__DockPointInfo);
		((ns3__DockPointInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__DockPointInfo, n);
		if (size)
			*size = n * sizeof(ns3__DockPointInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__DockPointInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__DockPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__DockPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__DockPointInfo %p -> %p\n", q, p));
	*(ns3__DockPointInfo*)p = *(ns3__DockPointInfo*)q;
}

void ns3__MapEdgeInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__MapEdgeInfo(soap, &this->ns3__MapEdgeInfos::Infos);
	/* transient soap skipped */
}

void ns3__MapEdgeInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__MapEdgeInfo(soap, &this->ns3__MapEdgeInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__MapEdgeInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__MapEdgeInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MapEdgeInfos(struct soap *soap, const char *tag, int id, const ns3__MapEdgeInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__MapEdgeInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__MapEdgeInfo(soap, "Infos", -1, &(a->ns3__MapEdgeInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__MapEdgeInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__MapEdgeInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__MapEdgeInfos * SOAP_FMAC4 soap_in_ns3__MapEdgeInfos(struct soap *soap, const char *tag, ns3__MapEdgeInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__MapEdgeInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__MapEdgeInfos, sizeof(ns3__MapEdgeInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__MapEdgeInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__MapEdgeInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__MapEdgeInfo(soap, "Infos", &(a->ns3__MapEdgeInfos::Infos), "ns3:MapEdgeInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__MapEdgeInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__MapEdgeInfos, 0, sizeof(ns3__MapEdgeInfos), 0, soap_copy_ns3__MapEdgeInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__MapEdgeInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__MapEdgeInfos);
	if (this->soap_out(soap, tag?tag:"ns3:MapEdgeInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__MapEdgeInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__MapEdgeInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__MapEdgeInfos * SOAP_FMAC4 soap_get_ns3__MapEdgeInfos(struct soap *soap, ns3__MapEdgeInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MapEdgeInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__MapEdgeInfos * SOAP_FMAC2 soap_instantiate_ns3__MapEdgeInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__MapEdgeInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__MapEdgeInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__MapEdgeInfos);
		if (size)
			*size = sizeof(ns3__MapEdgeInfos);
		((ns3__MapEdgeInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__MapEdgeInfos, n);
		if (size)
			*size = n * sizeof(ns3__MapEdgeInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__MapEdgeInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__MapEdgeInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__MapEdgeInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__MapEdgeInfos %p -> %p\n", q, p));
	*(ns3__MapEdgeInfos*)p = *(ns3__MapEdgeInfos*)q;
}

void ns3__MapEdgeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::EdgeId);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::StartNodeId);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::EndNodeId);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::StartNodeX);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::StartNodeY);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::EndNodeX);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::EndNodeY);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::FirstControlX);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::FirstControlY);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::SecondControlX);
	soap_default_std__string(soap, &this->ns3__MapEdgeInfo::SecondControlY);
	/* transient soap skipped */
}

void ns3__MapEdgeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::EdgeId);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::StartNodeId);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::EndNodeId);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::StartNodeX);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::StartNodeY);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::EndNodeX);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::EndNodeY);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::FirstControlX);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::FirstControlY);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::SecondControlX);
	soap_serialize_std__string(soap, &this->ns3__MapEdgeInfo::SecondControlY);
	/* transient soap skipped */
#endif
}

int ns3__MapEdgeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__MapEdgeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MapEdgeInfo(struct soap *soap, const char *tag, int id, const ns3__MapEdgeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__MapEdgeInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "EdgeId", -1, &(a->ns3__MapEdgeInfo::EdgeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeId", -1, &(a->ns3__MapEdgeInfo::StartNodeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeId", -1, &(a->ns3__MapEdgeInfo::EndNodeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeX", -1, &(a->ns3__MapEdgeInfo::StartNodeX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeY", -1, &(a->ns3__MapEdgeInfo::StartNodeY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeX", -1, &(a->ns3__MapEdgeInfo::EndNodeX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeY", -1, &(a->ns3__MapEdgeInfo::EndNodeY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FirstControlX", -1, &(a->ns3__MapEdgeInfo::FirstControlX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FirstControlY", -1, &(a->ns3__MapEdgeInfo::FirstControlY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SecondControlX", -1, &(a->ns3__MapEdgeInfo::SecondControlX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SecondControlY", -1, &(a->ns3__MapEdgeInfo::SecondControlY), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__MapEdgeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__MapEdgeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__MapEdgeInfo * SOAP_FMAC4 soap_in_ns3__MapEdgeInfo(struct soap *soap, const char *tag, ns3__MapEdgeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__MapEdgeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__MapEdgeInfo, sizeof(ns3__MapEdgeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__MapEdgeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__MapEdgeInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EdgeId1 = 1;
	size_t soap_flag_StartNodeId1 = 1;
	size_t soap_flag_EndNodeId1 = 1;
	size_t soap_flag_StartNodeX1 = 1;
	size_t soap_flag_StartNodeY1 = 1;
	size_t soap_flag_EndNodeX1 = 1;
	size_t soap_flag_EndNodeY1 = 1;
	size_t soap_flag_FirstControlX1 = 1;
	size_t soap_flag_FirstControlY1 = 1;
	size_t soap_flag_SecondControlX1 = 1;
	size_t soap_flag_SecondControlY1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EdgeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EdgeId", &(a->ns3__MapEdgeInfo::EdgeId), "xsd:string"))
				{	soap_flag_EdgeId1--;
					continue;
				}
			if (soap_flag_StartNodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeId", &(a->ns3__MapEdgeInfo::StartNodeId), "xsd:string"))
				{	soap_flag_StartNodeId1--;
					continue;
				}
			if (soap_flag_EndNodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeId", &(a->ns3__MapEdgeInfo::EndNodeId), "xsd:string"))
				{	soap_flag_EndNodeId1--;
					continue;
				}
			if (soap_flag_StartNodeX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeX", &(a->ns3__MapEdgeInfo::StartNodeX), "xsd:string"))
				{	soap_flag_StartNodeX1--;
					continue;
				}
			if (soap_flag_StartNodeY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeY", &(a->ns3__MapEdgeInfo::StartNodeY), "xsd:string"))
				{	soap_flag_StartNodeY1--;
					continue;
				}
			if (soap_flag_EndNodeX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeX", &(a->ns3__MapEdgeInfo::EndNodeX), "xsd:string"))
				{	soap_flag_EndNodeX1--;
					continue;
				}
			if (soap_flag_EndNodeY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeY", &(a->ns3__MapEdgeInfo::EndNodeY), "xsd:string"))
				{	soap_flag_EndNodeY1--;
					continue;
				}
			if (soap_flag_FirstControlX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FirstControlX", &(a->ns3__MapEdgeInfo::FirstControlX), "xsd:string"))
				{	soap_flag_FirstControlX1--;
					continue;
				}
			if (soap_flag_FirstControlY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FirstControlY", &(a->ns3__MapEdgeInfo::FirstControlY), "xsd:string"))
				{	soap_flag_FirstControlY1--;
					continue;
				}
			if (soap_flag_SecondControlX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SecondControlX", &(a->ns3__MapEdgeInfo::SecondControlX), "xsd:string"))
				{	soap_flag_SecondControlX1--;
					continue;
				}
			if (soap_flag_SecondControlY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SecondControlY", &(a->ns3__MapEdgeInfo::SecondControlY), "xsd:string"))
				{	soap_flag_SecondControlY1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__MapEdgeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__MapEdgeInfo, 0, sizeof(ns3__MapEdgeInfo), 0, soap_copy_ns3__MapEdgeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EdgeId1 > 0 || soap_flag_StartNodeId1 > 0 || soap_flag_EndNodeId1 > 0 || soap_flag_StartNodeX1 > 0 || soap_flag_StartNodeY1 > 0 || soap_flag_EndNodeX1 > 0 || soap_flag_EndNodeY1 > 0 || soap_flag_FirstControlX1 > 0 || soap_flag_FirstControlY1 > 0 || soap_flag_SecondControlX1 > 0 || soap_flag_SecondControlY1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__MapEdgeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__MapEdgeInfo);
	if (this->soap_out(soap, tag?tag:"ns3:MapEdgeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__MapEdgeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__MapEdgeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__MapEdgeInfo * SOAP_FMAC4 soap_get_ns3__MapEdgeInfo(struct soap *soap, ns3__MapEdgeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__MapEdgeInfo * SOAP_FMAC2 soap_instantiate_ns3__MapEdgeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__MapEdgeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__MapEdgeInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__MapEdgeInfo);
		if (size)
			*size = sizeof(ns3__MapEdgeInfo);
		((ns3__MapEdgeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__MapEdgeInfo, n);
		if (size)
			*size = n * sizeof(ns3__MapEdgeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__MapEdgeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__MapEdgeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__MapEdgeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__MapEdgeInfo %p -> %p\n", q, p));
	*(ns3__MapEdgeInfo*)p = *(ns3__MapEdgeInfo*)q;
}

void ns3__PatrolAreaInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(soap, &this->ns3__PatrolAreaInfos::Infos);
	/* transient soap skipped */
}

void ns3__PatrolAreaInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(soap, &this->ns3__PatrolAreaInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__PatrolAreaInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PatrolAreaInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PatrolAreaInfos(struct soap *soap, const char *tag, int id, const ns3__PatrolAreaInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__PatrolAreaInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(soap, "Infos", -1, &(a->ns3__PatrolAreaInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__PatrolAreaInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__PatrolAreaInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PatrolAreaInfos * SOAP_FMAC4 soap_in_ns3__PatrolAreaInfos(struct soap *soap, const char *tag, ns3__PatrolAreaInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PatrolAreaInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__PatrolAreaInfos, sizeof(ns3__PatrolAreaInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__PatrolAreaInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__PatrolAreaInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(soap, "Infos", &(a->ns3__PatrolAreaInfos::Infos), "ns3:PatrolAreaInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__PatrolAreaInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__PatrolAreaInfos, 0, sizeof(ns3__PatrolAreaInfos), 0, soap_copy_ns3__PatrolAreaInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__PatrolAreaInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__PatrolAreaInfos);
	if (this->soap_out(soap, tag?tag:"ns3:PatrolAreaInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PatrolAreaInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PatrolAreaInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PatrolAreaInfos * SOAP_FMAC4 soap_get_ns3__PatrolAreaInfos(struct soap *soap, ns3__PatrolAreaInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PatrolAreaInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__PatrolAreaInfos * SOAP_FMAC2 soap_instantiate_ns3__PatrolAreaInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PatrolAreaInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__PatrolAreaInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__PatrolAreaInfos);
		if (size)
			*size = sizeof(ns3__PatrolAreaInfos);
		((ns3__PatrolAreaInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__PatrolAreaInfos, n);
		if (size)
			*size = n * sizeof(ns3__PatrolAreaInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__PatrolAreaInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__PatrolAreaInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__PatrolAreaInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__PatrolAreaInfos %p -> %p\n", q, p));
	*(ns3__PatrolAreaInfos*)p = *(ns3__PatrolAreaInfos*)q;
}

void ns3__PatrolAreaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__PatrolAreaInfo::AreaId);
	soap_default_std__string(soap, &this->ns3__PatrolAreaInfo::AreaName);
	soap_default_std__string(soap, &this->ns3__PatrolAreaInfo::ParentId);
	soap_default_std__string(soap, &this->ns3__PatrolAreaInfo::RobotIp);
	/* transient soap skipped */
}

void ns3__PatrolAreaInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__PatrolAreaInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns3__PatrolAreaInfo::AreaName);
	soap_serialize_std__string(soap, &this->ns3__PatrolAreaInfo::ParentId);
	soap_serialize_std__string(soap, &this->ns3__PatrolAreaInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns3__PatrolAreaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PatrolAreaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PatrolAreaInfo(struct soap *soap, const char *tag, int id, const ns3__PatrolAreaInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__PatrolAreaInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns3__PatrolAreaInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaName", -1, &(a->ns3__PatrolAreaInfo::AreaName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ParentId", -1, &(a->ns3__PatrolAreaInfo::ParentId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__PatrolAreaInfo::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__PatrolAreaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__PatrolAreaInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PatrolAreaInfo * SOAP_FMAC4 soap_in_ns3__PatrolAreaInfo(struct soap *soap, const char *tag, ns3__PatrolAreaInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PatrolAreaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__PatrolAreaInfo, sizeof(ns3__PatrolAreaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__PatrolAreaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__PatrolAreaInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_AreaName1 = 1;
	size_t soap_flag_ParentId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns3__PatrolAreaInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_AreaName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaName", &(a->ns3__PatrolAreaInfo::AreaName), "xsd:string"))
				{	soap_flag_AreaName1--;
					continue;
				}
			if (soap_flag_ParentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ParentId", &(a->ns3__PatrolAreaInfo::ParentId), "xsd:string"))
				{	soap_flag_ParentId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__PatrolAreaInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__PatrolAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__PatrolAreaInfo, 0, sizeof(ns3__PatrolAreaInfo), 0, soap_copy_ns3__PatrolAreaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AreaId1 > 0 || soap_flag_AreaName1 > 0 || soap_flag_ParentId1 > 0 || soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__PatrolAreaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__PatrolAreaInfo);
	if (this->soap_out(soap, tag?tag:"ns3:PatrolAreaInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PatrolAreaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PatrolAreaInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PatrolAreaInfo * SOAP_FMAC4 soap_get_ns3__PatrolAreaInfo(struct soap *soap, ns3__PatrolAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__PatrolAreaInfo * SOAP_FMAC2 soap_instantiate_ns3__PatrolAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PatrolAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__PatrolAreaInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__PatrolAreaInfo);
		if (size)
			*size = sizeof(ns3__PatrolAreaInfo);
		((ns3__PatrolAreaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__PatrolAreaInfo, n);
		if (size)
			*size = n * sizeof(ns3__PatrolAreaInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__PatrolAreaInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__PatrolAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__PatrolAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__PatrolAreaInfo %p -> %p\n", q, p));
	*(ns3__PatrolAreaInfo*)p = *(ns3__PatrolAreaInfo*)q;
}

void ns3__MapAreaInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__MapAreaInfo(soap, &this->ns3__MapAreaInfos::Infos);
	/* transient soap skipped */
}

void ns3__MapAreaInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__MapAreaInfo(soap, &this->ns3__MapAreaInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__MapAreaInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__MapAreaInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MapAreaInfos(struct soap *soap, const char *tag, int id, const ns3__MapAreaInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__MapAreaInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__MapAreaInfo(soap, "Infos", -1, &(a->ns3__MapAreaInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__MapAreaInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__MapAreaInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__MapAreaInfos * SOAP_FMAC4 soap_in_ns3__MapAreaInfos(struct soap *soap, const char *tag, ns3__MapAreaInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__MapAreaInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__MapAreaInfos, sizeof(ns3__MapAreaInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__MapAreaInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__MapAreaInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__MapAreaInfo(soap, "Infos", &(a->ns3__MapAreaInfos::Infos), "ns3:MapAreaInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__MapAreaInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__MapAreaInfos, 0, sizeof(ns3__MapAreaInfos), 0, soap_copy_ns3__MapAreaInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__MapAreaInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__MapAreaInfos);
	if (this->soap_out(soap, tag?tag:"ns3:MapAreaInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__MapAreaInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__MapAreaInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__MapAreaInfos * SOAP_FMAC4 soap_get_ns3__MapAreaInfos(struct soap *soap, ns3__MapAreaInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MapAreaInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__MapAreaInfos * SOAP_FMAC2 soap_instantiate_ns3__MapAreaInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__MapAreaInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__MapAreaInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__MapAreaInfos);
		if (size)
			*size = sizeof(ns3__MapAreaInfos);
		((ns3__MapAreaInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__MapAreaInfos, n);
		if (size)
			*size = n * sizeof(ns3__MapAreaInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__MapAreaInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__MapAreaInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__MapAreaInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__MapAreaInfos %p -> %p\n", q, p));
	*(ns3__MapAreaInfos*)p = *(ns3__MapAreaInfos*)q;
}

void ns3__MapAreaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::RobotIp);
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::AreaId);
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::AreaName);
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::AreaMap);
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::MaxX);
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::MaxY);
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::MinX);
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::MinY);
	soap_default_std__string(soap, &this->ns3__MapAreaInfo::ParentId);
	/* transient soap skipped */
}

void ns3__MapAreaInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::AreaName);
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::AreaMap);
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::MaxX);
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::MaxY);
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::MinX);
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::MinY);
	soap_serialize_std__string(soap, &this->ns3__MapAreaInfo::ParentId);
	/* transient soap skipped */
#endif
}

int ns3__MapAreaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__MapAreaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MapAreaInfo(struct soap *soap, const char *tag, int id, const ns3__MapAreaInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__MapAreaInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__MapAreaInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns3__MapAreaInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaName", -1, &(a->ns3__MapAreaInfo::AreaName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaMap", -1, &(a->ns3__MapAreaInfo::AreaMap), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MaxX", -1, &(a->ns3__MapAreaInfo::MaxX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MaxY", -1, &(a->ns3__MapAreaInfo::MaxY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MinX", -1, &(a->ns3__MapAreaInfo::MinX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MinY", -1, &(a->ns3__MapAreaInfo::MinY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ParentId", -1, &(a->ns3__MapAreaInfo::ParentId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__MapAreaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__MapAreaInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__MapAreaInfo * SOAP_FMAC4 soap_in_ns3__MapAreaInfo(struct soap *soap, const char *tag, ns3__MapAreaInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__MapAreaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__MapAreaInfo, sizeof(ns3__MapAreaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__MapAreaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__MapAreaInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_AreaName1 = 1;
	size_t soap_flag_AreaMap1 = 1;
	size_t soap_flag_MaxX1 = 1;
	size_t soap_flag_MaxY1 = 1;
	size_t soap_flag_MinX1 = 1;
	size_t soap_flag_MinY1 = 1;
	size_t soap_flag_ParentId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__MapAreaInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns3__MapAreaInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_AreaName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaName", &(a->ns3__MapAreaInfo::AreaName), "xsd:string"))
				{	soap_flag_AreaName1--;
					continue;
				}
			if (soap_flag_AreaMap1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaMap", &(a->ns3__MapAreaInfo::AreaMap), "xsd:string"))
				{	soap_flag_AreaMap1--;
					continue;
				}
			if (soap_flag_MaxX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MaxX", &(a->ns3__MapAreaInfo::MaxX), "xsd:string"))
				{	soap_flag_MaxX1--;
					continue;
				}
			if (soap_flag_MaxY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MaxY", &(a->ns3__MapAreaInfo::MaxY), "xsd:string"))
				{	soap_flag_MaxY1--;
					continue;
				}
			if (soap_flag_MinX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MinX", &(a->ns3__MapAreaInfo::MinX), "xsd:string"))
				{	soap_flag_MinX1--;
					continue;
				}
			if (soap_flag_MinY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MinY", &(a->ns3__MapAreaInfo::MinY), "xsd:string"))
				{	soap_flag_MinY1--;
					continue;
				}
			if (soap_flag_ParentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ParentId", &(a->ns3__MapAreaInfo::ParentId), "xsd:string"))
				{	soap_flag_ParentId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__MapAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__MapAreaInfo, 0, sizeof(ns3__MapAreaInfo), 0, soap_copy_ns3__MapAreaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_AreaId1 > 0 || soap_flag_AreaName1 > 0 || soap_flag_AreaMap1 > 0 || soap_flag_MaxX1 > 0 || soap_flag_MaxY1 > 0 || soap_flag_MinX1 > 0 || soap_flag_MinY1 > 0 || soap_flag_ParentId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__MapAreaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__MapAreaInfo);
	if (this->soap_out(soap, tag?tag:"ns3:MapAreaInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__MapAreaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__MapAreaInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__MapAreaInfo * SOAP_FMAC4 soap_get_ns3__MapAreaInfo(struct soap *soap, ns3__MapAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__MapAreaInfo * SOAP_FMAC2 soap_instantiate_ns3__MapAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__MapAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__MapAreaInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__MapAreaInfo);
		if (size)
			*size = sizeof(ns3__MapAreaInfo);
		((ns3__MapAreaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__MapAreaInfo, n);
		if (size)
			*size = n * sizeof(ns3__MapAreaInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__MapAreaInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__MapAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__MapAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__MapAreaInfo %p -> %p\n", q, p));
	*(ns3__MapAreaInfo*)p = *(ns3__MapAreaInfo*)q;
}

void ns3__RobotAlarmInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(soap, &this->ns3__RobotAlarmInfos::Infos);
	/* transient soap skipped */
}

void ns3__RobotAlarmInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(soap, &this->ns3__RobotAlarmInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__RobotAlarmInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotAlarmInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotAlarmInfos(struct soap *soap, const char *tag, int id, const ns3__RobotAlarmInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotAlarmInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(soap, "Infos", -1, &(a->ns3__RobotAlarmInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotAlarmInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotAlarmInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotAlarmInfos * SOAP_FMAC4 soap_in_ns3__RobotAlarmInfos(struct soap *soap, const char *tag, ns3__RobotAlarmInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotAlarmInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotAlarmInfos, sizeof(ns3__RobotAlarmInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotAlarmInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotAlarmInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(soap, "Infos", &(a->ns3__RobotAlarmInfos::Infos), "ns3:RobotAlarmInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotAlarmInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotAlarmInfos, 0, sizeof(ns3__RobotAlarmInfos), 0, soap_copy_ns3__RobotAlarmInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__RobotAlarmInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotAlarmInfos);
	if (this->soap_out(soap, tag?tag:"ns3:RobotAlarmInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotAlarmInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotAlarmInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotAlarmInfos * SOAP_FMAC4 soap_get_ns3__RobotAlarmInfos(struct soap *soap, ns3__RobotAlarmInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotAlarmInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotAlarmInfos * SOAP_FMAC2 soap_instantiate_ns3__RobotAlarmInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotAlarmInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotAlarmInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotAlarmInfos);
		if (size)
			*size = sizeof(ns3__RobotAlarmInfos);
		((ns3__RobotAlarmInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotAlarmInfos, n);
		if (size)
			*size = n * sizeof(ns3__RobotAlarmInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotAlarmInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotAlarmInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotAlarmInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotAlarmInfos %p -> %p\n", q, p));
	*(ns3__RobotAlarmInfos*)p = *(ns3__RobotAlarmInfos*)q;
}

void ns3__RobotAlarmInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__RobotAlarmInfo::AlarmId);
	soap_default_std__string(soap, &this->ns3__RobotAlarmInfo::RobotIp);
	soap_default_std__string(soap, &this->ns3__RobotAlarmInfo::AlarmType);
	soap_default_std__string(soap, &this->ns3__RobotAlarmInfo::AlarmDesc);
	soap_default_std__string(soap, &this->ns3__RobotAlarmInfo::AlarmTime);
	/* transient soap skipped */
}

void ns3__RobotAlarmInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__RobotAlarmInfo::AlarmId);
	soap_serialize_std__string(soap, &this->ns3__RobotAlarmInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns3__RobotAlarmInfo::AlarmType);
	soap_serialize_std__string(soap, &this->ns3__RobotAlarmInfo::AlarmDesc);
	soap_serialize_std__string(soap, &this->ns3__RobotAlarmInfo::AlarmTime);
	/* transient soap skipped */
#endif
}

int ns3__RobotAlarmInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotAlarmInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotAlarmInfo(struct soap *soap, const char *tag, int id, const ns3__RobotAlarmInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotAlarmInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmId", -1, &(a->ns3__RobotAlarmInfo::AlarmId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__RobotAlarmInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmType", -1, &(a->ns3__RobotAlarmInfo::AlarmType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmDesc", -1, &(a->ns3__RobotAlarmInfo::AlarmDesc), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmTime", -1, &(a->ns3__RobotAlarmInfo::AlarmTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotAlarmInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotAlarmInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotAlarmInfo * SOAP_FMAC4 soap_in_ns3__RobotAlarmInfo(struct soap *soap, const char *tag, ns3__RobotAlarmInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotAlarmInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotAlarmInfo, sizeof(ns3__RobotAlarmInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotAlarmInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotAlarmInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AlarmId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_AlarmType1 = 1;
	size_t soap_flag_AlarmDesc1 = 1;
	size_t soap_flag_AlarmTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AlarmId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmId", &(a->ns3__RobotAlarmInfo::AlarmId), "xsd:string"))
				{	soap_flag_AlarmId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__RobotAlarmInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_AlarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmType", &(a->ns3__RobotAlarmInfo::AlarmType), "xsd:string"))
				{	soap_flag_AlarmType1--;
					continue;
				}
			if (soap_flag_AlarmDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmDesc", &(a->ns3__RobotAlarmInfo::AlarmDesc), "xsd:string"))
				{	soap_flag_AlarmDesc1--;
					continue;
				}
			if (soap_flag_AlarmTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmTime", &(a->ns3__RobotAlarmInfo::AlarmTime), "xsd:string"))
				{	soap_flag_AlarmTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotAlarmInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotAlarmInfo, 0, sizeof(ns3__RobotAlarmInfo), 0, soap_copy_ns3__RobotAlarmInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AlarmId1 > 0 || soap_flag_RobotIp1 > 0 || soap_flag_AlarmType1 > 0 || soap_flag_AlarmDesc1 > 0 || soap_flag_AlarmTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__RobotAlarmInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotAlarmInfo);
	if (this->soap_out(soap, tag?tag:"ns3:RobotAlarmInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotAlarmInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotAlarmInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotAlarmInfo * SOAP_FMAC4 soap_get_ns3__RobotAlarmInfo(struct soap *soap, ns3__RobotAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotAlarmInfo * SOAP_FMAC2 soap_instantiate_ns3__RobotAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotAlarmInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotAlarmInfo);
		if (size)
			*size = sizeof(ns3__RobotAlarmInfo);
		((ns3__RobotAlarmInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotAlarmInfo, n);
		if (size)
			*size = n * sizeof(ns3__RobotAlarmInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotAlarmInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotAlarmInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotAlarmInfo %p -> %p\n", q, p));
	*(ns3__RobotAlarmInfo*)p = *(ns3__RobotAlarmInfo*)q;
}

void ns3__RobotGasInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__RobotGasInfo(soap, &this->ns3__RobotGasInfos::GasContents);
	/* transient soap skipped */
}

void ns3__RobotGasInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__RobotGasInfo(soap, &this->ns3__RobotGasInfos::GasContents);
	/* transient soap skipped */
#endif
}

int ns3__RobotGasInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotGasInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotGasInfos(struct soap *soap, const char *tag, int id, const ns3__RobotGasInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotGasInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__RobotGasInfo(soap, "GasContents", -1, &(a->ns3__RobotGasInfos::GasContents), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotGasInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotGasInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotGasInfos * SOAP_FMAC4 soap_in_ns3__RobotGasInfos(struct soap *soap, const char *tag, ns3__RobotGasInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotGasInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotGasInfos, sizeof(ns3__RobotGasInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotGasInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotGasInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__RobotGasInfo(soap, "GasContents", &(a->ns3__RobotGasInfos::GasContents), "ns3:RobotGasInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotGasInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotGasInfos, 0, sizeof(ns3__RobotGasInfos), 0, soap_copy_ns3__RobotGasInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__RobotGasInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotGasInfos);
	if (this->soap_out(soap, tag?tag:"ns3:RobotGasInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotGasInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotGasInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotGasInfos * SOAP_FMAC4 soap_get_ns3__RobotGasInfos(struct soap *soap, ns3__RobotGasInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotGasInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotGasInfos * SOAP_FMAC2 soap_instantiate_ns3__RobotGasInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotGasInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotGasInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotGasInfos);
		if (size)
			*size = sizeof(ns3__RobotGasInfos);
		((ns3__RobotGasInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotGasInfos, n);
		if (size)
			*size = n * sizeof(ns3__RobotGasInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotGasInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotGasInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotGasInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotGasInfos %p -> %p\n", q, p));
	*(ns3__RobotGasInfos*)p = *(ns3__RobotGasInfos*)q;
}

void ns3__RobotGasInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::robot_ip);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::H2S);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::CO);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::O2);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::CH4);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::TEMP);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::HUM);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::PM25);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::PM10);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::O3);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::SF6);
	soap_default_std__string(soap, &this->ns3__RobotGasInfo::Desc);
	/* transient soap skipped */
}

void ns3__RobotGasInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::robot_ip);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::H2S);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::CO);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::O2);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::CH4);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::TEMP);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::HUM);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::PM25);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::PM10);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::O3);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::SF6);
	soap_serialize_std__string(soap, &this->ns3__RobotGasInfo::Desc);
	/* transient soap skipped */
#endif
}

int ns3__RobotGasInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotGasInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotGasInfo(struct soap *soap, const char *tag, int id, const ns3__RobotGasInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotGasInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "robot-ip", -1, &(a->ns3__RobotGasInfo::robot_ip), ""))
		return soap->error;
	if (soap_out_std__string(soap, "H2S", -1, &(a->ns3__RobotGasInfo::H2S), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CO", -1, &(a->ns3__RobotGasInfo::CO), ""))
		return soap->error;
	if (soap_out_std__string(soap, "O2", -1, &(a->ns3__RobotGasInfo::O2), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CH4", -1, &(a->ns3__RobotGasInfo::CH4), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TEMP", -1, &(a->ns3__RobotGasInfo::TEMP), ""))
		return soap->error;
	if (soap_out_std__string(soap, "HUM", -1, &(a->ns3__RobotGasInfo::HUM), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PM25", -1, &(a->ns3__RobotGasInfo::PM25), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PM10", -1, &(a->ns3__RobotGasInfo::PM10), ""))
		return soap->error;
	if (soap_out_std__string(soap, "O3", -1, &(a->ns3__RobotGasInfo::O3), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SF6", -1, &(a->ns3__RobotGasInfo::SF6), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Desc", -1, &(a->ns3__RobotGasInfo::Desc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotGasInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotGasInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotGasInfo * SOAP_FMAC4 soap_in_ns3__RobotGasInfo(struct soap *soap, const char *tag, ns3__RobotGasInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotGasInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotGasInfo, sizeof(ns3__RobotGasInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotGasInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotGasInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot_ip1 = 1;
	size_t soap_flag_H2S1 = 1;
	size_t soap_flag_CO1 = 1;
	size_t soap_flag_O21 = 1;
	size_t soap_flag_CH41 = 1;
	size_t soap_flag_TEMP1 = 1;
	size_t soap_flag_HUM1 = 1;
	size_t soap_flag_PM251 = 1;
	size_t soap_flag_PM101 = 1;
	size_t soap_flag_O31 = 1;
	size_t soap_flag_SF61 = 1;
	size_t soap_flag_Desc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot_ip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "robot-ip", &(a->ns3__RobotGasInfo::robot_ip), "xsd:string"))
				{	soap_flag_robot_ip1--;
					continue;
				}
			if (soap_flag_H2S1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "H2S", &(a->ns3__RobotGasInfo::H2S), "xsd:string"))
				{	soap_flag_H2S1--;
					continue;
				}
			if (soap_flag_CO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CO", &(a->ns3__RobotGasInfo::CO), "xsd:string"))
				{	soap_flag_CO1--;
					continue;
				}
			if (soap_flag_O21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "O2", &(a->ns3__RobotGasInfo::O2), "xsd:string"))
				{	soap_flag_O21--;
					continue;
				}
			if (soap_flag_CH41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CH4", &(a->ns3__RobotGasInfo::CH4), "xsd:string"))
				{	soap_flag_CH41--;
					continue;
				}
			if (soap_flag_TEMP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TEMP", &(a->ns3__RobotGasInfo::TEMP), "xsd:string"))
				{	soap_flag_TEMP1--;
					continue;
				}
			if (soap_flag_HUM1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HUM", &(a->ns3__RobotGasInfo::HUM), "xsd:string"))
				{	soap_flag_HUM1--;
					continue;
				}
			if (soap_flag_PM251 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PM25", &(a->ns3__RobotGasInfo::PM25), "xsd:string"))
				{	soap_flag_PM251--;
					continue;
				}
			if (soap_flag_PM101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PM10", &(a->ns3__RobotGasInfo::PM10), "xsd:string"))
				{	soap_flag_PM101--;
					continue;
				}
			if (soap_flag_O31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "O3", &(a->ns3__RobotGasInfo::O3), "xsd:string"))
				{	soap_flag_O31--;
					continue;
				}
			if (soap_flag_SF61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SF6", &(a->ns3__RobotGasInfo::SF6), "xsd:string"))
				{	soap_flag_SF61--;
					continue;
				}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Desc", &(a->ns3__RobotGasInfo::Desc), "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotGasInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotGasInfo, 0, sizeof(ns3__RobotGasInfo), 0, soap_copy_ns3__RobotGasInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot_ip1 > 0 || soap_flag_H2S1 > 0 || soap_flag_CO1 > 0 || soap_flag_O21 > 0 || soap_flag_CH41 > 0 || soap_flag_TEMP1 > 0 || soap_flag_HUM1 > 0 || soap_flag_PM251 > 0 || soap_flag_PM101 > 0 || soap_flag_O31 > 0 || soap_flag_SF61 > 0 || soap_flag_Desc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__RobotGasInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotGasInfo);
	if (this->soap_out(soap, tag?tag:"ns3:RobotGasInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotGasInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotGasInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotGasInfo * SOAP_FMAC4 soap_get_ns3__RobotGasInfo(struct soap *soap, ns3__RobotGasInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotGasInfo * SOAP_FMAC2 soap_instantiate_ns3__RobotGasInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotGasInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotGasInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotGasInfo);
		if (size)
			*size = sizeof(ns3__RobotGasInfo);
		((ns3__RobotGasInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotGasInfo, n);
		if (size)
			*size = n * sizeof(ns3__RobotGasInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotGasInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotGasInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotGasInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotGasInfo %p -> %p\n", q, p));
	*(ns3__RobotGasInfo*)p = *(ns3__RobotGasInfo*)q;
}

void ns3__RobotMileageInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__RobotMileageInfo(soap, &this->ns3__RobotMileageInfos::Infos);
	/* transient soap skipped */
}

void ns3__RobotMileageInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__RobotMileageInfo(soap, &this->ns3__RobotMileageInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__RobotMileageInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotMileageInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotMileageInfos(struct soap *soap, const char *tag, int id, const ns3__RobotMileageInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotMileageInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__RobotMileageInfo(soap, "Infos", -1, &(a->ns3__RobotMileageInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotMileageInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotMileageInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotMileageInfos * SOAP_FMAC4 soap_in_ns3__RobotMileageInfos(struct soap *soap, const char *tag, ns3__RobotMileageInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotMileageInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotMileageInfos, sizeof(ns3__RobotMileageInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotMileageInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotMileageInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__RobotMileageInfo(soap, "Infos", &(a->ns3__RobotMileageInfos::Infos), "ns3:RobotMileageInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotMileageInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotMileageInfos, 0, sizeof(ns3__RobotMileageInfos), 0, soap_copy_ns3__RobotMileageInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__RobotMileageInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotMileageInfos);
	if (this->soap_out(soap, tag?tag:"ns3:RobotMileageInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotMileageInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotMileageInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotMileageInfos * SOAP_FMAC4 soap_get_ns3__RobotMileageInfos(struct soap *soap, ns3__RobotMileageInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotMileageInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotMileageInfos * SOAP_FMAC2 soap_instantiate_ns3__RobotMileageInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotMileageInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotMileageInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotMileageInfos);
		if (size)
			*size = sizeof(ns3__RobotMileageInfos);
		((ns3__RobotMileageInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotMileageInfos, n);
		if (size)
			*size = n * sizeof(ns3__RobotMileageInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotMileageInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotMileageInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotMileageInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotMileageInfos %p -> %p\n", q, p));
	*(ns3__RobotMileageInfos*)p = *(ns3__RobotMileageInfos*)q;
}

void ns3__RobotMileageInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__RobotMileageInfo::RobotIp);
	soap_default_double(soap, &this->ns3__RobotMileageInfo::Mileage);
	/* transient soap skipped */
}

void ns3__RobotMileageInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__RobotMileageInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns3__RobotMileageInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotMileageInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotMileageInfo(struct soap *soap, const char *tag, int id, const ns3__RobotMileageInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotMileageInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__RobotMileageInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "Mileage", -1, &(a->ns3__RobotMileageInfo::Mileage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotMileageInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotMileageInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotMileageInfo * SOAP_FMAC4 soap_in_ns3__RobotMileageInfo(struct soap *soap, const char *tag, ns3__RobotMileageInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotMileageInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotMileageInfo, sizeof(ns3__RobotMileageInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotMileageInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotMileageInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_Mileage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__RobotMileageInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_Mileage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Mileage", &(a->ns3__RobotMileageInfo::Mileage), "xsd:double"))
				{	soap_flag_Mileage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotMileageInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotMileageInfo, 0, sizeof(ns3__RobotMileageInfo), 0, soap_copy_ns3__RobotMileageInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_Mileage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__RobotMileageInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotMileageInfo);
	if (this->soap_out(soap, tag?tag:"ns3:RobotMileageInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotMileageInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotMileageInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotMileageInfo * SOAP_FMAC4 soap_get_ns3__RobotMileageInfo(struct soap *soap, ns3__RobotMileageInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotMileageInfo * SOAP_FMAC2 soap_instantiate_ns3__RobotMileageInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotMileageInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotMileageInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotMileageInfo);
		if (size)
			*size = sizeof(ns3__RobotMileageInfo);
		((ns3__RobotMileageInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotMileageInfo, n);
		if (size)
			*size = n * sizeof(ns3__RobotMileageInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotMileageInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotMileageInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotMileageInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotMileageInfo %p -> %p\n", q, p));
	*(ns3__RobotMileageInfo*)p = *(ns3__RobotMileageInfo*)q;
}

void ns3__RobotYunTaiInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(soap, &this->ns3__RobotYunTaiInfos::Infos);
	/* transient soap skipped */
}

void ns3__RobotYunTaiInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(soap, &this->ns3__RobotYunTaiInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__RobotYunTaiInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotYunTaiInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotYunTaiInfos(struct soap *soap, const char *tag, int id, const ns3__RobotYunTaiInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(soap, "Infos", -1, &(a->ns3__RobotYunTaiInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotYunTaiInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotYunTaiInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotYunTaiInfos * SOAP_FMAC4 soap_in_ns3__RobotYunTaiInfos(struct soap *soap, const char *tag, ns3__RobotYunTaiInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotYunTaiInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos, sizeof(ns3__RobotYunTaiInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotYunTaiInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(soap, "Infos", &(a->ns3__RobotYunTaiInfos::Infos), "ns3:RobotYunTaiInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotYunTaiInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos, 0, sizeof(ns3__RobotYunTaiInfos), 0, soap_copy_ns3__RobotYunTaiInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__RobotYunTaiInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos);
	if (this->soap_out(soap, tag?tag:"ns3:RobotYunTaiInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotYunTaiInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotYunTaiInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotYunTaiInfos * SOAP_FMAC4 soap_get_ns3__RobotYunTaiInfos(struct soap *soap, ns3__RobotYunTaiInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotYunTaiInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotYunTaiInfos * SOAP_FMAC2 soap_instantiate_ns3__RobotYunTaiInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotYunTaiInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotYunTaiInfos);
		if (size)
			*size = sizeof(ns3__RobotYunTaiInfos);
		((ns3__RobotYunTaiInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotYunTaiInfos, n);
		if (size)
			*size = n * sizeof(ns3__RobotYunTaiInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotYunTaiInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotYunTaiInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotYunTaiInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotYunTaiInfos %p -> %p\n", q, p));
	*(ns3__RobotYunTaiInfos*)p = *(ns3__RobotYunTaiInfos*)q;
}

void ns3__RobotYunTaiInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__RobotYunTaiInfo::RobotIp);
	soap_default_std__string(soap, &this->ns3__RobotYunTaiInfo::PosPan);
	soap_default_std__string(soap, &this->ns3__RobotYunTaiInfo::PosTile);
	/* transient soap skipped */
}

void ns3__RobotYunTaiInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__RobotYunTaiInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns3__RobotYunTaiInfo::PosPan);
	soap_serialize_std__string(soap, &this->ns3__RobotYunTaiInfo::PosTile);
	/* transient soap skipped */
#endif
}

int ns3__RobotYunTaiInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotYunTaiInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, const ns3__RobotYunTaiInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__RobotYunTaiInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosPan", -1, &(a->ns3__RobotYunTaiInfo::PosPan), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosTile", -1, &(a->ns3__RobotYunTaiInfo::PosTile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotYunTaiInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotYunTaiInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotYunTaiInfo * SOAP_FMAC4 soap_in_ns3__RobotYunTaiInfo(struct soap *soap, const char *tag, ns3__RobotYunTaiInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotYunTaiInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo, sizeof(ns3__RobotYunTaiInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotYunTaiInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_PosPan1 = 1;
	size_t soap_flag_PosTile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__RobotYunTaiInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_PosPan1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosPan", &(a->ns3__RobotYunTaiInfo::PosPan), "xsd:string"))
				{	soap_flag_PosPan1--;
					continue;
				}
			if (soap_flag_PosTile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosTile", &(a->ns3__RobotYunTaiInfo::PosTile), "xsd:string"))
				{	soap_flag_PosTile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotYunTaiInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo, 0, sizeof(ns3__RobotYunTaiInfo), 0, soap_copy_ns3__RobotYunTaiInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_PosPan1 > 0 || soap_flag_PosTile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__RobotYunTaiInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo);
	if (this->soap_out(soap, tag?tag:"ns3:RobotYunTaiInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotYunTaiInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotYunTaiInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotYunTaiInfo * SOAP_FMAC4 soap_get_ns3__RobotYunTaiInfo(struct soap *soap, ns3__RobotYunTaiInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotYunTaiInfo * SOAP_FMAC2 soap_instantiate_ns3__RobotYunTaiInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotYunTaiInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotYunTaiInfo);
		if (size)
			*size = sizeof(ns3__RobotYunTaiInfo);
		((ns3__RobotYunTaiInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotYunTaiInfo, n);
		if (size)
			*size = n * sizeof(ns3__RobotYunTaiInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotYunTaiInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotYunTaiInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotYunTaiInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotYunTaiInfo %p -> %p\n", q, p));
	*(ns3__RobotYunTaiInfo*)p = *(ns3__RobotYunTaiInfo*)q;
}

void ns3__RobotPosInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__RobotPosInfo(soap, &this->ns3__RobotPosInfos::Infos);
	/* transient soap skipped */
}

void ns3__RobotPosInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__RobotPosInfo(soap, &this->ns3__RobotPosInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__RobotPosInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotPosInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotPosInfos(struct soap *soap, const char *tag, int id, const ns3__RobotPosInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotPosInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__RobotPosInfo(soap, "Infos", -1, &(a->ns3__RobotPosInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotPosInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotPosInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotPosInfos * SOAP_FMAC4 soap_in_ns3__RobotPosInfos(struct soap *soap, const char *tag, ns3__RobotPosInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotPosInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotPosInfos, sizeof(ns3__RobotPosInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotPosInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotPosInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__RobotPosInfo(soap, "Infos", &(a->ns3__RobotPosInfos::Infos), "ns3:RobotPosInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotPosInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotPosInfos, 0, sizeof(ns3__RobotPosInfos), 0, soap_copy_ns3__RobotPosInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__RobotPosInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotPosInfos);
	if (this->soap_out(soap, tag?tag:"ns3:RobotPosInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotPosInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotPosInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotPosInfos * SOAP_FMAC4 soap_get_ns3__RobotPosInfos(struct soap *soap, ns3__RobotPosInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotPosInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotPosInfos * SOAP_FMAC2 soap_instantiate_ns3__RobotPosInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotPosInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotPosInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotPosInfos);
		if (size)
			*size = sizeof(ns3__RobotPosInfos);
		((ns3__RobotPosInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotPosInfos, n);
		if (size)
			*size = n * sizeof(ns3__RobotPosInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotPosInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotPosInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotPosInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotPosInfos %p -> %p\n", q, p));
	*(ns3__RobotPosInfos*)p = *(ns3__RobotPosInfos*)q;
}

void ns3__RobotPosInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__RobotPosInfo::RobotIp);
	soap_default_std__string(soap, &this->ns3__RobotPosInfo::PosX);
	soap_default_std__string(soap, &this->ns3__RobotPosInfo::PosY);
	soap_default_std__string(soap, &this->ns3__RobotPosInfo::Angle);
	soap_default_std__string(soap, &this->ns3__RobotPosInfo::EdgeID);
	soap_default_std__string(soap, &this->ns3__RobotPosInfo::Precent);
	/* transient soap skipped */
}

void ns3__RobotPosInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__RobotPosInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns3__RobotPosInfo::PosX);
	soap_serialize_std__string(soap, &this->ns3__RobotPosInfo::PosY);
	soap_serialize_std__string(soap, &this->ns3__RobotPosInfo::Angle);
	soap_serialize_std__string(soap, &this->ns3__RobotPosInfo::EdgeID);
	soap_serialize_std__string(soap, &this->ns3__RobotPosInfo::Precent);
	/* transient soap skipped */
#endif
}

int ns3__RobotPosInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotPosInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotPosInfo(struct soap *soap, const char *tag, int id, const ns3__RobotPosInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotPosInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__RobotPosInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosX", -1, &(a->ns3__RobotPosInfo::PosX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosY", -1, &(a->ns3__RobotPosInfo::PosY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Angle", -1, &(a->ns3__RobotPosInfo::Angle), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EdgeID", -1, &(a->ns3__RobotPosInfo::EdgeID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Precent", -1, &(a->ns3__RobotPosInfo::Precent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotPosInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotPosInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotPosInfo * SOAP_FMAC4 soap_in_ns3__RobotPosInfo(struct soap *soap, const char *tag, ns3__RobotPosInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotPosInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotPosInfo, sizeof(ns3__RobotPosInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotPosInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotPosInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_PosX1 = 1;
	size_t soap_flag_PosY1 = 1;
	size_t soap_flag_Angle1 = 1;
	size_t soap_flag_EdgeID1 = 1;
	size_t soap_flag_Precent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__RobotPosInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_PosX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosX", &(a->ns3__RobotPosInfo::PosX), "xsd:string"))
				{	soap_flag_PosX1--;
					continue;
				}
			if (soap_flag_PosY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosY", &(a->ns3__RobotPosInfo::PosY), "xsd:string"))
				{	soap_flag_PosY1--;
					continue;
				}
			if (soap_flag_Angle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Angle", &(a->ns3__RobotPosInfo::Angle), "xsd:string"))
				{	soap_flag_Angle1--;
					continue;
				}
			if (soap_flag_EdgeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EdgeID", &(a->ns3__RobotPosInfo::EdgeID), "xsd:string"))
				{	soap_flag_EdgeID1--;
					continue;
				}
			if (soap_flag_Precent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Precent", &(a->ns3__RobotPosInfo::Precent), "xsd:string"))
				{	soap_flag_Precent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotPosInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotPosInfo, 0, sizeof(ns3__RobotPosInfo), 0, soap_copy_ns3__RobotPosInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_PosX1 > 0 || soap_flag_PosY1 > 0 || soap_flag_Angle1 > 0 || soap_flag_EdgeID1 > 0 || soap_flag_Precent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__RobotPosInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotPosInfo);
	if (this->soap_out(soap, tag?tag:"ns3:RobotPosInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotPosInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotPosInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotPosInfo * SOAP_FMAC4 soap_get_ns3__RobotPosInfo(struct soap *soap, ns3__RobotPosInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotPosInfo * SOAP_FMAC2 soap_instantiate_ns3__RobotPosInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotPosInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotPosInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotPosInfo);
		if (size)
			*size = sizeof(ns3__RobotPosInfo);
		((ns3__RobotPosInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotPosInfo, n);
		if (size)
			*size = n * sizeof(ns3__RobotPosInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotPosInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotPosInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotPosInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotPosInfo %p -> %p\n", q, p));
	*(ns3__RobotPosInfo*)p = *(ns3__RobotPosInfo*)q;
}

void ns3__RobotTaskStates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__RobotTaskState(soap, &this->ns3__RobotTaskStates::States);
	/* transient soap skipped */
}

void ns3__RobotTaskStates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__RobotTaskState(soap, &this->ns3__RobotTaskStates::States);
	/* transient soap skipped */
#endif
}

int ns3__RobotTaskStates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotTaskStates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotTaskStates(struct soap *soap, const char *tag, int id, const ns3__RobotTaskStates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotTaskStates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__RobotTaskState(soap, "States", -1, &(a->ns3__RobotTaskStates::States), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotTaskStates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotTaskStates(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotTaskStates * SOAP_FMAC4 soap_in_ns3__RobotTaskStates(struct soap *soap, const char *tag, ns3__RobotTaskStates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotTaskStates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotTaskStates, sizeof(ns3__RobotTaskStates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotTaskStates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotTaskStates *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__RobotTaskState(soap, "States", &(a->ns3__RobotTaskStates::States), "ns3:RobotTaskState"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotTaskStates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotTaskStates, 0, sizeof(ns3__RobotTaskStates), 0, soap_copy_ns3__RobotTaskStates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__RobotTaskStates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotTaskStates);
	if (this->soap_out(soap, tag?tag:"ns3:RobotTaskStates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotTaskStates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotTaskStates(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotTaskStates * SOAP_FMAC4 soap_get_ns3__RobotTaskStates(struct soap *soap, ns3__RobotTaskStates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotTaskStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotTaskStates * SOAP_FMAC2 soap_instantiate_ns3__RobotTaskStates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotTaskStates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotTaskStates, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotTaskStates);
		if (size)
			*size = sizeof(ns3__RobotTaskStates);
		((ns3__RobotTaskStates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotTaskStates, n);
		if (size)
			*size = n * sizeof(ns3__RobotTaskStates);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotTaskStates*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotTaskStates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotTaskStates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotTaskStates %p -> %p\n", q, p));
	*(ns3__RobotTaskStates*)p = *(ns3__RobotTaskStates*)q;
}

void ns3__RobotTaskState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__RobotTaskState::RobotIp);
	soap_default_std__string(soap, &this->ns3__RobotTaskState::TaskId);
	soap_default_std__string(soap, &this->ns3__RobotTaskState::TaskType);
	soap_default_std__string(soap, &this->ns3__RobotTaskState::TaskDesc);
	/* transient soap skipped */
}

void ns3__RobotTaskState::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__RobotTaskState::RobotIp);
	soap_serialize_std__string(soap, &this->ns3__RobotTaskState::TaskId);
	soap_serialize_std__string(soap, &this->ns3__RobotTaskState::TaskType);
	soap_serialize_std__string(soap, &this->ns3__RobotTaskState::TaskDesc);
	/* transient soap skipped */
#endif
}

int ns3__RobotTaskState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotTaskState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotTaskState(struct soap *soap, const char *tag, int id, const ns3__RobotTaskState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotTaskState), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__RobotTaskState::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns3__RobotTaskState::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns3__RobotTaskState::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskDesc", -1, &(a->ns3__RobotTaskState::TaskDesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotTaskState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotTaskState(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotTaskState * SOAP_FMAC4 soap_in_ns3__RobotTaskState(struct soap *soap, const char *tag, ns3__RobotTaskState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotTaskState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotTaskState, sizeof(ns3__RobotTaskState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotTaskState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotTaskState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskDesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__RobotTaskState::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns3__RobotTaskState::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns3__RobotTaskState::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskDesc", &(a->ns3__RobotTaskState::TaskDesc), "xsd:string"))
				{	soap_flag_TaskDesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotTaskState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotTaskState, 0, sizeof(ns3__RobotTaskState), 0, soap_copy_ns3__RobotTaskState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_TaskId1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskDesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__RobotTaskState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotTaskState);
	if (this->soap_out(soap, tag?tag:"ns3:RobotTaskState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotTaskState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotTaskState(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotTaskState * SOAP_FMAC4 soap_get_ns3__RobotTaskState(struct soap *soap, ns3__RobotTaskState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotTaskState * SOAP_FMAC2 soap_instantiate_ns3__RobotTaskState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotTaskState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotTaskState, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotTaskState);
		if (size)
			*size = sizeof(ns3__RobotTaskState);
		((ns3__RobotTaskState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotTaskState, n);
		if (size)
			*size = n * sizeof(ns3__RobotTaskState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotTaskState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotTaskState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotTaskState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotTaskState %p -> %p\n", q, p));
	*(ns3__RobotTaskState*)p = *(ns3__RobotTaskState*)q;
}

void ns3__SpeedInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__SpeedInfo(soap, &this->ns3__SpeedInfos::Infos);
	/* transient soap skipped */
}

void ns3__SpeedInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__SpeedInfo(soap, &this->ns3__SpeedInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__SpeedInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__SpeedInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SpeedInfos(struct soap *soap, const char *tag, int id, const ns3__SpeedInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__SpeedInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__SpeedInfo(soap, "Infos", -1, &(a->ns3__SpeedInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__SpeedInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__SpeedInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__SpeedInfos * SOAP_FMAC4 soap_in_ns3__SpeedInfos(struct soap *soap, const char *tag, ns3__SpeedInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__SpeedInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__SpeedInfos, sizeof(ns3__SpeedInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__SpeedInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__SpeedInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__SpeedInfo(soap, "Infos", &(a->ns3__SpeedInfos::Infos), "ns3:SpeedInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__SpeedInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__SpeedInfos, 0, sizeof(ns3__SpeedInfos), 0, soap_copy_ns3__SpeedInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__SpeedInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__SpeedInfos);
	if (this->soap_out(soap, tag?tag:"ns3:SpeedInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__SpeedInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__SpeedInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__SpeedInfos * SOAP_FMAC4 soap_get_ns3__SpeedInfos(struct soap *soap, ns3__SpeedInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__SpeedInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__SpeedInfos * SOAP_FMAC2 soap_instantiate_ns3__SpeedInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__SpeedInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__SpeedInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__SpeedInfos);
		if (size)
			*size = sizeof(ns3__SpeedInfos);
		((ns3__SpeedInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__SpeedInfos, n);
		if (size)
			*size = n * sizeof(ns3__SpeedInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__SpeedInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__SpeedInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__SpeedInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__SpeedInfos %p -> %p\n", q, p));
	*(ns3__SpeedInfos*)p = *(ns3__SpeedInfos*)q;
}

void ns3__SpeedInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__SpeedInfo::RobotIp);
	soap_default_double(soap, &this->ns3__SpeedInfo::Speed);
	/* transient soap skipped */
}

void ns3__SpeedInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__SpeedInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns3__SpeedInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__SpeedInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SpeedInfo(struct soap *soap, const char *tag, int id, const ns3__SpeedInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__SpeedInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__SpeedInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "Speed", -1, &(a->ns3__SpeedInfo::Speed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__SpeedInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__SpeedInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__SpeedInfo * SOAP_FMAC4 soap_in_ns3__SpeedInfo(struct soap *soap, const char *tag, ns3__SpeedInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__SpeedInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__SpeedInfo, sizeof(ns3__SpeedInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__SpeedInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__SpeedInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__SpeedInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Speed", &(a->ns3__SpeedInfo::Speed), "xsd:double"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__SpeedInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__SpeedInfo, 0, sizeof(ns3__SpeedInfo), 0, soap_copy_ns3__SpeedInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_Speed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__SpeedInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__SpeedInfo);
	if (this->soap_out(soap, tag?tag:"ns3:SpeedInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__SpeedInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__SpeedInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__SpeedInfo * SOAP_FMAC4 soap_get_ns3__SpeedInfo(struct soap *soap, ns3__SpeedInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__SpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__SpeedInfo * SOAP_FMAC2 soap_instantiate_ns3__SpeedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__SpeedInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__SpeedInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__SpeedInfo);
		if (size)
			*size = sizeof(ns3__SpeedInfo);
		((ns3__SpeedInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__SpeedInfo, n);
		if (size)
			*size = n * sizeof(ns3__SpeedInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__SpeedInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__SpeedInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__SpeedInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__SpeedInfo %p -> %p\n", q, p));
	*(ns3__SpeedInfo*)p = *(ns3__SpeedInfo*)q;
}

void ns3__BatteryInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__BatteryInfo(soap, &this->ns3__BatteryInfos::Infos);
	/* transient soap skipped */
}

void ns3__BatteryInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__BatteryInfo(soap, &this->ns3__BatteryInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__BatteryInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__BatteryInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__BatteryInfos(struct soap *soap, const char *tag, int id, const ns3__BatteryInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__BatteryInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__BatteryInfo(soap, "Infos", -1, &(a->ns3__BatteryInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__BatteryInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__BatteryInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__BatteryInfos * SOAP_FMAC4 soap_in_ns3__BatteryInfos(struct soap *soap, const char *tag, ns3__BatteryInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__BatteryInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__BatteryInfos, sizeof(ns3__BatteryInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__BatteryInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__BatteryInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__BatteryInfo(soap, "Infos", &(a->ns3__BatteryInfos::Infos), "ns3:BatteryInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__BatteryInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__BatteryInfos, 0, sizeof(ns3__BatteryInfos), 0, soap_copy_ns3__BatteryInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__BatteryInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__BatteryInfos);
	if (this->soap_out(soap, tag?tag:"ns3:BatteryInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__BatteryInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__BatteryInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__BatteryInfos * SOAP_FMAC4 soap_get_ns3__BatteryInfos(struct soap *soap, ns3__BatteryInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__BatteryInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__BatteryInfos * SOAP_FMAC2 soap_instantiate_ns3__BatteryInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__BatteryInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__BatteryInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__BatteryInfos);
		if (size)
			*size = sizeof(ns3__BatteryInfos);
		((ns3__BatteryInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__BatteryInfos, n);
		if (size)
			*size = n * sizeof(ns3__BatteryInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__BatteryInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__BatteryInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__BatteryInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__BatteryInfos %p -> %p\n", q, p));
	*(ns3__BatteryInfos*)p = *(ns3__BatteryInfos*)q;
}

void ns3__BatteryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__BatteryInfo::RobotIp);
	soap_default_double(soap, &this->ns3__BatteryInfo::BatteryValue);
	soap_default_double(soap, &this->ns3__BatteryInfo::BatteryPercent);
	/* transient soap skipped */
}

void ns3__BatteryInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__BatteryInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns3__BatteryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__BatteryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__BatteryInfo(struct soap *soap, const char *tag, int id, const ns3__BatteryInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__BatteryInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__BatteryInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "BatteryValue", -1, &(a->ns3__BatteryInfo::BatteryValue), ""))
		return soap->error;
	if (soap_out_double(soap, "BatteryPercent", -1, &(a->ns3__BatteryInfo::BatteryPercent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__BatteryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__BatteryInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__BatteryInfo * SOAP_FMAC4 soap_in_ns3__BatteryInfo(struct soap *soap, const char *tag, ns3__BatteryInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__BatteryInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__BatteryInfo, sizeof(ns3__BatteryInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__BatteryInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__BatteryInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_BatteryValue1 = 1;
	size_t soap_flag_BatteryPercent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__BatteryInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_BatteryValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BatteryValue", &(a->ns3__BatteryInfo::BatteryValue), "xsd:double"))
				{	soap_flag_BatteryValue1--;
					continue;
				}
			if (soap_flag_BatteryPercent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BatteryPercent", &(a->ns3__BatteryInfo::BatteryPercent), "xsd:double"))
				{	soap_flag_BatteryPercent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__BatteryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__BatteryInfo, 0, sizeof(ns3__BatteryInfo), 0, soap_copy_ns3__BatteryInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_BatteryValue1 > 0 || soap_flag_BatteryPercent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__BatteryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__BatteryInfo);
	if (this->soap_out(soap, tag?tag:"ns3:BatteryInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__BatteryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__BatteryInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__BatteryInfo * SOAP_FMAC4 soap_get_ns3__BatteryInfo(struct soap *soap, ns3__BatteryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__BatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__BatteryInfo * SOAP_FMAC2 soap_instantiate_ns3__BatteryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__BatteryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__BatteryInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__BatteryInfo);
		if (size)
			*size = sizeof(ns3__BatteryInfo);
		((ns3__BatteryInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__BatteryInfo, n);
		if (size)
			*size = n * sizeof(ns3__BatteryInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__BatteryInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__BatteryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__BatteryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__BatteryInfo %p -> %p\n", q, p));
	*(ns3__BatteryInfo*)p = *(ns3__BatteryInfo*)q;
}

void ns3__RobotInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__RobotInfo(soap, &this->ns3__RobotInfos::Infos);
	/* transient soap skipped */
}

void ns3__RobotInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__RobotInfo(soap, &this->ns3__RobotInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__RobotInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotInfos(struct soap *soap, const char *tag, int id, const ns3__RobotInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__RobotInfo(soap, "Infos", -1, &(a->ns3__RobotInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotInfos * SOAP_FMAC4 soap_in_ns3__RobotInfos(struct soap *soap, const char *tag, ns3__RobotInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotInfos, sizeof(ns3__RobotInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__RobotInfo(soap, "Infos", &(a->ns3__RobotInfos::Infos), "ns3:RobotInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotInfos, 0, sizeof(ns3__RobotInfos), 0, soap_copy_ns3__RobotInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__RobotInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotInfos);
	if (this->soap_out(soap, tag?tag:"ns3:RobotInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotInfos * SOAP_FMAC4 soap_get_ns3__RobotInfos(struct soap *soap, ns3__RobotInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotInfos * SOAP_FMAC2 soap_instantiate_ns3__RobotInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotInfos);
		if (size)
			*size = sizeof(ns3__RobotInfos);
		((ns3__RobotInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotInfos, n);
		if (size)
			*size = n * sizeof(ns3__RobotInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotInfos %p -> %p\n", q, p));
	*(ns3__RobotInfos*)p = *(ns3__RobotInfos*)q;
}

void ns3__RobotInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__RobotInfo::RobotName);
	soap_default_std__string(soap, &this->ns3__RobotInfo::RobotIp);
	soap_default_std__string(soap, &this->ns3__RobotInfo::CameraIp);
	soap_default_int(soap, &this->ns3__RobotInfo::CameraPort);
	soap_default_std__string(soap, &this->ns3__RobotInfo::FlirIp);
	soap_default_int(soap, &this->ns3__RobotInfo::FlirPort);
	soap_default_std__string(soap, &this->ns3__RobotInfo::CameraUser);
	soap_default_std__string(soap, &this->ns3__RobotInfo::CameraPassword);
	soap_default_std__string(soap, &this->ns3__RobotInfo::FlirUser);
	soap_default_std__string(soap, &this->ns3__RobotInfo::FlirPassword);
	/* transient soap skipped */
}

void ns3__RobotInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__RobotInfo::RobotName);
	soap_serialize_std__string(soap, &this->ns3__RobotInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns3__RobotInfo::CameraIp);
	soap_serialize_std__string(soap, &this->ns3__RobotInfo::FlirIp);
	soap_serialize_std__string(soap, &this->ns3__RobotInfo::CameraUser);
	soap_serialize_std__string(soap, &this->ns3__RobotInfo::CameraPassword);
	soap_serialize_std__string(soap, &this->ns3__RobotInfo::FlirUser);
	soap_serialize_std__string(soap, &this->ns3__RobotInfo::FlirPassword);
	/* transient soap skipped */
#endif
}

int ns3__RobotInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RobotInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RobotInfo(struct soap *soap, const char *tag, int id, const ns3__RobotInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__RobotInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotName", -1, &(a->ns3__RobotInfo::RobotName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__RobotInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraIp", -1, &(a->ns3__RobotInfo::CameraIp), ""))
		return soap->error;
	if (soap_out_int(soap, "CameraPort", -1, &(a->ns3__RobotInfo::CameraPort), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirIp", -1, &(a->ns3__RobotInfo::FlirIp), ""))
		return soap->error;
	if (soap_out_int(soap, "FlirPort", -1, &(a->ns3__RobotInfo::FlirPort), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraUser", -1, &(a->ns3__RobotInfo::CameraUser), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraPassword", -1, &(a->ns3__RobotInfo::CameraPassword), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirUser", -1, &(a->ns3__RobotInfo::FlirUser), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirPassword", -1, &(a->ns3__RobotInfo::FlirPassword), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__RobotInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RobotInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RobotInfo * SOAP_FMAC4 soap_in_ns3__RobotInfo(struct soap *soap, const char *tag, ns3__RobotInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RobotInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__RobotInfo, sizeof(ns3__RobotInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__RobotInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RobotInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotName1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_CameraIp1 = 1;
	size_t soap_flag_CameraPort1 = 1;
	size_t soap_flag_FlirIp1 = 1;
	size_t soap_flag_FlirPort1 = 1;
	size_t soap_flag_CameraUser1 = 1;
	size_t soap_flag_CameraPassword1 = 1;
	size_t soap_flag_FlirUser1 = 1;
	size_t soap_flag_FlirPassword1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotName", &(a->ns3__RobotInfo::RobotName), "xsd:string"))
				{	soap_flag_RobotName1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__RobotInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_CameraIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraIp", &(a->ns3__RobotInfo::CameraIp), "xsd:string"))
				{	soap_flag_CameraIp1--;
					continue;
				}
			if (soap_flag_CameraPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CameraPort", &(a->ns3__RobotInfo::CameraPort), "xsd:int"))
				{	soap_flag_CameraPort1--;
					continue;
				}
			if (soap_flag_FlirIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirIp", &(a->ns3__RobotInfo::FlirIp), "xsd:string"))
				{	soap_flag_FlirIp1--;
					continue;
				}
			if (soap_flag_FlirPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FlirPort", &(a->ns3__RobotInfo::FlirPort), "xsd:int"))
				{	soap_flag_FlirPort1--;
					continue;
				}
			if (soap_flag_CameraUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraUser", &(a->ns3__RobotInfo::CameraUser), "xsd:string"))
				{	soap_flag_CameraUser1--;
					continue;
				}
			if (soap_flag_CameraPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraPassword", &(a->ns3__RobotInfo::CameraPassword), "xsd:string"))
				{	soap_flag_CameraPassword1--;
					continue;
				}
			if (soap_flag_FlirUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirUser", &(a->ns3__RobotInfo::FlirUser), "xsd:string"))
				{	soap_flag_FlirUser1--;
					continue;
				}
			if (soap_flag_FlirPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirPassword", &(a->ns3__RobotInfo::FlirPassword), "xsd:string"))
				{	soap_flag_FlirPassword1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RobotInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__RobotInfo, 0, sizeof(ns3__RobotInfo), 0, soap_copy_ns3__RobotInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotName1 > 0 || soap_flag_RobotIp1 > 0 || soap_flag_CameraIp1 > 0 || soap_flag_CameraPort1 > 0 || soap_flag_FlirIp1 > 0 || soap_flag_FlirPort1 > 0 || soap_flag_CameraUser1 > 0 || soap_flag_CameraPassword1 > 0 || soap_flag_FlirUser1 > 0 || soap_flag_FlirPassword1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__RobotInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__RobotInfo);
	if (this->soap_out(soap, tag?tag:"ns3:RobotInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__RobotInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RobotInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RobotInfo * SOAP_FMAC4 soap_get_ns3__RobotInfo(struct soap *soap, ns3__RobotInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__RobotInfo * SOAP_FMAC2 soap_instantiate_ns3__RobotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RobotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__RobotInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__RobotInfo);
		if (size)
			*size = sizeof(ns3__RobotInfo);
		((ns3__RobotInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__RobotInfo, n);
		if (size)
			*size = n * sizeof(ns3__RobotInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__RobotInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__RobotInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RobotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RobotInfo %p -> %p\n", q, p));
	*(ns3__RobotInfo*)p = *(ns3__RobotInfo*)q;
}

void ns3__ConnectInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__ConnectInfo(soap, &this->ns3__ConnectInfos::Infos);
	/* transient soap skipped */
}

void ns3__ConnectInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__ConnectInfo(soap, &this->ns3__ConnectInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns3__ConnectInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ConnectInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ConnectInfos(struct soap *soap, const char *tag, int id, const ns3__ConnectInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__ConnectInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__ConnectInfo(soap, "Infos", -1, &(a->ns3__ConnectInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ConnectInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ConnectInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ConnectInfos * SOAP_FMAC4 soap_in_ns3__ConnectInfos(struct soap *soap, const char *tag, ns3__ConnectInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ConnectInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__ConnectInfos, sizeof(ns3__ConnectInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__ConnectInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ConnectInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__ConnectInfo(soap, "Infos", &(a->ns3__ConnectInfos::Infos), "ns3:ConnectInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ConnectInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__ConnectInfos, 0, sizeof(ns3__ConnectInfos), 0, soap_copy_ns3__ConnectInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__ConnectInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__ConnectInfos);
	if (this->soap_out(soap, tag?tag:"ns3:ConnectInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ConnectInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ConnectInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ConnectInfos * SOAP_FMAC4 soap_get_ns3__ConnectInfos(struct soap *soap, ns3__ConnectInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ConnectInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__ConnectInfos * SOAP_FMAC2 soap_instantiate_ns3__ConnectInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ConnectInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__ConnectInfos, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__ConnectInfos);
		if (size)
			*size = sizeof(ns3__ConnectInfos);
		((ns3__ConnectInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__ConnectInfos, n);
		if (size)
			*size = n * sizeof(ns3__ConnectInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__ConnectInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__ConnectInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ConnectInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ConnectInfos %p -> %p\n", q, p));
	*(ns3__ConnectInfos*)p = *(ns3__ConnectInfos*)q;
}

void ns3__ConnectInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__ConnectInfo::RobotIp);
	soap_default_bool(soap, &this->ns3__ConnectInfo::State);
	soap_default_std__string(soap, &this->ns3__ConnectInfo::ConnectDesc);
	/* transient soap skipped */
}

void ns3__ConnectInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns3__ConnectInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns3__ConnectInfo::ConnectDesc);
	/* transient soap skipped */
#endif
}

int ns3__ConnectInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ConnectInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ConnectInfo(struct soap *soap, const char *tag, int id, const ns3__ConnectInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_ns3__ConnectInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns3__ConnectInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_bool(soap, "State", -1, &(a->ns3__ConnectInfo::State), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ConnectDesc", -1, &(a->ns3__ConnectInfo::ConnectDesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ConnectInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ConnectInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ConnectInfo * SOAP_FMAC4 soap_in_ns3__ConnectInfo(struct soap *soap, const char *tag, ns3__ConnectInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ConnectInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_ns3__ConnectInfo, sizeof(ns3__ConnectInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_RobotData_ns3__ConnectInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ConnectInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_State1 = 1;
	size_t soap_flag_ConnectDesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns3__ConnectInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "State", &(a->ns3__ConnectInfo::State), "xsd:boolean"))
				{	soap_flag_State1--;
					continue;
				}
			if (soap_flag_ConnectDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ConnectDesc", &(a->ns3__ConnectInfo::ConnectDesc), "xsd:string"))
				{	soap_flag_ConnectDesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ConnectInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_ns3__ConnectInfo, 0, sizeof(ns3__ConnectInfo), 0, soap_copy_ns3__ConnectInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_State1 > 0 || soap_flag_ConnectDesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__ConnectInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_RobotData_ns3__ConnectInfo);
	if (this->soap_out(soap, tag?tag:"ns3:ConnectInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ConnectInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ConnectInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ConnectInfo * SOAP_FMAC4 soap_get_ns3__ConnectInfo(struct soap *soap, ns3__ConnectInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ConnectInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__ConnectInfo * SOAP_FMAC2 soap_instantiate_ns3__ConnectInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ConnectInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_ns3__ConnectInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__ConnectInfo);
		if (size)
			*size = sizeof(ns3__ConnectInfo);
		((ns3__ConnectInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__ConnectInfo, n);
		if (size)
			*size = n * sizeof(ns3__ConnectInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__ConnectInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__ConnectInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ConnectInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ConnectInfo %p -> %p\n", q, p));
	*(ns3__ConnectInfo*)p = *(ns3__ConnectInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_SOAP_ENV__Fault, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_SOAP_ENV__Reason, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_SOAP_ENV__Detail, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_SOAP_ENV__Code, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RobotData_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RobotData_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RobotData_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_SOAP_ENV__Header, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotAlarmInfo(struct soap *soap, struct __ns1__GetRobotAlarmInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotAlarmInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotAlarmInfo(struct soap *soap, const struct __ns1__GetRobotAlarmInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotAlarmInfo(soap, &a->ns3__GetRobotAlarmInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotAlarmInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotAlarmInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotAlarmInfo(soap, "ns3:GetRobotAlarmInfo", -1, &a->ns3__GetRobotAlarmInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotAlarmInfo * SOAP_FMAC4 soap_in___ns1__GetRobotAlarmInfo(struct soap *soap, const char *tag, struct __ns1__GetRobotAlarmInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotAlarmInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotAlarmInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotAlarmInfo, sizeof(struct __ns1__GetRobotAlarmInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotAlarmInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotAlarmInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotAlarmInfo(soap, "ns3:GetRobotAlarmInfo", &a->ns3__GetRobotAlarmInfo, ""))
				{	soap_flag_ns3__GetRobotAlarmInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotAlarmInfo(struct soap *soap, const struct __ns1__GetRobotAlarmInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotAlarmInfo(soap, tag?tag:"-ns1:GetRobotAlarmInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotAlarmInfo * SOAP_FMAC4 soap_get___ns1__GetRobotAlarmInfo(struct soap *soap, struct __ns1__GetRobotAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotAlarmInfo * SOAP_FMAC2 soap_instantiate___ns1__GetRobotAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotAlarmInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotAlarmInfo);
		if (size)
			*size = sizeof(struct __ns1__GetRobotAlarmInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotAlarmInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotAlarmInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotAlarmInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotAlarmInfo %p -> %p\n", q, p));
	*(struct __ns1__GetRobotAlarmInfo*)p = *(struct __ns1__GetRobotAlarmInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotGasInfo(struct soap *soap, struct __ns1__GetRobotGasInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotGasInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotGasInfo(struct soap *soap, const struct __ns1__GetRobotGasInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotGasInfo(soap, &a->ns3__GetRobotGasInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotGasInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotGasInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotGasInfo(soap, "ns3:GetRobotGasInfo", -1, &a->ns3__GetRobotGasInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotGasInfo * SOAP_FMAC4 soap_in___ns1__GetRobotGasInfo(struct soap *soap, const char *tag, struct __ns1__GetRobotGasInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotGasInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotGasInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotGasInfo, sizeof(struct __ns1__GetRobotGasInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotGasInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotGasInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotGasInfo(soap, "ns3:GetRobotGasInfo", &a->ns3__GetRobotGasInfo, ""))
				{	soap_flag_ns3__GetRobotGasInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotGasInfo(struct soap *soap, const struct __ns1__GetRobotGasInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotGasInfo(soap, tag?tag:"-ns1:GetRobotGasInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotGasInfo * SOAP_FMAC4 soap_get___ns1__GetRobotGasInfo(struct soap *soap, struct __ns1__GetRobotGasInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotGasInfo * SOAP_FMAC2 soap_instantiate___ns1__GetRobotGasInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotGasInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotGasInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotGasInfo);
		if (size)
			*size = sizeof(struct __ns1__GetRobotGasInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotGasInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotGasInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotGasInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotGasInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotGasInfo %p -> %p\n", q, p));
	*(struct __ns1__GetRobotGasInfo*)p = *(struct __ns1__GetRobotGasInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotMileageInfo(struct soap *soap, struct __ns1__GetRobotMileageInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotMileageInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotMileageInfo(struct soap *soap, const struct __ns1__GetRobotMileageInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotMileageInfo(soap, &a->ns3__GetRobotMileageInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotMileageInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotMileageInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotMileageInfo(soap, "ns3:GetRobotMileageInfo", -1, &a->ns3__GetRobotMileageInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotMileageInfo * SOAP_FMAC4 soap_in___ns1__GetRobotMileageInfo(struct soap *soap, const char *tag, struct __ns1__GetRobotMileageInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotMileageInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotMileageInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotMileageInfo, sizeof(struct __ns1__GetRobotMileageInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotMileageInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotMileageInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotMileageInfo(soap, "ns3:GetRobotMileageInfo", &a->ns3__GetRobotMileageInfo, ""))
				{	soap_flag_ns3__GetRobotMileageInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotMileageInfo(struct soap *soap, const struct __ns1__GetRobotMileageInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotMileageInfo(soap, tag?tag:"-ns1:GetRobotMileageInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotMileageInfo * SOAP_FMAC4 soap_get___ns1__GetRobotMileageInfo(struct soap *soap, struct __ns1__GetRobotMileageInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotMileageInfo * SOAP_FMAC2 soap_instantiate___ns1__GetRobotMileageInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotMileageInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotMileageInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotMileageInfo);
		if (size)
			*size = sizeof(struct __ns1__GetRobotMileageInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotMileageInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotMileageInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotMileageInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotMileageInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotMileageInfo %p -> %p\n", q, p));
	*(struct __ns1__GetRobotMileageInfo*)p = *(struct __ns1__GetRobotMileageInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotYunTaiInfo(struct soap *soap, struct __ns1__GetRobotYunTaiInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotYunTaiInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotYunTaiInfo(struct soap *soap, const struct __ns1__GetRobotYunTaiInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotYunTaiInfo(soap, &a->ns3__GetRobotYunTaiInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotYunTaiInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotYunTaiInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotYunTaiInfo(soap, "ns3:GetRobotYunTaiInfo", -1, &a->ns3__GetRobotYunTaiInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotYunTaiInfo * SOAP_FMAC4 soap_in___ns1__GetRobotYunTaiInfo(struct soap *soap, const char *tag, struct __ns1__GetRobotYunTaiInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotYunTaiInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotYunTaiInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotYunTaiInfo, sizeof(struct __ns1__GetRobotYunTaiInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotYunTaiInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotYunTaiInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotYunTaiInfo(soap, "ns3:GetRobotYunTaiInfo", &a->ns3__GetRobotYunTaiInfo, ""))
				{	soap_flag_ns3__GetRobotYunTaiInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotYunTaiInfo(struct soap *soap, const struct __ns1__GetRobotYunTaiInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotYunTaiInfo(soap, tag?tag:"-ns1:GetRobotYunTaiInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotYunTaiInfo * SOAP_FMAC4 soap_get___ns1__GetRobotYunTaiInfo(struct soap *soap, struct __ns1__GetRobotYunTaiInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotYunTaiInfo * SOAP_FMAC2 soap_instantiate___ns1__GetRobotYunTaiInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotYunTaiInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotYunTaiInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotYunTaiInfo);
		if (size)
			*size = sizeof(struct __ns1__GetRobotYunTaiInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotYunTaiInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotYunTaiInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotYunTaiInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotYunTaiInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotYunTaiInfo %p -> %p\n", q, p));
	*(struct __ns1__GetRobotYunTaiInfo*)p = *(struct __ns1__GetRobotYunTaiInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotPosInfo(struct soap *soap, struct __ns1__GetRobotPosInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotPosInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotPosInfo(struct soap *soap, const struct __ns1__GetRobotPosInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotPosInfo(soap, &a->ns3__GetRobotPosInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotPosInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotPosInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotPosInfo(soap, "ns3:GetRobotPosInfo", -1, &a->ns3__GetRobotPosInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotPosInfo * SOAP_FMAC4 soap_in___ns1__GetRobotPosInfo(struct soap *soap, const char *tag, struct __ns1__GetRobotPosInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotPosInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotPosInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotPosInfo, sizeof(struct __ns1__GetRobotPosInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotPosInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotPosInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotPosInfo(soap, "ns3:GetRobotPosInfo", &a->ns3__GetRobotPosInfo, ""))
				{	soap_flag_ns3__GetRobotPosInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotPosInfo(struct soap *soap, const struct __ns1__GetRobotPosInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotPosInfo(soap, tag?tag:"-ns1:GetRobotPosInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotPosInfo * SOAP_FMAC4 soap_get___ns1__GetRobotPosInfo(struct soap *soap, struct __ns1__GetRobotPosInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotPosInfo * SOAP_FMAC2 soap_instantiate___ns1__GetRobotPosInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotPosInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotPosInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotPosInfo);
		if (size)
			*size = sizeof(struct __ns1__GetRobotPosInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotPosInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotPosInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotPosInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotPosInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotPosInfo %p -> %p\n", q, p));
	*(struct __ns1__GetRobotPosInfo*)p = *(struct __ns1__GetRobotPosInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotTaskState(struct soap *soap, struct __ns1__GetRobotTaskState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotTaskState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotTaskState(struct soap *soap, const struct __ns1__GetRobotTaskState *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotTaskState(soap, &a->ns3__GetRobotTaskState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotTaskState(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotTaskState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotTaskState(soap, "ns3:GetRobotTaskState", -1, &a->ns3__GetRobotTaskState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotTaskState * SOAP_FMAC4 soap_in___ns1__GetRobotTaskState(struct soap *soap, const char *tag, struct __ns1__GetRobotTaskState *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotTaskState = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotTaskState *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotTaskState, sizeof(struct __ns1__GetRobotTaskState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotTaskState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotTaskState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotTaskState(soap, "ns3:GetRobotTaskState", &a->ns3__GetRobotTaskState, ""))
				{	soap_flag_ns3__GetRobotTaskState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotTaskState(struct soap *soap, const struct __ns1__GetRobotTaskState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotTaskState(soap, tag?tag:"-ns1:GetRobotTaskState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotTaskState * SOAP_FMAC4 soap_get___ns1__GetRobotTaskState(struct soap *soap, struct __ns1__GetRobotTaskState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotTaskState * SOAP_FMAC2 soap_instantiate___ns1__GetRobotTaskState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotTaskState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotTaskState, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotTaskState);
		if (size)
			*size = sizeof(struct __ns1__GetRobotTaskState);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotTaskState, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotTaskState);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotTaskState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotTaskState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotTaskState %p -> %p\n", q, p));
	*(struct __ns1__GetRobotTaskState*)p = *(struct __ns1__GetRobotTaskState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotSpeedInfo(struct soap *soap, struct __ns1__GetRobotSpeedInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotSpeedInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotSpeedInfo(struct soap *soap, const struct __ns1__GetRobotSpeedInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotSpeedInfo(soap, &a->ns3__GetRobotSpeedInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotSpeedInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotSpeedInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotSpeedInfo(soap, "ns3:GetRobotSpeedInfo", -1, &a->ns3__GetRobotSpeedInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotSpeedInfo * SOAP_FMAC4 soap_in___ns1__GetRobotSpeedInfo(struct soap *soap, const char *tag, struct __ns1__GetRobotSpeedInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotSpeedInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotSpeedInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotSpeedInfo, sizeof(struct __ns1__GetRobotSpeedInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotSpeedInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotSpeedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotSpeedInfo(soap, "ns3:GetRobotSpeedInfo", &a->ns3__GetRobotSpeedInfo, ""))
				{	soap_flag_ns3__GetRobotSpeedInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotSpeedInfo(struct soap *soap, const struct __ns1__GetRobotSpeedInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotSpeedInfo(soap, tag?tag:"-ns1:GetRobotSpeedInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotSpeedInfo * SOAP_FMAC4 soap_get___ns1__GetRobotSpeedInfo(struct soap *soap, struct __ns1__GetRobotSpeedInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotSpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotSpeedInfo * SOAP_FMAC2 soap_instantiate___ns1__GetRobotSpeedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotSpeedInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotSpeedInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotSpeedInfo);
		if (size)
			*size = sizeof(struct __ns1__GetRobotSpeedInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotSpeedInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotSpeedInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotSpeedInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotSpeedInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotSpeedInfo %p -> %p\n", q, p));
	*(struct __ns1__GetRobotSpeedInfo*)p = *(struct __ns1__GetRobotSpeedInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotBatteryInfo(struct soap *soap, struct __ns1__GetRobotBatteryInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotBatteryInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotBatteryInfo(struct soap *soap, const struct __ns1__GetRobotBatteryInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotBatteryInfo(soap, &a->ns3__GetRobotBatteryInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotBatteryInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotBatteryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotBatteryInfo(soap, "ns3:GetRobotBatteryInfo", -1, &a->ns3__GetRobotBatteryInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotBatteryInfo * SOAP_FMAC4 soap_in___ns1__GetRobotBatteryInfo(struct soap *soap, const char *tag, struct __ns1__GetRobotBatteryInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotBatteryInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotBatteryInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotBatteryInfo, sizeof(struct __ns1__GetRobotBatteryInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotBatteryInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotBatteryInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotBatteryInfo(soap, "ns3:GetRobotBatteryInfo", &a->ns3__GetRobotBatteryInfo, ""))
				{	soap_flag_ns3__GetRobotBatteryInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotBatteryInfo(struct soap *soap, const struct __ns1__GetRobotBatteryInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotBatteryInfo(soap, tag?tag:"-ns1:GetRobotBatteryInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotBatteryInfo * SOAP_FMAC4 soap_get___ns1__GetRobotBatteryInfo(struct soap *soap, struct __ns1__GetRobotBatteryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotBatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotBatteryInfo * SOAP_FMAC2 soap_instantiate___ns1__GetRobotBatteryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotBatteryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotBatteryInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotBatteryInfo);
		if (size)
			*size = sizeof(struct __ns1__GetRobotBatteryInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotBatteryInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotBatteryInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotBatteryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotBatteryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotBatteryInfo %p -> %p\n", q, p));
	*(struct __ns1__GetRobotBatteryInfo*)p = *(struct __ns1__GetRobotBatteryInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotPdControl(struct soap *soap, struct __ns1__RobotPdControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RobotPdControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotPdControl(struct soap *soap, const struct __ns1__RobotPdControl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RobotPdControl(soap, &a->ns3__RobotPdControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotPdControl(struct soap *soap, const char *tag, int id, const struct __ns1__RobotPdControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__RobotPdControl(soap, "ns3:RobotPdControl", -1, &a->ns3__RobotPdControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotPdControl * SOAP_FMAC4 soap_in___ns1__RobotPdControl(struct soap *soap, const char *tag, struct __ns1__RobotPdControl *a, const char *type)
{
	size_t soap_flag_ns3__RobotPdControl = 1;
	short soap_flag;
	a = (struct __ns1__RobotPdControl *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__RobotPdControl, sizeof(struct __ns1__RobotPdControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotPdControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RobotPdControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RobotPdControl(soap, "ns3:RobotPdControl", &a->ns3__RobotPdControl, ""))
				{	soap_flag_ns3__RobotPdControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotPdControl(struct soap *soap, const struct __ns1__RobotPdControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotPdControl(soap, tag?tag:"-ns1:RobotPdControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotPdControl * SOAP_FMAC4 soap_get___ns1__RobotPdControl(struct soap *soap, struct __ns1__RobotPdControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotPdControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotPdControl * SOAP_FMAC2 soap_instantiate___ns1__RobotPdControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotPdControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__RobotPdControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotPdControl);
		if (size)
			*size = sizeof(struct __ns1__RobotPdControl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotPdControl, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotPdControl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotPdControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotPdControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotPdControl %p -> %p\n", q, p));
	*(struct __ns1__RobotPdControl*)p = *(struct __ns1__RobotPdControl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotLifterControl(struct soap *soap, struct __ns1__RobotLifterControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RobotLifterControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotLifterControl(struct soap *soap, const struct __ns1__RobotLifterControl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RobotLifterControl(soap, &a->ns3__RobotLifterControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotLifterControl(struct soap *soap, const char *tag, int id, const struct __ns1__RobotLifterControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__RobotLifterControl(soap, "ns3:RobotLifterControl", -1, &a->ns3__RobotLifterControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotLifterControl * SOAP_FMAC4 soap_in___ns1__RobotLifterControl(struct soap *soap, const char *tag, struct __ns1__RobotLifterControl *a, const char *type)
{
	size_t soap_flag_ns3__RobotLifterControl = 1;
	short soap_flag;
	a = (struct __ns1__RobotLifterControl *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__RobotLifterControl, sizeof(struct __ns1__RobotLifterControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotLifterControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RobotLifterControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RobotLifterControl(soap, "ns3:RobotLifterControl", &a->ns3__RobotLifterControl, ""))
				{	soap_flag_ns3__RobotLifterControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotLifterControl(struct soap *soap, const struct __ns1__RobotLifterControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotLifterControl(soap, tag?tag:"-ns1:RobotLifterControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotLifterControl * SOAP_FMAC4 soap_get___ns1__RobotLifterControl(struct soap *soap, struct __ns1__RobotLifterControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotLifterControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotLifterControl * SOAP_FMAC2 soap_instantiate___ns1__RobotLifterControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotLifterControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__RobotLifterControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotLifterControl);
		if (size)
			*size = sizeof(struct __ns1__RobotLifterControl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotLifterControl, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotLifterControl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotLifterControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotLifterControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotLifterControl %p -> %p\n", q, p));
	*(struct __ns1__RobotLifterControl*)p = *(struct __ns1__RobotLifterControl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotFlirControl(struct soap *soap, struct __ns1__RobotFlirControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RobotFlirControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotFlirControl(struct soap *soap, const struct __ns1__RobotFlirControl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RobotFlirControl(soap, &a->ns3__RobotFlirControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotFlirControl(struct soap *soap, const char *tag, int id, const struct __ns1__RobotFlirControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__RobotFlirControl(soap, "ns3:RobotFlirControl", -1, &a->ns3__RobotFlirControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotFlirControl * SOAP_FMAC4 soap_in___ns1__RobotFlirControl(struct soap *soap, const char *tag, struct __ns1__RobotFlirControl *a, const char *type)
{
	size_t soap_flag_ns3__RobotFlirControl = 1;
	short soap_flag;
	a = (struct __ns1__RobotFlirControl *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__RobotFlirControl, sizeof(struct __ns1__RobotFlirControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotFlirControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RobotFlirControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RobotFlirControl(soap, "ns3:RobotFlirControl", &a->ns3__RobotFlirControl, ""))
				{	soap_flag_ns3__RobotFlirControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotFlirControl(struct soap *soap, const struct __ns1__RobotFlirControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotFlirControl(soap, tag?tag:"-ns1:RobotFlirControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotFlirControl * SOAP_FMAC4 soap_get___ns1__RobotFlirControl(struct soap *soap, struct __ns1__RobotFlirControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotFlirControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotFlirControl * SOAP_FMAC2 soap_instantiate___ns1__RobotFlirControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotFlirControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__RobotFlirControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotFlirControl);
		if (size)
			*size = sizeof(struct __ns1__RobotFlirControl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotFlirControl, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotFlirControl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotFlirControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotFlirControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotFlirControl %p -> %p\n", q, p));
	*(struct __ns1__RobotFlirControl*)p = *(struct __ns1__RobotFlirControl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotWiperControl(struct soap *soap, struct __ns1__RobotWiperControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RobotWiperControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotWiperControl(struct soap *soap, const struct __ns1__RobotWiperControl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RobotWiperControl(soap, &a->ns3__RobotWiperControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotWiperControl(struct soap *soap, const char *tag, int id, const struct __ns1__RobotWiperControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__RobotWiperControl(soap, "ns3:RobotWiperControl", -1, &a->ns3__RobotWiperControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotWiperControl * SOAP_FMAC4 soap_in___ns1__RobotWiperControl(struct soap *soap, const char *tag, struct __ns1__RobotWiperControl *a, const char *type)
{
	size_t soap_flag_ns3__RobotWiperControl = 1;
	short soap_flag;
	a = (struct __ns1__RobotWiperControl *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__RobotWiperControl, sizeof(struct __ns1__RobotWiperControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotWiperControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RobotWiperControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RobotWiperControl(soap, "ns3:RobotWiperControl", &a->ns3__RobotWiperControl, ""))
				{	soap_flag_ns3__RobotWiperControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotWiperControl(struct soap *soap, const struct __ns1__RobotWiperControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotWiperControl(soap, tag?tag:"-ns1:RobotWiperControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotWiperControl * SOAP_FMAC4 soap_get___ns1__RobotWiperControl(struct soap *soap, struct __ns1__RobotWiperControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotWiperControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotWiperControl * SOAP_FMAC2 soap_instantiate___ns1__RobotWiperControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotWiperControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__RobotWiperControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotWiperControl);
		if (size)
			*size = sizeof(struct __ns1__RobotWiperControl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotWiperControl, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotWiperControl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotWiperControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotWiperControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotWiperControl %p -> %p\n", q, p));
	*(struct __ns1__RobotWiperControl*)p = *(struct __ns1__RobotWiperControl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotLightControl(struct soap *soap, struct __ns1__RobotLightControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RobotLightControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotLightControl(struct soap *soap, const struct __ns1__RobotLightControl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RobotLightControl(soap, &a->ns3__RobotLightControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotLightControl(struct soap *soap, const char *tag, int id, const struct __ns1__RobotLightControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__RobotLightControl(soap, "ns3:RobotLightControl", -1, &a->ns3__RobotLightControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotLightControl * SOAP_FMAC4 soap_in___ns1__RobotLightControl(struct soap *soap, const char *tag, struct __ns1__RobotLightControl *a, const char *type)
{
	size_t soap_flag_ns3__RobotLightControl = 1;
	short soap_flag;
	a = (struct __ns1__RobotLightControl *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__RobotLightControl, sizeof(struct __ns1__RobotLightControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotLightControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RobotLightControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RobotLightControl(soap, "ns3:RobotLightControl", &a->ns3__RobotLightControl, ""))
				{	soap_flag_ns3__RobotLightControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotLightControl(struct soap *soap, const struct __ns1__RobotLightControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotLightControl(soap, tag?tag:"-ns1:RobotLightControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotLightControl * SOAP_FMAC4 soap_get___ns1__RobotLightControl(struct soap *soap, struct __ns1__RobotLightControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotLightControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotLightControl * SOAP_FMAC2 soap_instantiate___ns1__RobotLightControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotLightControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__RobotLightControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotLightControl);
		if (size)
			*size = sizeof(struct __ns1__RobotLightControl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotLightControl, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotLightControl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotLightControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotLightControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotLightControl %p -> %p\n", q, p));
	*(struct __ns1__RobotLightControl*)p = *(struct __ns1__RobotLightControl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotCameraControl(struct soap *soap, struct __ns1__RobotCameraControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RobotCameraControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotCameraControl(struct soap *soap, const struct __ns1__RobotCameraControl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RobotCameraControl(soap, &a->ns3__RobotCameraControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotCameraControl(struct soap *soap, const char *tag, int id, const struct __ns1__RobotCameraControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__RobotCameraControl(soap, "ns3:RobotCameraControl", -1, &a->ns3__RobotCameraControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotCameraControl * SOAP_FMAC4 soap_in___ns1__RobotCameraControl(struct soap *soap, const char *tag, struct __ns1__RobotCameraControl *a, const char *type)
{
	size_t soap_flag_ns3__RobotCameraControl = 1;
	short soap_flag;
	a = (struct __ns1__RobotCameraControl *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__RobotCameraControl, sizeof(struct __ns1__RobotCameraControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotCameraControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RobotCameraControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RobotCameraControl(soap, "ns3:RobotCameraControl", &a->ns3__RobotCameraControl, ""))
				{	soap_flag_ns3__RobotCameraControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotCameraControl(struct soap *soap, const struct __ns1__RobotCameraControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotCameraControl(soap, tag?tag:"-ns1:RobotCameraControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotCameraControl * SOAP_FMAC4 soap_get___ns1__RobotCameraControl(struct soap *soap, struct __ns1__RobotCameraControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotCameraControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotCameraControl * SOAP_FMAC2 soap_instantiate___ns1__RobotCameraControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotCameraControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__RobotCameraControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotCameraControl);
		if (size)
			*size = sizeof(struct __ns1__RobotCameraControl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotCameraControl, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotCameraControl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotCameraControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotCameraControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotCameraControl %p -> %p\n", q, p));
	*(struct __ns1__RobotCameraControl*)p = *(struct __ns1__RobotCameraControl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotYuntaiControl(struct soap *soap, struct __ns1__RobotYuntaiControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RobotYuntaiControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotYuntaiControl(struct soap *soap, const struct __ns1__RobotYuntaiControl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RobotYuntaiControl(soap, &a->ns3__RobotYuntaiControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotYuntaiControl(struct soap *soap, const char *tag, int id, const struct __ns1__RobotYuntaiControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__RobotYuntaiControl(soap, "ns3:RobotYuntaiControl", -1, &a->ns3__RobotYuntaiControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotYuntaiControl * SOAP_FMAC4 soap_in___ns1__RobotYuntaiControl(struct soap *soap, const char *tag, struct __ns1__RobotYuntaiControl *a, const char *type)
{
	size_t soap_flag_ns3__RobotYuntaiControl = 1;
	short soap_flag;
	a = (struct __ns1__RobotYuntaiControl *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__RobotYuntaiControl, sizeof(struct __ns1__RobotYuntaiControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotYuntaiControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RobotYuntaiControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RobotYuntaiControl(soap, "ns3:RobotYuntaiControl", &a->ns3__RobotYuntaiControl, ""))
				{	soap_flag_ns3__RobotYuntaiControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotYuntaiControl(struct soap *soap, const struct __ns1__RobotYuntaiControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotYuntaiControl(soap, tag?tag:"-ns1:RobotYuntaiControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotYuntaiControl * SOAP_FMAC4 soap_get___ns1__RobotYuntaiControl(struct soap *soap, struct __ns1__RobotYuntaiControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotYuntaiControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotYuntaiControl * SOAP_FMAC2 soap_instantiate___ns1__RobotYuntaiControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotYuntaiControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__RobotYuntaiControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotYuntaiControl);
		if (size)
			*size = sizeof(struct __ns1__RobotYuntaiControl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotYuntaiControl, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotYuntaiControl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotYuntaiControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotYuntaiControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotYuntaiControl %p -> %p\n", q, p));
	*(struct __ns1__RobotYuntaiControl*)p = *(struct __ns1__RobotYuntaiControl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotSpeedControl(struct soap *soap, struct __ns1__RobotSpeedControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RobotSpeedControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotSpeedControl(struct soap *soap, const struct __ns1__RobotSpeedControl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RobotSpeedControl(soap, &a->ns3__RobotSpeedControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotSpeedControl(struct soap *soap, const char *tag, int id, const struct __ns1__RobotSpeedControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__RobotSpeedControl(soap, "ns3:RobotSpeedControl", -1, &a->ns3__RobotSpeedControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotSpeedControl * SOAP_FMAC4 soap_in___ns1__RobotSpeedControl(struct soap *soap, const char *tag, struct __ns1__RobotSpeedControl *a, const char *type)
{
	size_t soap_flag_ns3__RobotSpeedControl = 1;
	short soap_flag;
	a = (struct __ns1__RobotSpeedControl *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__RobotSpeedControl, sizeof(struct __ns1__RobotSpeedControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotSpeedControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RobotSpeedControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RobotSpeedControl(soap, "ns3:RobotSpeedControl", &a->ns3__RobotSpeedControl, ""))
				{	soap_flag_ns3__RobotSpeedControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotSpeedControl(struct soap *soap, const struct __ns1__RobotSpeedControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotSpeedControl(soap, tag?tag:"-ns1:RobotSpeedControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotSpeedControl * SOAP_FMAC4 soap_get___ns1__RobotSpeedControl(struct soap *soap, struct __ns1__RobotSpeedControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotSpeedControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotSpeedControl * SOAP_FMAC2 soap_instantiate___ns1__RobotSpeedControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotSpeedControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__RobotSpeedControl, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotSpeedControl);
		if (size)
			*size = sizeof(struct __ns1__RobotSpeedControl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotSpeedControl, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotSpeedControl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotSpeedControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotSpeedControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotSpeedControl %p -> %p\n", q, p));
	*(struct __ns1__RobotSpeedControl*)p = *(struct __ns1__RobotSpeedControl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetControlMode(struct soap *soap, struct __ns1__GetControlMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetControlMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetControlMode(struct soap *soap, const struct __ns1__GetControlMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetControlMode(soap, &a->ns3__GetControlMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetControlMode(struct soap *soap, const char *tag, int id, const struct __ns1__GetControlMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetControlMode(soap, "ns3:GetControlMode", -1, &a->ns3__GetControlMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetControlMode * SOAP_FMAC4 soap_in___ns1__GetControlMode(struct soap *soap, const char *tag, struct __ns1__GetControlMode *a, const char *type)
{
	size_t soap_flag_ns3__GetControlMode = 1;
	short soap_flag;
	a = (struct __ns1__GetControlMode *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetControlMode, sizeof(struct __ns1__GetControlMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetControlMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetControlMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetControlMode(soap, "ns3:GetControlMode", &a->ns3__GetControlMode, ""))
				{	soap_flag_ns3__GetControlMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetControlMode(struct soap *soap, const struct __ns1__GetControlMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetControlMode(soap, tag?tag:"-ns1:GetControlMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetControlMode * SOAP_FMAC4 soap_get___ns1__GetControlMode(struct soap *soap, struct __ns1__GetControlMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetControlMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetControlMode * SOAP_FMAC2 soap_instantiate___ns1__GetControlMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetControlMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetControlMode, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetControlMode);
		if (size)
			*size = sizeof(struct __ns1__GetControlMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetControlMode, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetControlMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetControlMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetControlMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetControlMode %p -> %p\n", q, p));
	*(struct __ns1__GetControlMode*)p = *(struct __ns1__GetControlMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetControlMode(struct soap *soap, struct __ns1__SetControlMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__SetControlMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetControlMode(struct soap *soap, const struct __ns1__SetControlMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__SetControlMode(soap, &a->ns3__SetControlMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetControlMode(struct soap *soap, const char *tag, int id, const struct __ns1__SetControlMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__SetControlMode(soap, "ns3:SetControlMode", -1, &a->ns3__SetControlMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetControlMode * SOAP_FMAC4 soap_in___ns1__SetControlMode(struct soap *soap, const char *tag, struct __ns1__SetControlMode *a, const char *type)
{
	size_t soap_flag_ns3__SetControlMode = 1;
	short soap_flag;
	a = (struct __ns1__SetControlMode *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__SetControlMode, sizeof(struct __ns1__SetControlMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetControlMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__SetControlMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__SetControlMode(soap, "ns3:SetControlMode", &a->ns3__SetControlMode, ""))
				{	soap_flag_ns3__SetControlMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetControlMode(struct soap *soap, const struct __ns1__SetControlMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetControlMode(soap, tag?tag:"-ns1:SetControlMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetControlMode * SOAP_FMAC4 soap_get___ns1__SetControlMode(struct soap *soap, struct __ns1__SetControlMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetControlMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetControlMode * SOAP_FMAC2 soap_instantiate___ns1__SetControlMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetControlMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__SetControlMode, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetControlMode);
		if (size)
			*size = sizeof(struct __ns1__SetControlMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetControlMode, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetControlMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetControlMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetControlMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetControlMode %p -> %p\n", q, p));
	*(struct __ns1__SetControlMode*)p = *(struct __ns1__SetControlMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ReleaseCurrentRobot(struct soap *soap, struct __ns1__ReleaseCurrentRobot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__ReleaseCurrentRobot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ReleaseCurrentRobot(struct soap *soap, const struct __ns1__ReleaseCurrentRobot *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__ReleaseCurrentRobot(soap, &a->ns3__ReleaseCurrentRobot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ReleaseCurrentRobot(struct soap *soap, const char *tag, int id, const struct __ns1__ReleaseCurrentRobot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__ReleaseCurrentRobot(soap, "ns3:ReleaseCurrentRobot", -1, &a->ns3__ReleaseCurrentRobot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReleaseCurrentRobot * SOAP_FMAC4 soap_in___ns1__ReleaseCurrentRobot(struct soap *soap, const char *tag, struct __ns1__ReleaseCurrentRobot *a, const char *type)
{
	size_t soap_flag_ns3__ReleaseCurrentRobot = 1;
	short soap_flag;
	a = (struct __ns1__ReleaseCurrentRobot *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__ReleaseCurrentRobot, sizeof(struct __ns1__ReleaseCurrentRobot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ReleaseCurrentRobot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__ReleaseCurrentRobot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__ReleaseCurrentRobot(soap, "ns3:ReleaseCurrentRobot", &a->ns3__ReleaseCurrentRobot, ""))
				{	soap_flag_ns3__ReleaseCurrentRobot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ReleaseCurrentRobot(struct soap *soap, const struct __ns1__ReleaseCurrentRobot *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ReleaseCurrentRobot(soap, tag?tag:"-ns1:ReleaseCurrentRobot", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReleaseCurrentRobot * SOAP_FMAC4 soap_get___ns1__ReleaseCurrentRobot(struct soap *soap, struct __ns1__ReleaseCurrentRobot *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ReleaseCurrentRobot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ReleaseCurrentRobot * SOAP_FMAC2 soap_instantiate___ns1__ReleaseCurrentRobot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ReleaseCurrentRobot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__ReleaseCurrentRobot, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ReleaseCurrentRobot);
		if (size)
			*size = sizeof(struct __ns1__ReleaseCurrentRobot);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__ReleaseCurrentRobot, n);
		if (size)
			*size = n * sizeof(struct __ns1__ReleaseCurrentRobot);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__ReleaseCurrentRobot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ReleaseCurrentRobot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ReleaseCurrentRobot %p -> %p\n", q, p));
	*(struct __ns1__ReleaseCurrentRobot*)p = *(struct __ns1__ReleaseCurrentRobot*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetCurrentRobot(struct soap *soap, struct __ns1__SetCurrentRobot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__SetCurrentRobot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetCurrentRobot(struct soap *soap, const struct __ns1__SetCurrentRobot *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__SetCurrentRobot(soap, &a->ns3__SetCurrentRobot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetCurrentRobot(struct soap *soap, const char *tag, int id, const struct __ns1__SetCurrentRobot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__SetCurrentRobot(soap, "ns3:SetCurrentRobot", -1, &a->ns3__SetCurrentRobot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetCurrentRobot * SOAP_FMAC4 soap_in___ns1__SetCurrentRobot(struct soap *soap, const char *tag, struct __ns1__SetCurrentRobot *a, const char *type)
{
	size_t soap_flag_ns3__SetCurrentRobot = 1;
	short soap_flag;
	a = (struct __ns1__SetCurrentRobot *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__SetCurrentRobot, sizeof(struct __ns1__SetCurrentRobot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetCurrentRobot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__SetCurrentRobot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__SetCurrentRobot(soap, "ns3:SetCurrentRobot", &a->ns3__SetCurrentRobot, ""))
				{	soap_flag_ns3__SetCurrentRobot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetCurrentRobot(struct soap *soap, const struct __ns1__SetCurrentRobot *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetCurrentRobot(soap, tag?tag:"-ns1:SetCurrentRobot", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetCurrentRobot * SOAP_FMAC4 soap_get___ns1__SetCurrentRobot(struct soap *soap, struct __ns1__SetCurrentRobot *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetCurrentRobot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetCurrentRobot * SOAP_FMAC2 soap_instantiate___ns1__SetCurrentRobot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetCurrentRobot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__SetCurrentRobot, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetCurrentRobot);
		if (size)
			*size = sizeof(struct __ns1__SetCurrentRobot);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetCurrentRobot, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetCurrentRobot);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetCurrentRobot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetCurrentRobot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetCurrentRobot %p -> %p\n", q, p));
	*(struct __ns1__SetCurrentRobot*)p = *(struct __ns1__SetCurrentRobot*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetRobotTime(struct soap *soap, struct __ns1__SetRobotTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__SetRobotTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetRobotTime(struct soap *soap, const struct __ns1__SetRobotTime *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__SetRobotTime(soap, &a->ns3__SetRobotTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetRobotTime(struct soap *soap, const char *tag, int id, const struct __ns1__SetRobotTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__SetRobotTime(soap, "ns3:SetRobotTime", -1, &a->ns3__SetRobotTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetRobotTime * SOAP_FMAC4 soap_in___ns1__SetRobotTime(struct soap *soap, const char *tag, struct __ns1__SetRobotTime *a, const char *type)
{
	size_t soap_flag_ns3__SetRobotTime = 1;
	short soap_flag;
	a = (struct __ns1__SetRobotTime *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__SetRobotTime, sizeof(struct __ns1__SetRobotTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetRobotTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__SetRobotTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__SetRobotTime(soap, "ns3:SetRobotTime", &a->ns3__SetRobotTime, ""))
				{	soap_flag_ns3__SetRobotTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetRobotTime(struct soap *soap, const struct __ns1__SetRobotTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetRobotTime(soap, tag?tag:"-ns1:SetRobotTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetRobotTime * SOAP_FMAC4 soap_get___ns1__SetRobotTime(struct soap *soap, struct __ns1__SetRobotTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetRobotTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetRobotTime * SOAP_FMAC2 soap_instantiate___ns1__SetRobotTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetRobotTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__SetRobotTime, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetRobotTime);
		if (size)
			*size = sizeof(struct __ns1__SetRobotTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetRobotTime, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetRobotTime);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetRobotTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetRobotTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetRobotTime %p -> %p\n", q, p));
	*(struct __ns1__SetRobotTime*)p = *(struct __ns1__SetRobotTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotTime(struct soap *soap, struct __ns1__GetRobotTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotTime(struct soap *soap, const struct __ns1__GetRobotTime *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotTime(soap, &a->ns3__GetRobotTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotTime(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotTime(soap, "ns3:GetRobotTime", -1, &a->ns3__GetRobotTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotTime * SOAP_FMAC4 soap_in___ns1__GetRobotTime(struct soap *soap, const char *tag, struct __ns1__GetRobotTime *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotTime = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotTime *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotTime, sizeof(struct __ns1__GetRobotTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotTime(soap, "ns3:GetRobotTime", &a->ns3__GetRobotTime, ""))
				{	soap_flag_ns3__GetRobotTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotTime(struct soap *soap, const struct __ns1__GetRobotTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotTime(soap, tag?tag:"-ns1:GetRobotTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotTime * SOAP_FMAC4 soap_get___ns1__GetRobotTime(struct soap *soap, struct __ns1__GetRobotTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotTime * SOAP_FMAC2 soap_instantiate___ns1__GetRobotTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotTime, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotTime);
		if (size)
			*size = sizeof(struct __ns1__GetRobotTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotTime, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotTime);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotTime %p -> %p\n", q, p));
	*(struct __ns1__GetRobotTime*)p = *(struct __ns1__GetRobotTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotInfo(struct soap *soap, struct __ns1__GetRobotInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotInfo(struct soap *soap, const struct __ns1__GetRobotInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotInfo(soap, &a->ns3__GetRobotInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotInfo(soap, "ns3:GetRobotInfo", -1, &a->ns3__GetRobotInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotInfo * SOAP_FMAC4 soap_in___ns1__GetRobotInfo(struct soap *soap, const char *tag, struct __ns1__GetRobotInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotInfo, sizeof(struct __ns1__GetRobotInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotInfo(soap, "ns3:GetRobotInfo", &a->ns3__GetRobotInfo, ""))
				{	soap_flag_ns3__GetRobotInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotInfo(struct soap *soap, const struct __ns1__GetRobotInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotInfo(soap, tag?tag:"-ns1:GetRobotInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotInfo * SOAP_FMAC4 soap_get___ns1__GetRobotInfo(struct soap *soap, struct __ns1__GetRobotInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotInfo * SOAP_FMAC2 soap_instantiate___ns1__GetRobotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotInfo);
		if (size)
			*size = sizeof(struct __ns1__GetRobotInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotInfo %p -> %p\n", q, p));
	*(struct __ns1__GetRobotInfo*)p = *(struct __ns1__GetRobotInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRobotConnect(struct soap *soap, struct __ns1__GetRobotConnect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRobotConnect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRobotConnect(struct soap *soap, const struct __ns1__GetRobotConnect *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRobotConnect(soap, &a->ns3__GetRobotConnect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRobotConnect(struct soap *soap, const char *tag, int id, const struct __ns1__GetRobotConnect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns3__GetRobotConnect(soap, "ns3:GetRobotConnect", -1, &a->ns3__GetRobotConnect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotConnect * SOAP_FMAC4 soap_in___ns1__GetRobotConnect(struct soap *soap, const char *tag, struct __ns1__GetRobotConnect *a, const char *type)
{
	size_t soap_flag_ns3__GetRobotConnect = 1;
	short soap_flag;
	a = (struct __ns1__GetRobotConnect *)soap_id_enter(soap, "", a, SOAP_TYPE_RobotData___ns1__GetRobotConnect, sizeof(struct __ns1__GetRobotConnect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRobotConnect(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRobotConnect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRobotConnect(soap, "ns3:GetRobotConnect", &a->ns3__GetRobotConnect, ""))
				{	soap_flag_ns3__GetRobotConnect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRobotConnect(struct soap *soap, const struct __ns1__GetRobotConnect *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRobotConnect(soap, tag?tag:"-ns1:GetRobotConnect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRobotConnect * SOAP_FMAC4 soap_get___ns1__GetRobotConnect(struct soap *soap, struct __ns1__GetRobotConnect *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRobotConnect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRobotConnect * SOAP_FMAC2 soap_instantiate___ns1__GetRobotConnect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRobotConnect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData___ns1__GetRobotConnect, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRobotConnect);
		if (size)
			*size = sizeof(struct __ns1__GetRobotConnect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRobotConnect, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRobotConnect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRobotConnect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRobotConnect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRobotConnect %p -> %p\n", q, p));
	*(struct __ns1__GetRobotConnect*)p = *(struct __ns1__GetRobotConnect*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotAlarmInfoResponse(struct soap *soap, _ns3__GetRobotAlarmInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotAlarmInfoResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotAlarmInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotAlarmInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotAlarmInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotAlarmInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotAlarmInfoResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotAlarmInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotAlarmInfoResponse *)soap_instantiate__ns3__GetRobotAlarmInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotAlarmInfoResponse ** p = (_ns3__GetRobotAlarmInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfoResponse, sizeof(_ns3__GetRobotAlarmInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotAlarmInfoResponse(struct soap *soap, _ns3__GetRobotAlarmInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotAlarmInfoResponse);
	if (soap_out_PointerTo_ns3__GetRobotAlarmInfoResponse(soap, tag?tag:"ns3:GetRobotAlarmInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotAlarmInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotAlarmInfoResponse(struct soap *soap, _ns3__GetRobotAlarmInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotAlarmInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotAlarmInfo(struct soap *soap, _ns3__GetRobotAlarmInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotAlarmInfo(struct soap *soap, const char *tag, int id, _ns3__GetRobotAlarmInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotAlarmInfo ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotAlarmInfo(struct soap *soap, const char *tag, _ns3__GetRobotAlarmInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotAlarmInfo **)soap_malloc(soap, sizeof(_ns3__GetRobotAlarmInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotAlarmInfo *)soap_instantiate__ns3__GetRobotAlarmInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotAlarmInfo ** p = (_ns3__GetRobotAlarmInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotAlarmInfo, sizeof(_ns3__GetRobotAlarmInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotAlarmInfo(struct soap *soap, _ns3__GetRobotAlarmInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotAlarmInfo);
	if (soap_out_PointerTo_ns3__GetRobotAlarmInfo(soap, tag?tag:"ns3:GetRobotAlarmInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotAlarmInfo ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotAlarmInfo(struct soap *soap, _ns3__GetRobotAlarmInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotGasInfoResponse(struct soap *soap, _ns3__GetRobotGasInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotGasInfoResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotGasInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotGasInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotGasInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotGasInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotGasInfoResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotGasInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotGasInfoResponse *)soap_instantiate__ns3__GetRobotGasInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotGasInfoResponse ** p = (_ns3__GetRobotGasInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotGasInfoResponse, sizeof(_ns3__GetRobotGasInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotGasInfoResponse(struct soap *soap, _ns3__GetRobotGasInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotGasInfoResponse);
	if (soap_out_PointerTo_ns3__GetRobotGasInfoResponse(soap, tag?tag:"ns3:GetRobotGasInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotGasInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotGasInfoResponse(struct soap *soap, _ns3__GetRobotGasInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotGasInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotGasInfo(struct soap *soap, _ns3__GetRobotGasInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotGasInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotGasInfo(struct soap *soap, const char *tag, int id, _ns3__GetRobotGasInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotGasInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotGasInfo ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotGasInfo(struct soap *soap, const char *tag, _ns3__GetRobotGasInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotGasInfo **)soap_malloc(soap, sizeof(_ns3__GetRobotGasInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotGasInfo *)soap_instantiate__ns3__GetRobotGasInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotGasInfo ** p = (_ns3__GetRobotGasInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotGasInfo, sizeof(_ns3__GetRobotGasInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotGasInfo(struct soap *soap, _ns3__GetRobotGasInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotGasInfo);
	if (soap_out_PointerTo_ns3__GetRobotGasInfo(soap, tag?tag:"ns3:GetRobotGasInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotGasInfo ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotGasInfo(struct soap *soap, _ns3__GetRobotGasInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotMileageInfoResponse(struct soap *soap, _ns3__GetRobotMileageInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotMileageInfoResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotMileageInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotMileageInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotMileageInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotMileageInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotMileageInfoResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotMileageInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotMileageInfoResponse *)soap_instantiate__ns3__GetRobotMileageInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotMileageInfoResponse ** p = (_ns3__GetRobotMileageInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfoResponse, sizeof(_ns3__GetRobotMileageInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotMileageInfoResponse(struct soap *soap, _ns3__GetRobotMileageInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotMileageInfoResponse);
	if (soap_out_PointerTo_ns3__GetRobotMileageInfoResponse(soap, tag?tag:"ns3:GetRobotMileageInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotMileageInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotMileageInfoResponse(struct soap *soap, _ns3__GetRobotMileageInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotMileageInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotMileageInfo(struct soap *soap, _ns3__GetRobotMileageInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotMileageInfo(struct soap *soap, const char *tag, int id, _ns3__GetRobotMileageInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotMileageInfo ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotMileageInfo(struct soap *soap, const char *tag, _ns3__GetRobotMileageInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotMileageInfo **)soap_malloc(soap, sizeof(_ns3__GetRobotMileageInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotMileageInfo *)soap_instantiate__ns3__GetRobotMileageInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotMileageInfo ** p = (_ns3__GetRobotMileageInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotMileageInfo, sizeof(_ns3__GetRobotMileageInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotMileageInfo(struct soap *soap, _ns3__GetRobotMileageInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotMileageInfo);
	if (soap_out_PointerTo_ns3__GetRobotMileageInfo(soap, tag?tag:"ns3:GetRobotMileageInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotMileageInfo ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotMileageInfo(struct soap *soap, _ns3__GetRobotMileageInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotYunTaiInfoResponse(struct soap *soap, _ns3__GetRobotYunTaiInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotYunTaiInfoResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotYunTaiInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotYunTaiInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotYunTaiInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotYunTaiInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotYunTaiInfoResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotYunTaiInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotYunTaiInfoResponse *)soap_instantiate__ns3__GetRobotYunTaiInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotYunTaiInfoResponse ** p = (_ns3__GetRobotYunTaiInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfoResponse, sizeof(_ns3__GetRobotYunTaiInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotYunTaiInfoResponse(struct soap *soap, _ns3__GetRobotYunTaiInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotYunTaiInfoResponse);
	if (soap_out_PointerTo_ns3__GetRobotYunTaiInfoResponse(soap, tag?tag:"ns3:GetRobotYunTaiInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotYunTaiInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotYunTaiInfoResponse(struct soap *soap, _ns3__GetRobotYunTaiInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotYunTaiInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotYunTaiInfo(struct soap *soap, _ns3__GetRobotYunTaiInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotYunTaiInfo(struct soap *soap, const char *tag, int id, _ns3__GetRobotYunTaiInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotYunTaiInfo ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotYunTaiInfo(struct soap *soap, const char *tag, _ns3__GetRobotYunTaiInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotYunTaiInfo **)soap_malloc(soap, sizeof(_ns3__GetRobotYunTaiInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotYunTaiInfo *)soap_instantiate__ns3__GetRobotYunTaiInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotYunTaiInfo ** p = (_ns3__GetRobotYunTaiInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotYunTaiInfo, sizeof(_ns3__GetRobotYunTaiInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotYunTaiInfo(struct soap *soap, _ns3__GetRobotYunTaiInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotYunTaiInfo);
	if (soap_out_PointerTo_ns3__GetRobotYunTaiInfo(soap, tag?tag:"ns3:GetRobotYunTaiInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotYunTaiInfo ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotYunTaiInfo(struct soap *soap, _ns3__GetRobotYunTaiInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotPosInfoResponse(struct soap *soap, _ns3__GetRobotPosInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotPosInfoResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotPosInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotPosInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotPosInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotPosInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotPosInfoResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotPosInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotPosInfoResponse *)soap_instantiate__ns3__GetRobotPosInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotPosInfoResponse ** p = (_ns3__GetRobotPosInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotPosInfoResponse, sizeof(_ns3__GetRobotPosInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotPosInfoResponse(struct soap *soap, _ns3__GetRobotPosInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotPosInfoResponse);
	if (soap_out_PointerTo_ns3__GetRobotPosInfoResponse(soap, tag?tag:"ns3:GetRobotPosInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotPosInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotPosInfoResponse(struct soap *soap, _ns3__GetRobotPosInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotPosInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotPosInfo(struct soap *soap, _ns3__GetRobotPosInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotPosInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotPosInfo(struct soap *soap, const char *tag, int id, _ns3__GetRobotPosInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotPosInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotPosInfo ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotPosInfo(struct soap *soap, const char *tag, _ns3__GetRobotPosInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotPosInfo **)soap_malloc(soap, sizeof(_ns3__GetRobotPosInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotPosInfo *)soap_instantiate__ns3__GetRobotPosInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotPosInfo ** p = (_ns3__GetRobotPosInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotPosInfo, sizeof(_ns3__GetRobotPosInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotPosInfo(struct soap *soap, _ns3__GetRobotPosInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotPosInfo);
	if (soap_out_PointerTo_ns3__GetRobotPosInfo(soap, tag?tag:"ns3:GetRobotPosInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotPosInfo ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotPosInfo(struct soap *soap, _ns3__GetRobotPosInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotTaskStateResponse(struct soap *soap, _ns3__GetRobotTaskStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotTaskStateResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotTaskStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotTaskStateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotTaskStateResponse(struct soap *soap, const char *tag, _ns3__GetRobotTaskStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotTaskStateResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotTaskStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotTaskStateResponse *)soap_instantiate__ns3__GetRobotTaskStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotTaskStateResponse ** p = (_ns3__GetRobotTaskStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotTaskStateResponse, sizeof(_ns3__GetRobotTaskStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotTaskStateResponse(struct soap *soap, _ns3__GetRobotTaskStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTaskStateResponse);
	if (soap_out_PointerTo_ns3__GetRobotTaskStateResponse(soap, tag?tag:"ns3:GetRobotTaskStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotTaskStateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotTaskStateResponse(struct soap *soap, _ns3__GetRobotTaskStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotTaskStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotTaskState(struct soap *soap, _ns3__GetRobotTaskState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotTaskState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotTaskState(struct soap *soap, const char *tag, int id, _ns3__GetRobotTaskState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotTaskState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotTaskState ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotTaskState(struct soap *soap, const char *tag, _ns3__GetRobotTaskState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotTaskState **)soap_malloc(soap, sizeof(_ns3__GetRobotTaskState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotTaskState *)soap_instantiate__ns3__GetRobotTaskState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotTaskState ** p = (_ns3__GetRobotTaskState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotTaskState, sizeof(_ns3__GetRobotTaskState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotTaskState(struct soap *soap, _ns3__GetRobotTaskState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTaskState);
	if (soap_out_PointerTo_ns3__GetRobotTaskState(soap, tag?tag:"ns3:GetRobotTaskState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotTaskState ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotTaskState(struct soap *soap, _ns3__GetRobotTaskState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotSpeedInfoResponse(struct soap *soap, _ns3__GetRobotSpeedInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotSpeedInfoResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotSpeedInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotSpeedInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotSpeedInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotSpeedInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotSpeedInfoResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotSpeedInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotSpeedInfoResponse *)soap_instantiate__ns3__GetRobotSpeedInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotSpeedInfoResponse ** p = (_ns3__GetRobotSpeedInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfoResponse, sizeof(_ns3__GetRobotSpeedInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotSpeedInfoResponse(struct soap *soap, _ns3__GetRobotSpeedInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotSpeedInfoResponse);
	if (soap_out_PointerTo_ns3__GetRobotSpeedInfoResponse(soap, tag?tag:"ns3:GetRobotSpeedInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotSpeedInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotSpeedInfoResponse(struct soap *soap, _ns3__GetRobotSpeedInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotSpeedInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotSpeedInfo(struct soap *soap, _ns3__GetRobotSpeedInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotSpeedInfo(struct soap *soap, const char *tag, int id, _ns3__GetRobotSpeedInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotSpeedInfo ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotSpeedInfo(struct soap *soap, const char *tag, _ns3__GetRobotSpeedInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotSpeedInfo **)soap_malloc(soap, sizeof(_ns3__GetRobotSpeedInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotSpeedInfo *)soap_instantiate__ns3__GetRobotSpeedInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotSpeedInfo ** p = (_ns3__GetRobotSpeedInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotSpeedInfo, sizeof(_ns3__GetRobotSpeedInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotSpeedInfo(struct soap *soap, _ns3__GetRobotSpeedInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotSpeedInfo);
	if (soap_out_PointerTo_ns3__GetRobotSpeedInfo(soap, tag?tag:"ns3:GetRobotSpeedInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotSpeedInfo ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotSpeedInfo(struct soap *soap, _ns3__GetRobotSpeedInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotSpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotBatteryInfoResponse(struct soap *soap, _ns3__GetRobotBatteryInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotBatteryInfoResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotBatteryInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotBatteryInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotBatteryInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotBatteryInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotBatteryInfoResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotBatteryInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotBatteryInfoResponse *)soap_instantiate__ns3__GetRobotBatteryInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotBatteryInfoResponse ** p = (_ns3__GetRobotBatteryInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfoResponse, sizeof(_ns3__GetRobotBatteryInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotBatteryInfoResponse(struct soap *soap, _ns3__GetRobotBatteryInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotBatteryInfoResponse);
	if (soap_out_PointerTo_ns3__GetRobotBatteryInfoResponse(soap, tag?tag:"ns3:GetRobotBatteryInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotBatteryInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotBatteryInfoResponse(struct soap *soap, _ns3__GetRobotBatteryInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotBatteryInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotBatteryInfo(struct soap *soap, _ns3__GetRobotBatteryInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotBatteryInfo(struct soap *soap, const char *tag, int id, _ns3__GetRobotBatteryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotBatteryInfo ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotBatteryInfo(struct soap *soap, const char *tag, _ns3__GetRobotBatteryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotBatteryInfo **)soap_malloc(soap, sizeof(_ns3__GetRobotBatteryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotBatteryInfo *)soap_instantiate__ns3__GetRobotBatteryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotBatteryInfo ** p = (_ns3__GetRobotBatteryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotBatteryInfo, sizeof(_ns3__GetRobotBatteryInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotBatteryInfo(struct soap *soap, _ns3__GetRobotBatteryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotBatteryInfo);
	if (soap_out_PointerTo_ns3__GetRobotBatteryInfo(soap, tag?tag:"ns3:GetRobotBatteryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotBatteryInfo ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotBatteryInfo(struct soap *soap, _ns3__GetRobotBatteryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotBatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotPdControlResponse(struct soap *soap, _ns3__RobotPdControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotPdControlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotPdControlResponse(struct soap *soap, const char *tag, int id, _ns3__RobotPdControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotPdControlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotPdControlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotPdControlResponse(struct soap *soap, const char *tag, _ns3__RobotPdControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotPdControlResponse **)soap_malloc(soap, sizeof(_ns3__RobotPdControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotPdControlResponse *)soap_instantiate__ns3__RobotPdControlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotPdControlResponse ** p = (_ns3__RobotPdControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotPdControlResponse, sizeof(_ns3__RobotPdControlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotPdControlResponse(struct soap *soap, _ns3__RobotPdControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotPdControlResponse);
	if (soap_out_PointerTo_ns3__RobotPdControlResponse(soap, tag?tag:"ns3:RobotPdControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotPdControlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotPdControlResponse(struct soap *soap, _ns3__RobotPdControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotPdControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotPdControl(struct soap *soap, _ns3__RobotPdControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotPdControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotPdControl(struct soap *soap, const char *tag, int id, _ns3__RobotPdControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotPdControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotPdControl ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotPdControl(struct soap *soap, const char *tag, _ns3__RobotPdControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotPdControl **)soap_malloc(soap, sizeof(_ns3__RobotPdControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotPdControl *)soap_instantiate__ns3__RobotPdControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotPdControl ** p = (_ns3__RobotPdControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotPdControl, sizeof(_ns3__RobotPdControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotPdControl(struct soap *soap, _ns3__RobotPdControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotPdControl);
	if (soap_out_PointerTo_ns3__RobotPdControl(soap, tag?tag:"ns3:RobotPdControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotPdControl ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotPdControl(struct soap *soap, _ns3__RobotPdControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotPdControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotLifterControlResponse(struct soap *soap, _ns3__RobotLifterControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotLifterControlResponse(struct soap *soap, const char *tag, int id, _ns3__RobotLifterControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotLifterControlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotLifterControlResponse(struct soap *soap, const char *tag, _ns3__RobotLifterControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotLifterControlResponse **)soap_malloc(soap, sizeof(_ns3__RobotLifterControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotLifterControlResponse *)soap_instantiate__ns3__RobotLifterControlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotLifterControlResponse ** p = (_ns3__RobotLifterControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotLifterControlResponse, sizeof(_ns3__RobotLifterControlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotLifterControlResponse(struct soap *soap, _ns3__RobotLifterControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotLifterControlResponse);
	if (soap_out_PointerTo_ns3__RobotLifterControlResponse(soap, tag?tag:"ns3:RobotLifterControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotLifterControlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotLifterControlResponse(struct soap *soap, _ns3__RobotLifterControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotLifterControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotLifterControl(struct soap *soap, _ns3__RobotLifterControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotLifterControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotLifterControl(struct soap *soap, const char *tag, int id, _ns3__RobotLifterControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotLifterControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotLifterControl ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotLifterControl(struct soap *soap, const char *tag, _ns3__RobotLifterControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotLifterControl **)soap_malloc(soap, sizeof(_ns3__RobotLifterControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotLifterControl *)soap_instantiate__ns3__RobotLifterControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotLifterControl ** p = (_ns3__RobotLifterControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotLifterControl, sizeof(_ns3__RobotLifterControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotLifterControl(struct soap *soap, _ns3__RobotLifterControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotLifterControl);
	if (soap_out_PointerTo_ns3__RobotLifterControl(soap, tag?tag:"ns3:RobotLifterControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotLifterControl ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotLifterControl(struct soap *soap, _ns3__RobotLifterControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotLifterControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotFlirControlResponse(struct soap *soap, _ns3__RobotFlirControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotFlirControlResponse(struct soap *soap, const char *tag, int id, _ns3__RobotFlirControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotFlirControlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotFlirControlResponse(struct soap *soap, const char *tag, _ns3__RobotFlirControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotFlirControlResponse **)soap_malloc(soap, sizeof(_ns3__RobotFlirControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotFlirControlResponse *)soap_instantiate__ns3__RobotFlirControlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotFlirControlResponse ** p = (_ns3__RobotFlirControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotFlirControlResponse, sizeof(_ns3__RobotFlirControlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotFlirControlResponse(struct soap *soap, _ns3__RobotFlirControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotFlirControlResponse);
	if (soap_out_PointerTo_ns3__RobotFlirControlResponse(soap, tag?tag:"ns3:RobotFlirControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotFlirControlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotFlirControlResponse(struct soap *soap, _ns3__RobotFlirControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotFlirControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotFlirControl(struct soap *soap, _ns3__RobotFlirControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotFlirControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotFlirControl(struct soap *soap, const char *tag, int id, _ns3__RobotFlirControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotFlirControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotFlirControl ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotFlirControl(struct soap *soap, const char *tag, _ns3__RobotFlirControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotFlirControl **)soap_malloc(soap, sizeof(_ns3__RobotFlirControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotFlirControl *)soap_instantiate__ns3__RobotFlirControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotFlirControl ** p = (_ns3__RobotFlirControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotFlirControl, sizeof(_ns3__RobotFlirControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotFlirControl(struct soap *soap, _ns3__RobotFlirControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotFlirControl);
	if (soap_out_PointerTo_ns3__RobotFlirControl(soap, tag?tag:"ns3:RobotFlirControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotFlirControl ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotFlirControl(struct soap *soap, _ns3__RobotFlirControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotFlirControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotWiperControlResponse(struct soap *soap, _ns3__RobotWiperControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotWiperControlResponse(struct soap *soap, const char *tag, int id, _ns3__RobotWiperControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotWiperControlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotWiperControlResponse(struct soap *soap, const char *tag, _ns3__RobotWiperControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotWiperControlResponse **)soap_malloc(soap, sizeof(_ns3__RobotWiperControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotWiperControlResponse *)soap_instantiate__ns3__RobotWiperControlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotWiperControlResponse ** p = (_ns3__RobotWiperControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotWiperControlResponse, sizeof(_ns3__RobotWiperControlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotWiperControlResponse(struct soap *soap, _ns3__RobotWiperControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotWiperControlResponse);
	if (soap_out_PointerTo_ns3__RobotWiperControlResponse(soap, tag?tag:"ns3:RobotWiperControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotWiperControlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotWiperControlResponse(struct soap *soap, _ns3__RobotWiperControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotWiperControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotWiperControl(struct soap *soap, _ns3__RobotWiperControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotWiperControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotWiperControl(struct soap *soap, const char *tag, int id, _ns3__RobotWiperControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotWiperControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotWiperControl ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotWiperControl(struct soap *soap, const char *tag, _ns3__RobotWiperControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotWiperControl **)soap_malloc(soap, sizeof(_ns3__RobotWiperControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotWiperControl *)soap_instantiate__ns3__RobotWiperControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotWiperControl ** p = (_ns3__RobotWiperControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotWiperControl, sizeof(_ns3__RobotWiperControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotWiperControl(struct soap *soap, _ns3__RobotWiperControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotWiperControl);
	if (soap_out_PointerTo_ns3__RobotWiperControl(soap, tag?tag:"ns3:RobotWiperControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotWiperControl ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotWiperControl(struct soap *soap, _ns3__RobotWiperControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotWiperControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotLightControlResponse(struct soap *soap, _ns3__RobotLightControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotLightControlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotLightControlResponse(struct soap *soap, const char *tag, int id, _ns3__RobotLightControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotLightControlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotLightControlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotLightControlResponse(struct soap *soap, const char *tag, _ns3__RobotLightControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotLightControlResponse **)soap_malloc(soap, sizeof(_ns3__RobotLightControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotLightControlResponse *)soap_instantiate__ns3__RobotLightControlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotLightControlResponse ** p = (_ns3__RobotLightControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotLightControlResponse, sizeof(_ns3__RobotLightControlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotLightControlResponse(struct soap *soap, _ns3__RobotLightControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotLightControlResponse);
	if (soap_out_PointerTo_ns3__RobotLightControlResponse(soap, tag?tag:"ns3:RobotLightControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotLightControlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotLightControlResponse(struct soap *soap, _ns3__RobotLightControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotLightControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotLightControl(struct soap *soap, _ns3__RobotLightControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotLightControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotLightControl(struct soap *soap, const char *tag, int id, _ns3__RobotLightControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotLightControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotLightControl ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotLightControl(struct soap *soap, const char *tag, _ns3__RobotLightControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotLightControl **)soap_malloc(soap, sizeof(_ns3__RobotLightControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotLightControl *)soap_instantiate__ns3__RobotLightControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotLightControl ** p = (_ns3__RobotLightControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotLightControl, sizeof(_ns3__RobotLightControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotLightControl(struct soap *soap, _ns3__RobotLightControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotLightControl);
	if (soap_out_PointerTo_ns3__RobotLightControl(soap, tag?tag:"ns3:RobotLightControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotLightControl ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotLightControl(struct soap *soap, _ns3__RobotLightControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotLightControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotCameraControlResponse(struct soap *soap, _ns3__RobotCameraControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotCameraControlResponse(struct soap *soap, const char *tag, int id, _ns3__RobotCameraControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotCameraControlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotCameraControlResponse(struct soap *soap, const char *tag, _ns3__RobotCameraControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotCameraControlResponse **)soap_malloc(soap, sizeof(_ns3__RobotCameraControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotCameraControlResponse *)soap_instantiate__ns3__RobotCameraControlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotCameraControlResponse ** p = (_ns3__RobotCameraControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotCameraControlResponse, sizeof(_ns3__RobotCameraControlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotCameraControlResponse(struct soap *soap, _ns3__RobotCameraControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotCameraControlResponse);
	if (soap_out_PointerTo_ns3__RobotCameraControlResponse(soap, tag?tag:"ns3:RobotCameraControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotCameraControlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotCameraControlResponse(struct soap *soap, _ns3__RobotCameraControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotCameraControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotCameraControl(struct soap *soap, _ns3__RobotCameraControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotCameraControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotCameraControl(struct soap *soap, const char *tag, int id, _ns3__RobotCameraControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotCameraControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotCameraControl ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotCameraControl(struct soap *soap, const char *tag, _ns3__RobotCameraControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotCameraControl **)soap_malloc(soap, sizeof(_ns3__RobotCameraControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotCameraControl *)soap_instantiate__ns3__RobotCameraControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotCameraControl ** p = (_ns3__RobotCameraControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotCameraControl, sizeof(_ns3__RobotCameraControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotCameraControl(struct soap *soap, _ns3__RobotCameraControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotCameraControl);
	if (soap_out_PointerTo_ns3__RobotCameraControl(soap, tag?tag:"ns3:RobotCameraControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotCameraControl ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotCameraControl(struct soap *soap, _ns3__RobotCameraControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotCameraControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotYuntaiControlResponse(struct soap *soap, _ns3__RobotYuntaiControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotYuntaiControlResponse(struct soap *soap, const char *tag, int id, _ns3__RobotYuntaiControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotYuntaiControlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotYuntaiControlResponse(struct soap *soap, const char *tag, _ns3__RobotYuntaiControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotYuntaiControlResponse **)soap_malloc(soap, sizeof(_ns3__RobotYuntaiControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotYuntaiControlResponse *)soap_instantiate__ns3__RobotYuntaiControlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotYuntaiControlResponse ** p = (_ns3__RobotYuntaiControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotYuntaiControlResponse, sizeof(_ns3__RobotYuntaiControlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotYuntaiControlResponse(struct soap *soap, _ns3__RobotYuntaiControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotYuntaiControlResponse);
	if (soap_out_PointerTo_ns3__RobotYuntaiControlResponse(soap, tag?tag:"ns3:RobotYuntaiControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotYuntaiControlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotYuntaiControlResponse(struct soap *soap, _ns3__RobotYuntaiControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotYuntaiControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotYuntaiControl(struct soap *soap, _ns3__RobotYuntaiControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotYuntaiControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotYuntaiControl(struct soap *soap, const char *tag, int id, _ns3__RobotYuntaiControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotYuntaiControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotYuntaiControl ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotYuntaiControl(struct soap *soap, const char *tag, _ns3__RobotYuntaiControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotYuntaiControl **)soap_malloc(soap, sizeof(_ns3__RobotYuntaiControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotYuntaiControl *)soap_instantiate__ns3__RobotYuntaiControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotYuntaiControl ** p = (_ns3__RobotYuntaiControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotYuntaiControl, sizeof(_ns3__RobotYuntaiControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotYuntaiControl(struct soap *soap, _ns3__RobotYuntaiControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotYuntaiControl);
	if (soap_out_PointerTo_ns3__RobotYuntaiControl(soap, tag?tag:"ns3:RobotYuntaiControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotYuntaiControl ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotYuntaiControl(struct soap *soap, _ns3__RobotYuntaiControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotYuntaiControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotSpeedControlResponse(struct soap *soap, _ns3__RobotSpeedControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotSpeedControlResponse(struct soap *soap, const char *tag, int id, _ns3__RobotSpeedControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotSpeedControlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotSpeedControlResponse(struct soap *soap, const char *tag, _ns3__RobotSpeedControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotSpeedControlResponse **)soap_malloc(soap, sizeof(_ns3__RobotSpeedControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotSpeedControlResponse *)soap_instantiate__ns3__RobotSpeedControlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotSpeedControlResponse ** p = (_ns3__RobotSpeedControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotSpeedControlResponse, sizeof(_ns3__RobotSpeedControlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotSpeedControlResponse(struct soap *soap, _ns3__RobotSpeedControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotSpeedControlResponse);
	if (soap_out_PointerTo_ns3__RobotSpeedControlResponse(soap, tag?tag:"ns3:RobotSpeedControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotSpeedControlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotSpeedControlResponse(struct soap *soap, _ns3__RobotSpeedControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotSpeedControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RobotSpeedControl(struct soap *soap, _ns3__RobotSpeedControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__RobotSpeedControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RobotSpeedControl(struct soap *soap, const char *tag, int id, _ns3__RobotSpeedControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__RobotSpeedControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RobotSpeedControl ** SOAP_FMAC4 soap_in_PointerTo_ns3__RobotSpeedControl(struct soap *soap, const char *tag, _ns3__RobotSpeedControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RobotSpeedControl **)soap_malloc(soap, sizeof(_ns3__RobotSpeedControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RobotSpeedControl *)soap_instantiate__ns3__RobotSpeedControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RobotSpeedControl ** p = (_ns3__RobotSpeedControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__RobotSpeedControl, sizeof(_ns3__RobotSpeedControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RobotSpeedControl(struct soap *soap, _ns3__RobotSpeedControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__RobotSpeedControl);
	if (soap_out_PointerTo_ns3__RobotSpeedControl(soap, tag?tag:"ns3:RobotSpeedControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__RobotSpeedControl ** SOAP_FMAC4 soap_get_PointerTo_ns3__RobotSpeedControl(struct soap *soap, _ns3__RobotSpeedControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RobotSpeedControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetControlModeResponse(struct soap *soap, _ns3__GetControlModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetControlModeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetControlModeResponse(struct soap *soap, const char *tag, int id, _ns3__GetControlModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetControlModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetControlModeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetControlModeResponse(struct soap *soap, const char *tag, _ns3__GetControlModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetControlModeResponse **)soap_malloc(soap, sizeof(_ns3__GetControlModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetControlModeResponse *)soap_instantiate__ns3__GetControlModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetControlModeResponse ** p = (_ns3__GetControlModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetControlModeResponse, sizeof(_ns3__GetControlModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetControlModeResponse(struct soap *soap, _ns3__GetControlModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetControlModeResponse);
	if (soap_out_PointerTo_ns3__GetControlModeResponse(soap, tag?tag:"ns3:GetControlModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetControlModeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetControlModeResponse(struct soap *soap, _ns3__GetControlModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetControlModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetControlMode(struct soap *soap, _ns3__GetControlMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetControlMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetControlMode(struct soap *soap, const char *tag, int id, _ns3__GetControlMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetControlMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetControlMode ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetControlMode(struct soap *soap, const char *tag, _ns3__GetControlMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetControlMode **)soap_malloc(soap, sizeof(_ns3__GetControlMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetControlMode *)soap_instantiate__ns3__GetControlMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetControlMode ** p = (_ns3__GetControlMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetControlMode, sizeof(_ns3__GetControlMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetControlMode(struct soap *soap, _ns3__GetControlMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetControlMode);
	if (soap_out_PointerTo_ns3__GetControlMode(soap, tag?tag:"ns3:GetControlMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetControlMode ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetControlMode(struct soap *soap, _ns3__GetControlMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetControlMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__SetControlModeResponse(struct soap *soap, _ns3__SetControlModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__SetControlModeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__SetControlModeResponse(struct soap *soap, const char *tag, int id, _ns3__SetControlModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__SetControlModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__SetControlModeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__SetControlModeResponse(struct soap *soap, const char *tag, _ns3__SetControlModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__SetControlModeResponse **)soap_malloc(soap, sizeof(_ns3__SetControlModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__SetControlModeResponse *)soap_instantiate__ns3__SetControlModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__SetControlModeResponse ** p = (_ns3__SetControlModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__SetControlModeResponse, sizeof(_ns3__SetControlModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__SetControlModeResponse(struct soap *soap, _ns3__SetControlModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__SetControlModeResponse);
	if (soap_out_PointerTo_ns3__SetControlModeResponse(soap, tag?tag:"ns3:SetControlModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__SetControlModeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__SetControlModeResponse(struct soap *soap, _ns3__SetControlModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__SetControlModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__SetControlMode(struct soap *soap, _ns3__SetControlMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__SetControlMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__SetControlMode(struct soap *soap, const char *tag, int id, _ns3__SetControlMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__SetControlMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__SetControlMode ** SOAP_FMAC4 soap_in_PointerTo_ns3__SetControlMode(struct soap *soap, const char *tag, _ns3__SetControlMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__SetControlMode **)soap_malloc(soap, sizeof(_ns3__SetControlMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__SetControlMode *)soap_instantiate__ns3__SetControlMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__SetControlMode ** p = (_ns3__SetControlMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__SetControlMode, sizeof(_ns3__SetControlMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__SetControlMode(struct soap *soap, _ns3__SetControlMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__SetControlMode);
	if (soap_out_PointerTo_ns3__SetControlMode(soap, tag?tag:"ns3:SetControlMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__SetControlMode ** SOAP_FMAC4 soap_get_PointerTo_ns3__SetControlMode(struct soap *soap, _ns3__SetControlMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__SetControlMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__ReleaseCurrentRobotResponse(struct soap *soap, _ns3__ReleaseCurrentRobotResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__ReleaseCurrentRobotResponse(struct soap *soap, const char *tag, int id, _ns3__ReleaseCurrentRobotResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__ReleaseCurrentRobotResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__ReleaseCurrentRobotResponse(struct soap *soap, const char *tag, _ns3__ReleaseCurrentRobotResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__ReleaseCurrentRobotResponse **)soap_malloc(soap, sizeof(_ns3__ReleaseCurrentRobotResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__ReleaseCurrentRobotResponse *)soap_instantiate__ns3__ReleaseCurrentRobotResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__ReleaseCurrentRobotResponse ** p = (_ns3__ReleaseCurrentRobotResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobotResponse, sizeof(_ns3__ReleaseCurrentRobotResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__ReleaseCurrentRobotResponse(struct soap *soap, _ns3__ReleaseCurrentRobotResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__ReleaseCurrentRobotResponse);
	if (soap_out_PointerTo_ns3__ReleaseCurrentRobotResponse(soap, tag?tag:"ns3:ReleaseCurrentRobotResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__ReleaseCurrentRobotResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__ReleaseCurrentRobotResponse(struct soap *soap, _ns3__ReleaseCurrentRobotResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__ReleaseCurrentRobotResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__ReleaseCurrentRobot(struct soap *soap, _ns3__ReleaseCurrentRobot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__ReleaseCurrentRobot(struct soap *soap, const char *tag, int id, _ns3__ReleaseCurrentRobot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__ReleaseCurrentRobot ** SOAP_FMAC4 soap_in_PointerTo_ns3__ReleaseCurrentRobot(struct soap *soap, const char *tag, _ns3__ReleaseCurrentRobot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__ReleaseCurrentRobot **)soap_malloc(soap, sizeof(_ns3__ReleaseCurrentRobot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__ReleaseCurrentRobot *)soap_instantiate__ns3__ReleaseCurrentRobot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__ReleaseCurrentRobot ** p = (_ns3__ReleaseCurrentRobot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__ReleaseCurrentRobot, sizeof(_ns3__ReleaseCurrentRobot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__ReleaseCurrentRobot(struct soap *soap, _ns3__ReleaseCurrentRobot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__ReleaseCurrentRobot);
	if (soap_out_PointerTo_ns3__ReleaseCurrentRobot(soap, tag?tag:"ns3:ReleaseCurrentRobot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__ReleaseCurrentRobot ** SOAP_FMAC4 soap_get_PointerTo_ns3__ReleaseCurrentRobot(struct soap *soap, _ns3__ReleaseCurrentRobot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__ReleaseCurrentRobot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__SetCurrentRobotResponse(struct soap *soap, _ns3__SetCurrentRobotResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__SetCurrentRobotResponse(struct soap *soap, const char *tag, int id, _ns3__SetCurrentRobotResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__SetCurrentRobotResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__SetCurrentRobotResponse(struct soap *soap, const char *tag, _ns3__SetCurrentRobotResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__SetCurrentRobotResponse **)soap_malloc(soap, sizeof(_ns3__SetCurrentRobotResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__SetCurrentRobotResponse *)soap_instantiate__ns3__SetCurrentRobotResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__SetCurrentRobotResponse ** p = (_ns3__SetCurrentRobotResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__SetCurrentRobotResponse, sizeof(_ns3__SetCurrentRobotResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__SetCurrentRobotResponse(struct soap *soap, _ns3__SetCurrentRobotResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__SetCurrentRobotResponse);
	if (soap_out_PointerTo_ns3__SetCurrentRobotResponse(soap, tag?tag:"ns3:SetCurrentRobotResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__SetCurrentRobotResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__SetCurrentRobotResponse(struct soap *soap, _ns3__SetCurrentRobotResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__SetCurrentRobotResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__SetCurrentRobot(struct soap *soap, _ns3__SetCurrentRobot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__SetCurrentRobot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__SetCurrentRobot(struct soap *soap, const char *tag, int id, _ns3__SetCurrentRobot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__SetCurrentRobot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__SetCurrentRobot ** SOAP_FMAC4 soap_in_PointerTo_ns3__SetCurrentRobot(struct soap *soap, const char *tag, _ns3__SetCurrentRobot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__SetCurrentRobot **)soap_malloc(soap, sizeof(_ns3__SetCurrentRobot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__SetCurrentRobot *)soap_instantiate__ns3__SetCurrentRobot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__SetCurrentRobot ** p = (_ns3__SetCurrentRobot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__SetCurrentRobot, sizeof(_ns3__SetCurrentRobot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__SetCurrentRobot(struct soap *soap, _ns3__SetCurrentRobot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__SetCurrentRobot);
	if (soap_out_PointerTo_ns3__SetCurrentRobot(soap, tag?tag:"ns3:SetCurrentRobot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__SetCurrentRobot ** SOAP_FMAC4 soap_get_PointerTo_ns3__SetCurrentRobot(struct soap *soap, _ns3__SetCurrentRobot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__SetCurrentRobot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__SetRobotTimeResponse(struct soap *soap, _ns3__SetRobotTimeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__SetRobotTimeResponse(struct soap *soap, const char *tag, int id, _ns3__SetRobotTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__SetRobotTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__SetRobotTimeResponse(struct soap *soap, const char *tag, _ns3__SetRobotTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__SetRobotTimeResponse **)soap_malloc(soap, sizeof(_ns3__SetRobotTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__SetRobotTimeResponse *)soap_instantiate__ns3__SetRobotTimeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__SetRobotTimeResponse ** p = (_ns3__SetRobotTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__SetRobotTimeResponse, sizeof(_ns3__SetRobotTimeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__SetRobotTimeResponse(struct soap *soap, _ns3__SetRobotTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__SetRobotTimeResponse);
	if (soap_out_PointerTo_ns3__SetRobotTimeResponse(soap, tag?tag:"ns3:SetRobotTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__SetRobotTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__SetRobotTimeResponse(struct soap *soap, _ns3__SetRobotTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__SetRobotTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__SetRobotTime(struct soap *soap, _ns3__SetRobotTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__SetRobotTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__SetRobotTime(struct soap *soap, const char *tag, int id, _ns3__SetRobotTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__SetRobotTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__SetRobotTime ** SOAP_FMAC4 soap_in_PointerTo_ns3__SetRobotTime(struct soap *soap, const char *tag, _ns3__SetRobotTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__SetRobotTime **)soap_malloc(soap, sizeof(_ns3__SetRobotTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__SetRobotTime *)soap_instantiate__ns3__SetRobotTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__SetRobotTime ** p = (_ns3__SetRobotTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__SetRobotTime, sizeof(_ns3__SetRobotTime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__SetRobotTime(struct soap *soap, _ns3__SetRobotTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__SetRobotTime);
	if (soap_out_PointerTo_ns3__SetRobotTime(soap, tag?tag:"ns3:SetRobotTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__SetRobotTime ** SOAP_FMAC4 soap_get_PointerTo_ns3__SetRobotTime(struct soap *soap, _ns3__SetRobotTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__SetRobotTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotTimeResponse(struct soap *soap, _ns3__GetRobotTimeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotTimeResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotTimeResponse(struct soap *soap, const char *tag, _ns3__GetRobotTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotTimeResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotTimeResponse *)soap_instantiate__ns3__GetRobotTimeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotTimeResponse ** p = (_ns3__GetRobotTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotTimeResponse, sizeof(_ns3__GetRobotTimeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotTimeResponse(struct soap *soap, _ns3__GetRobotTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTimeResponse);
	if (soap_out_PointerTo_ns3__GetRobotTimeResponse(soap, tag?tag:"ns3:GetRobotTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotTimeResponse(struct soap *soap, _ns3__GetRobotTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotTime(struct soap *soap, _ns3__GetRobotTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotTime(struct soap *soap, const char *tag, int id, _ns3__GetRobotTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotTime ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotTime(struct soap *soap, const char *tag, _ns3__GetRobotTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotTime **)soap_malloc(soap, sizeof(_ns3__GetRobotTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotTime *)soap_instantiate__ns3__GetRobotTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotTime ** p = (_ns3__GetRobotTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotTime, sizeof(_ns3__GetRobotTime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotTime(struct soap *soap, _ns3__GetRobotTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotTime);
	if (soap_out_PointerTo_ns3__GetRobotTime(soap, tag?tag:"ns3:GetRobotTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotTime ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotTime(struct soap *soap, _ns3__GetRobotTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotInfoResponse(struct soap *soap, _ns3__GetRobotInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotInfoResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotInfoResponse(struct soap *soap, const char *tag, _ns3__GetRobotInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotInfoResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotInfoResponse *)soap_instantiate__ns3__GetRobotInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotInfoResponse ** p = (_ns3__GetRobotInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotInfoResponse, sizeof(_ns3__GetRobotInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotInfoResponse(struct soap *soap, _ns3__GetRobotInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotInfoResponse);
	if (soap_out_PointerTo_ns3__GetRobotInfoResponse(soap, tag?tag:"ns3:GetRobotInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotInfoResponse(struct soap *soap, _ns3__GetRobotInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotInfo(struct soap *soap, _ns3__GetRobotInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotInfo(struct soap *soap, const char *tag, int id, _ns3__GetRobotInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotInfo ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotInfo(struct soap *soap, const char *tag, _ns3__GetRobotInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotInfo **)soap_malloc(soap, sizeof(_ns3__GetRobotInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotInfo *)soap_instantiate__ns3__GetRobotInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotInfo ** p = (_ns3__GetRobotInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotInfo, sizeof(_ns3__GetRobotInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotInfo(struct soap *soap, _ns3__GetRobotInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotInfo);
	if (soap_out_PointerTo_ns3__GetRobotInfo(soap, tag?tag:"ns3:GetRobotInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotInfo ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotInfo(struct soap *soap, _ns3__GetRobotInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotConnectResponse(struct soap *soap, _ns3__GetRobotConnectResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotConnectResponse(struct soap *soap, const char *tag, int id, _ns3__GetRobotConnectResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotConnectResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotConnectResponse(struct soap *soap, const char *tag, _ns3__GetRobotConnectResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotConnectResponse **)soap_malloc(soap, sizeof(_ns3__GetRobotConnectResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotConnectResponse *)soap_instantiate__ns3__GetRobotConnectResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotConnectResponse ** p = (_ns3__GetRobotConnectResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotConnectResponse, sizeof(_ns3__GetRobotConnectResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotConnectResponse(struct soap *soap, _ns3__GetRobotConnectResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotConnectResponse);
	if (soap_out_PointerTo_ns3__GetRobotConnectResponse(soap, tag?tag:"ns3:GetRobotConnectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotConnectResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotConnectResponse(struct soap *soap, _ns3__GetRobotConnectResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotConnectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRobotConnect(struct soap *soap, _ns3__GetRobotConnect *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData__ns3__GetRobotConnect))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRobotConnect(struct soap *soap, const char *tag, int id, _ns3__GetRobotConnect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData__ns3__GetRobotConnect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRobotConnect ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRobotConnect(struct soap *soap, const char *tag, _ns3__GetRobotConnect **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRobotConnect **)soap_malloc(soap, sizeof(_ns3__GetRobotConnect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRobotConnect *)soap_instantiate__ns3__GetRobotConnect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRobotConnect ** p = (_ns3__GetRobotConnect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData__ns3__GetRobotConnect, sizeof(_ns3__GetRobotConnect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRobotConnect(struct soap *soap, _ns3__GetRobotConnect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTo_ns3__GetRobotConnect);
	if (soap_out_PointerTo_ns3__GetRobotConnect(soap, tag?tag:"ns3:GetRobotConnect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__GetRobotConnect ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRobotConnect(struct soap *soap, _ns3__GetRobotConnect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRobotConnect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotAlarmInfos(struct soap *soap, ns3__RobotAlarmInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotAlarmInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotAlarmInfos(struct soap *soap, const char *tag, int id, ns3__RobotAlarmInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotAlarmInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotAlarmInfos ** SOAP_FMAC4 soap_in_PointerTons3__RobotAlarmInfos(struct soap *soap, const char *tag, ns3__RobotAlarmInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotAlarmInfos **)soap_malloc(soap, sizeof(ns3__RobotAlarmInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotAlarmInfos *)soap_instantiate_ns3__RobotAlarmInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotAlarmInfos ** p = (ns3__RobotAlarmInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotAlarmInfos, sizeof(ns3__RobotAlarmInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotAlarmInfos(struct soap *soap, ns3__RobotAlarmInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotAlarmInfos);
	if (soap_out_PointerTons3__RobotAlarmInfos(soap, tag?tag:"ns3:RobotAlarmInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotAlarmInfos ** SOAP_FMAC4 soap_get_PointerTons3__RobotAlarmInfos(struct soap *soap, ns3__RobotAlarmInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotAlarmInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotGasInfos(struct soap *soap, ns3__RobotGasInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotGasInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotGasInfos(struct soap *soap, const char *tag, int id, ns3__RobotGasInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotGasInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotGasInfos ** SOAP_FMAC4 soap_in_PointerTons3__RobotGasInfos(struct soap *soap, const char *tag, ns3__RobotGasInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotGasInfos **)soap_malloc(soap, sizeof(ns3__RobotGasInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotGasInfos *)soap_instantiate_ns3__RobotGasInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotGasInfos ** p = (ns3__RobotGasInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotGasInfos, sizeof(ns3__RobotGasInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotGasInfos(struct soap *soap, ns3__RobotGasInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotGasInfos);
	if (soap_out_PointerTons3__RobotGasInfos(soap, tag?tag:"ns3:RobotGasInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotGasInfos ** SOAP_FMAC4 soap_get_PointerTons3__RobotGasInfos(struct soap *soap, ns3__RobotGasInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotGasInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotMileageInfos(struct soap *soap, ns3__RobotMileageInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotMileageInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotMileageInfos(struct soap *soap, const char *tag, int id, ns3__RobotMileageInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotMileageInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotMileageInfos ** SOAP_FMAC4 soap_in_PointerTons3__RobotMileageInfos(struct soap *soap, const char *tag, ns3__RobotMileageInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotMileageInfos **)soap_malloc(soap, sizeof(ns3__RobotMileageInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotMileageInfos *)soap_instantiate_ns3__RobotMileageInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotMileageInfos ** p = (ns3__RobotMileageInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotMileageInfos, sizeof(ns3__RobotMileageInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotMileageInfos(struct soap *soap, ns3__RobotMileageInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotMileageInfos);
	if (soap_out_PointerTons3__RobotMileageInfos(soap, tag?tag:"ns3:RobotMileageInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotMileageInfos ** SOAP_FMAC4 soap_get_PointerTons3__RobotMileageInfos(struct soap *soap, ns3__RobotMileageInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotMileageInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotYunTaiInfos(struct soap *soap, ns3__RobotYunTaiInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotYunTaiInfos(struct soap *soap, const char *tag, int id, ns3__RobotYunTaiInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotYunTaiInfos ** SOAP_FMAC4 soap_in_PointerTons3__RobotYunTaiInfos(struct soap *soap, const char *tag, ns3__RobotYunTaiInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotYunTaiInfos **)soap_malloc(soap, sizeof(ns3__RobotYunTaiInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotYunTaiInfos *)soap_instantiate_ns3__RobotYunTaiInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotYunTaiInfos ** p = (ns3__RobotYunTaiInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfos, sizeof(ns3__RobotYunTaiInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotYunTaiInfos(struct soap *soap, ns3__RobotYunTaiInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotYunTaiInfos);
	if (soap_out_PointerTons3__RobotYunTaiInfos(soap, tag?tag:"ns3:RobotYunTaiInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotYunTaiInfos ** SOAP_FMAC4 soap_get_PointerTons3__RobotYunTaiInfos(struct soap *soap, ns3__RobotYunTaiInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotYunTaiInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotPosInfos(struct soap *soap, ns3__RobotPosInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotPosInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotPosInfos(struct soap *soap, const char *tag, int id, ns3__RobotPosInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotPosInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotPosInfos ** SOAP_FMAC4 soap_in_PointerTons3__RobotPosInfos(struct soap *soap, const char *tag, ns3__RobotPosInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotPosInfos **)soap_malloc(soap, sizeof(ns3__RobotPosInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotPosInfos *)soap_instantiate_ns3__RobotPosInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotPosInfos ** p = (ns3__RobotPosInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotPosInfos, sizeof(ns3__RobotPosInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotPosInfos(struct soap *soap, ns3__RobotPosInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotPosInfos);
	if (soap_out_PointerTons3__RobotPosInfos(soap, tag?tag:"ns3:RobotPosInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotPosInfos ** SOAP_FMAC4 soap_get_PointerTons3__RobotPosInfos(struct soap *soap, ns3__RobotPosInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotPosInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotTaskStates(struct soap *soap, ns3__RobotTaskStates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotTaskStates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotTaskStates(struct soap *soap, const char *tag, int id, ns3__RobotTaskStates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotTaskStates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotTaskStates ** SOAP_FMAC4 soap_in_PointerTons3__RobotTaskStates(struct soap *soap, const char *tag, ns3__RobotTaskStates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotTaskStates **)soap_malloc(soap, sizeof(ns3__RobotTaskStates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotTaskStates *)soap_instantiate_ns3__RobotTaskStates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotTaskStates ** p = (ns3__RobotTaskStates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotTaskStates, sizeof(ns3__RobotTaskStates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotTaskStates(struct soap *soap, ns3__RobotTaskStates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotTaskStates);
	if (soap_out_PointerTons3__RobotTaskStates(soap, tag?tag:"ns3:RobotTaskStates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotTaskStates ** SOAP_FMAC4 soap_get_PointerTons3__RobotTaskStates(struct soap *soap, ns3__RobotTaskStates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotTaskStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SpeedInfos(struct soap *soap, ns3__SpeedInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__SpeedInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__SpeedInfos(struct soap *soap, const char *tag, int id, ns3__SpeedInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__SpeedInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__SpeedInfos ** SOAP_FMAC4 soap_in_PointerTons3__SpeedInfos(struct soap *soap, const char *tag, ns3__SpeedInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__SpeedInfos **)soap_malloc(soap, sizeof(ns3__SpeedInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__SpeedInfos *)soap_instantiate_ns3__SpeedInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__SpeedInfos ** p = (ns3__SpeedInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__SpeedInfos, sizeof(ns3__SpeedInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SpeedInfos(struct soap *soap, ns3__SpeedInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__SpeedInfos);
	if (soap_out_PointerTons3__SpeedInfos(soap, tag?tag:"ns3:SpeedInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__SpeedInfos ** SOAP_FMAC4 soap_get_PointerTons3__SpeedInfos(struct soap *soap, ns3__SpeedInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__SpeedInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__BatteryInfos(struct soap *soap, ns3__BatteryInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__BatteryInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__BatteryInfos(struct soap *soap, const char *tag, int id, ns3__BatteryInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__BatteryInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__BatteryInfos ** SOAP_FMAC4 soap_in_PointerTons3__BatteryInfos(struct soap *soap, const char *tag, ns3__BatteryInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__BatteryInfos **)soap_malloc(soap, sizeof(ns3__BatteryInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__BatteryInfos *)soap_instantiate_ns3__BatteryInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__BatteryInfos ** p = (ns3__BatteryInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__BatteryInfos, sizeof(ns3__BatteryInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__BatteryInfos(struct soap *soap, ns3__BatteryInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__BatteryInfos);
	if (soap_out_PointerTons3__BatteryInfos(soap, tag?tag:"ns3:BatteryInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__BatteryInfos ** SOAP_FMAC4 soap_get_PointerTons3__BatteryInfos(struct soap *soap, ns3__BatteryInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__BatteryInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotInfos(struct soap *soap, ns3__RobotInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotInfos(struct soap *soap, const char *tag, int id, ns3__RobotInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotInfos ** SOAP_FMAC4 soap_in_PointerTons3__RobotInfos(struct soap *soap, const char *tag, ns3__RobotInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotInfos **)soap_malloc(soap, sizeof(ns3__RobotInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotInfos *)soap_instantiate_ns3__RobotInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotInfos ** p = (ns3__RobotInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotInfos, sizeof(ns3__RobotInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotInfos(struct soap *soap, ns3__RobotInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotInfos);
	if (soap_out_PointerTons3__RobotInfos(soap, tag?tag:"ns3:RobotInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotInfos ** SOAP_FMAC4 soap_get_PointerTons3__RobotInfos(struct soap *soap, ns3__RobotInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ConnectInfos(struct soap *soap, ns3__ConnectInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__ConnectInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ConnectInfos(struct soap *soap, const char *tag, int id, ns3__ConnectInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__ConnectInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ConnectInfos ** SOAP_FMAC4 soap_in_PointerTons3__ConnectInfos(struct soap *soap, const char *tag, ns3__ConnectInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ConnectInfos **)soap_malloc(soap, sizeof(ns3__ConnectInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ConnectInfos *)soap_instantiate_ns3__ConnectInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ConnectInfos ** p = (ns3__ConnectInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__ConnectInfos, sizeof(ns3__ConnectInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ConnectInfos(struct soap *soap, ns3__ConnectInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__ConnectInfos);
	if (soap_out_PointerTons3__ConnectInfos(soap, tag?tag:"ns3:ConnectInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ConnectInfos ** SOAP_FMAC4 soap_get_PointerTons3__ConnectInfos(struct soap *soap, ns3__ConnectInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ConnectInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TaskExcuteInfo(struct soap *soap, ns3__TaskExcuteInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__TaskExcuteInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TaskExcuteInfo(struct soap *soap, const char *tag, int id, ns3__TaskExcuteInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__TaskExcuteInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__TaskExcuteInfo ** SOAP_FMAC4 soap_in_PointerTons3__TaskExcuteInfo(struct soap *soap, const char *tag, ns3__TaskExcuteInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TaskExcuteInfo **)soap_malloc(soap, sizeof(ns3__TaskExcuteInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TaskExcuteInfo *)soap_instantiate_ns3__TaskExcuteInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__TaskExcuteInfo ** p = (ns3__TaskExcuteInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__TaskExcuteInfo, sizeof(ns3__TaskExcuteInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TaskExcuteInfo(struct soap *soap, ns3__TaskExcuteInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__TaskExcuteInfo);
	if (soap_out_PointerTons3__TaskExcuteInfo(soap, tag?tag:"ns3:TaskExcuteInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TaskExcuteInfo ** SOAP_FMAC4 soap_get_PointerTons3__TaskExcuteInfo(struct soap *soap, ns3__TaskExcuteInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TaskExcuteInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TaskFinishInfo(struct soap *soap, ns3__TaskFinishInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__TaskFinishInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TaskFinishInfo(struct soap *soap, const char *tag, int id, ns3__TaskFinishInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__TaskFinishInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__TaskFinishInfo ** SOAP_FMAC4 soap_in_PointerTons3__TaskFinishInfo(struct soap *soap, const char *tag, ns3__TaskFinishInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TaskFinishInfo **)soap_malloc(soap, sizeof(ns3__TaskFinishInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TaskFinishInfo *)soap_instantiate_ns3__TaskFinishInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__TaskFinishInfo ** p = (ns3__TaskFinishInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__TaskFinishInfo, sizeof(ns3__TaskFinishInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TaskFinishInfo(struct soap *soap, ns3__TaskFinishInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__TaskFinishInfo);
	if (soap_out_PointerTons3__TaskFinishInfo(soap, tag?tag:"ns3:TaskFinishInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TaskFinishInfo ** SOAP_FMAC4 soap_get_PointerTons3__TaskFinishInfo(struct soap *soap, ns3__TaskFinishInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TaskFinishInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TaskPathInfo(struct soap *soap, ns3__TaskPathInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__TaskPathInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TaskPathInfo(struct soap *soap, const char *tag, int id, ns3__TaskPathInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__TaskPathInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__TaskPathInfo ** SOAP_FMAC4 soap_in_PointerTons3__TaskPathInfo(struct soap *soap, const char *tag, ns3__TaskPathInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TaskPathInfo **)soap_malloc(soap, sizeof(ns3__TaskPathInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TaskPathInfo *)soap_instantiate_ns3__TaskPathInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__TaskPathInfo ** p = (ns3__TaskPathInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__TaskPathInfo, sizeof(ns3__TaskPathInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TaskPathInfo(struct soap *soap, ns3__TaskPathInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__TaskPathInfo);
	if (soap_out_PointerTons3__TaskPathInfo(soap, tag?tag:"ns3:TaskPathInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TaskPathInfo ** SOAP_FMAC4 soap_get_PointerTons3__TaskPathInfo(struct soap *soap, ns3__TaskPathInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__PatrolPointInfo(struct soap *soap, ns3__PatrolPointInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__PatrolPointInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__PatrolPointInfo(struct soap *soap, const char *tag, int id, ns3__PatrolPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__PatrolPointInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__PatrolPointInfo ** SOAP_FMAC4 soap_in_PointerTons3__PatrolPointInfo(struct soap *soap, const char *tag, ns3__PatrolPointInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__PatrolPointInfo **)soap_malloc(soap, sizeof(ns3__PatrolPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__PatrolPointInfo *)soap_instantiate_ns3__PatrolPointInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__PatrolPointInfo ** p = (ns3__PatrolPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__PatrolPointInfo, sizeof(ns3__PatrolPointInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__PatrolPointInfo(struct soap *soap, ns3__PatrolPointInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__PatrolPointInfo);
	if (soap_out_PointerTons3__PatrolPointInfo(soap, tag?tag:"ns3:PatrolPointInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__PatrolPointInfo ** SOAP_FMAC4 soap_get_PointerTons3__PatrolPointInfo(struct soap *soap, ns3__PatrolPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__PatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DockPointInfo(struct soap *soap, ns3__DockPointInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__DockPointInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__DockPointInfo(struct soap *soap, const char *tag, int id, ns3__DockPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__DockPointInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__DockPointInfo ** SOAP_FMAC4 soap_in_PointerTons3__DockPointInfo(struct soap *soap, const char *tag, ns3__DockPointInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__DockPointInfo **)soap_malloc(soap, sizeof(ns3__DockPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__DockPointInfo *)soap_instantiate_ns3__DockPointInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__DockPointInfo ** p = (ns3__DockPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__DockPointInfo, sizeof(ns3__DockPointInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DockPointInfo(struct soap *soap, ns3__DockPointInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__DockPointInfo);
	if (soap_out_PointerTons3__DockPointInfo(soap, tag?tag:"ns3:DockPointInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__DockPointInfo ** SOAP_FMAC4 soap_get_PointerTons3__DockPointInfo(struct soap *soap, ns3__DockPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__DockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__MapEdgeInfo(struct soap *soap, ns3__MapEdgeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__MapEdgeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__MapEdgeInfo(struct soap *soap, const char *tag, int id, ns3__MapEdgeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__MapEdgeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__MapEdgeInfo ** SOAP_FMAC4 soap_in_PointerTons3__MapEdgeInfo(struct soap *soap, const char *tag, ns3__MapEdgeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__MapEdgeInfo **)soap_malloc(soap, sizeof(ns3__MapEdgeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__MapEdgeInfo *)soap_instantiate_ns3__MapEdgeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__MapEdgeInfo ** p = (ns3__MapEdgeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__MapEdgeInfo, sizeof(ns3__MapEdgeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__MapEdgeInfo(struct soap *soap, ns3__MapEdgeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__MapEdgeInfo);
	if (soap_out_PointerTons3__MapEdgeInfo(soap, tag?tag:"ns3:MapEdgeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__MapEdgeInfo ** SOAP_FMAC4 soap_get_PointerTons3__MapEdgeInfo(struct soap *soap, ns3__MapEdgeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__MapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__PatrolAreaInfo(struct soap *soap, ns3__PatrolAreaInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__PatrolAreaInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__PatrolAreaInfo(struct soap *soap, const char *tag, int id, ns3__PatrolAreaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__PatrolAreaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__PatrolAreaInfo ** SOAP_FMAC4 soap_in_PointerTons3__PatrolAreaInfo(struct soap *soap, const char *tag, ns3__PatrolAreaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__PatrolAreaInfo **)soap_malloc(soap, sizeof(ns3__PatrolAreaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__PatrolAreaInfo *)soap_instantiate_ns3__PatrolAreaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__PatrolAreaInfo ** p = (ns3__PatrolAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__PatrolAreaInfo, sizeof(ns3__PatrolAreaInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__PatrolAreaInfo(struct soap *soap, ns3__PatrolAreaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__PatrolAreaInfo);
	if (soap_out_PointerTons3__PatrolAreaInfo(soap, tag?tag:"ns3:PatrolAreaInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__PatrolAreaInfo ** SOAP_FMAC4 soap_get_PointerTons3__PatrolAreaInfo(struct soap *soap, ns3__PatrolAreaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__PatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__MapAreaInfo(struct soap *soap, ns3__MapAreaInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__MapAreaInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__MapAreaInfo(struct soap *soap, const char *tag, int id, ns3__MapAreaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__MapAreaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__MapAreaInfo ** SOAP_FMAC4 soap_in_PointerTons3__MapAreaInfo(struct soap *soap, const char *tag, ns3__MapAreaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__MapAreaInfo **)soap_malloc(soap, sizeof(ns3__MapAreaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__MapAreaInfo *)soap_instantiate_ns3__MapAreaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__MapAreaInfo ** p = (ns3__MapAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__MapAreaInfo, sizeof(ns3__MapAreaInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__MapAreaInfo(struct soap *soap, ns3__MapAreaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__MapAreaInfo);
	if (soap_out_PointerTons3__MapAreaInfo(soap, tag?tag:"ns3:MapAreaInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__MapAreaInfo ** SOAP_FMAC4 soap_get_PointerTons3__MapAreaInfo(struct soap *soap, ns3__MapAreaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__MapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotAlarmInfo(struct soap *soap, ns3__RobotAlarmInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotAlarmInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotAlarmInfo(struct soap *soap, const char *tag, int id, ns3__RobotAlarmInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotAlarmInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotAlarmInfo ** SOAP_FMAC4 soap_in_PointerTons3__RobotAlarmInfo(struct soap *soap, const char *tag, ns3__RobotAlarmInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotAlarmInfo **)soap_malloc(soap, sizeof(ns3__RobotAlarmInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotAlarmInfo *)soap_instantiate_ns3__RobotAlarmInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotAlarmInfo ** p = (ns3__RobotAlarmInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotAlarmInfo, sizeof(ns3__RobotAlarmInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotAlarmInfo(struct soap *soap, ns3__RobotAlarmInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotAlarmInfo);
	if (soap_out_PointerTons3__RobotAlarmInfo(soap, tag?tag:"ns3:RobotAlarmInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotAlarmInfo ** SOAP_FMAC4 soap_get_PointerTons3__RobotAlarmInfo(struct soap *soap, ns3__RobotAlarmInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotGasInfo(struct soap *soap, ns3__RobotGasInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotGasInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotGasInfo(struct soap *soap, const char *tag, int id, ns3__RobotGasInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotGasInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotGasInfo ** SOAP_FMAC4 soap_in_PointerTons3__RobotGasInfo(struct soap *soap, const char *tag, ns3__RobotGasInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotGasInfo **)soap_malloc(soap, sizeof(ns3__RobotGasInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotGasInfo *)soap_instantiate_ns3__RobotGasInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotGasInfo ** p = (ns3__RobotGasInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotGasInfo, sizeof(ns3__RobotGasInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotGasInfo(struct soap *soap, ns3__RobotGasInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotGasInfo);
	if (soap_out_PointerTons3__RobotGasInfo(soap, tag?tag:"ns3:RobotGasInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotGasInfo ** SOAP_FMAC4 soap_get_PointerTons3__RobotGasInfo(struct soap *soap, ns3__RobotGasInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotMileageInfo(struct soap *soap, ns3__RobotMileageInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotMileageInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotMileageInfo(struct soap *soap, const char *tag, int id, ns3__RobotMileageInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotMileageInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotMileageInfo ** SOAP_FMAC4 soap_in_PointerTons3__RobotMileageInfo(struct soap *soap, const char *tag, ns3__RobotMileageInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotMileageInfo **)soap_malloc(soap, sizeof(ns3__RobotMileageInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotMileageInfo *)soap_instantiate_ns3__RobotMileageInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotMileageInfo ** p = (ns3__RobotMileageInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotMileageInfo, sizeof(ns3__RobotMileageInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotMileageInfo(struct soap *soap, ns3__RobotMileageInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotMileageInfo);
	if (soap_out_PointerTons3__RobotMileageInfo(soap, tag?tag:"ns3:RobotMileageInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotMileageInfo ** SOAP_FMAC4 soap_get_PointerTons3__RobotMileageInfo(struct soap *soap, ns3__RobotMileageInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotYunTaiInfo(struct soap *soap, ns3__RobotYunTaiInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, ns3__RobotYunTaiInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotYunTaiInfo ** SOAP_FMAC4 soap_in_PointerTons3__RobotYunTaiInfo(struct soap *soap, const char *tag, ns3__RobotYunTaiInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotYunTaiInfo **)soap_malloc(soap, sizeof(ns3__RobotYunTaiInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotYunTaiInfo *)soap_instantiate_ns3__RobotYunTaiInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotYunTaiInfo ** p = (ns3__RobotYunTaiInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo, sizeof(ns3__RobotYunTaiInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotYunTaiInfo(struct soap *soap, ns3__RobotYunTaiInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotYunTaiInfo);
	if (soap_out_PointerTons3__RobotYunTaiInfo(soap, tag?tag:"ns3:RobotYunTaiInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotYunTaiInfo ** SOAP_FMAC4 soap_get_PointerTons3__RobotYunTaiInfo(struct soap *soap, ns3__RobotYunTaiInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotPosInfo(struct soap *soap, ns3__RobotPosInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotPosInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotPosInfo(struct soap *soap, const char *tag, int id, ns3__RobotPosInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotPosInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotPosInfo ** SOAP_FMAC4 soap_in_PointerTons3__RobotPosInfo(struct soap *soap, const char *tag, ns3__RobotPosInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotPosInfo **)soap_malloc(soap, sizeof(ns3__RobotPosInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotPosInfo *)soap_instantiate_ns3__RobotPosInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotPosInfo ** p = (ns3__RobotPosInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotPosInfo, sizeof(ns3__RobotPosInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotPosInfo(struct soap *soap, ns3__RobotPosInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotPosInfo);
	if (soap_out_PointerTons3__RobotPosInfo(soap, tag?tag:"ns3:RobotPosInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotPosInfo ** SOAP_FMAC4 soap_get_PointerTons3__RobotPosInfo(struct soap *soap, ns3__RobotPosInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotTaskState(struct soap *soap, ns3__RobotTaskState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotTaskState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotTaskState(struct soap *soap, const char *tag, int id, ns3__RobotTaskState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotTaskState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotTaskState ** SOAP_FMAC4 soap_in_PointerTons3__RobotTaskState(struct soap *soap, const char *tag, ns3__RobotTaskState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotTaskState **)soap_malloc(soap, sizeof(ns3__RobotTaskState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotTaskState *)soap_instantiate_ns3__RobotTaskState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotTaskState ** p = (ns3__RobotTaskState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotTaskState, sizeof(ns3__RobotTaskState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotTaskState(struct soap *soap, ns3__RobotTaskState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotTaskState);
	if (soap_out_PointerTons3__RobotTaskState(soap, tag?tag:"ns3:RobotTaskState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotTaskState ** SOAP_FMAC4 soap_get_PointerTons3__RobotTaskState(struct soap *soap, ns3__RobotTaskState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SpeedInfo(struct soap *soap, ns3__SpeedInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__SpeedInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__SpeedInfo(struct soap *soap, const char *tag, int id, ns3__SpeedInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__SpeedInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__SpeedInfo ** SOAP_FMAC4 soap_in_PointerTons3__SpeedInfo(struct soap *soap, const char *tag, ns3__SpeedInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__SpeedInfo **)soap_malloc(soap, sizeof(ns3__SpeedInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__SpeedInfo *)soap_instantiate_ns3__SpeedInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__SpeedInfo ** p = (ns3__SpeedInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__SpeedInfo, sizeof(ns3__SpeedInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SpeedInfo(struct soap *soap, ns3__SpeedInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__SpeedInfo);
	if (soap_out_PointerTons3__SpeedInfo(soap, tag?tag:"ns3:SpeedInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__SpeedInfo ** SOAP_FMAC4 soap_get_PointerTons3__SpeedInfo(struct soap *soap, ns3__SpeedInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__SpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__BatteryInfo(struct soap *soap, ns3__BatteryInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__BatteryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__BatteryInfo(struct soap *soap, const char *tag, int id, ns3__BatteryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__BatteryInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__BatteryInfo ** SOAP_FMAC4 soap_in_PointerTons3__BatteryInfo(struct soap *soap, const char *tag, ns3__BatteryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__BatteryInfo **)soap_malloc(soap, sizeof(ns3__BatteryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__BatteryInfo *)soap_instantiate_ns3__BatteryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__BatteryInfo ** p = (ns3__BatteryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__BatteryInfo, sizeof(ns3__BatteryInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__BatteryInfo(struct soap *soap, ns3__BatteryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__BatteryInfo);
	if (soap_out_PointerTons3__BatteryInfo(soap, tag?tag:"ns3:BatteryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__BatteryInfo ** SOAP_FMAC4 soap_get_PointerTons3__BatteryInfo(struct soap *soap, ns3__BatteryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__BatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RobotInfo(struct soap *soap, ns3__RobotInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__RobotInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RobotInfo(struct soap *soap, const char *tag, int id, ns3__RobotInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__RobotInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RobotInfo ** SOAP_FMAC4 soap_in_PointerTons3__RobotInfo(struct soap *soap, const char *tag, ns3__RobotInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RobotInfo **)soap_malloc(soap, sizeof(ns3__RobotInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RobotInfo *)soap_instantiate_ns3__RobotInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__RobotInfo ** p = (ns3__RobotInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__RobotInfo, sizeof(ns3__RobotInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RobotInfo(struct soap *soap, ns3__RobotInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__RobotInfo);
	if (soap_out_PointerTons3__RobotInfo(soap, tag?tag:"ns3:RobotInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__RobotInfo ** SOAP_FMAC4 soap_get_PointerTons3__RobotInfo(struct soap *soap, ns3__RobotInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ConnectInfo(struct soap *soap, ns3__ConnectInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_RobotData_ns3__ConnectInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ConnectInfo(struct soap *soap, const char *tag, int id, ns3__ConnectInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_RobotData_ns3__ConnectInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ConnectInfo ** SOAP_FMAC4 soap_in_PointerTons3__ConnectInfo(struct soap *soap, const char *tag, ns3__ConnectInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ConnectInfo **)soap_malloc(soap, sizeof(ns3__ConnectInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ConnectInfo *)soap_instantiate_ns3__ConnectInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ConnectInfo ** p = (ns3__ConnectInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RobotData_ns3__ConnectInfo, sizeof(ns3__ConnectInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ConnectInfo(struct soap *soap, ns3__ConnectInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_PointerTons3__ConnectInfo);
	if (soap_out_PointerTons3__ConnectInfo(soap, tag?tag:"ns3:ConnectInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ConnectInfo ** SOAP_FMAC4 soap_get_PointerTons3__ConnectInfo(struct soap *soap, ns3__ConnectInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ConnectInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_RobotData__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_RobotData__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_RobotData__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_RobotData_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_RobotData_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_RobotData_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RobotData_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(struct soap *soap, std::vector<ns3__TaskExcuteInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(struct soap *soap, const std::vector<ns3__TaskExcuteInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__TaskExcuteInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__TaskExcuteInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__TaskExcuteInfo * >*a, const char *type)
{
	for (std::vector<ns3__TaskExcuteInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__TaskExcuteInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__TaskExcuteInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(struct soap *soap, const char *tag, std::vector<ns3__TaskExcuteInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__TaskExcuteInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__TaskExcuteInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskExcuteInfo, sizeof(ns3__TaskExcuteInfo), 1))
				break;
			if (!soap_in_PointerTons3__TaskExcuteInfo(soap, tag, NULL, "ns3:TaskExcuteInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__TaskExcuteInfo(soap, tag, &n, "ns3:TaskExcuteInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__TaskExcuteInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskExcuteInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__TaskExcuteInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__TaskExcuteInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__TaskExcuteInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__TaskExcuteInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__TaskExcuteInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__TaskExcuteInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__TaskExcuteInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__TaskExcuteInfo * >*)p = *(std::vector<ns3__TaskExcuteInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__TaskFinishInfo(struct soap *soap, std::vector<ns3__TaskFinishInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__TaskFinishInfo(struct soap *soap, const std::vector<ns3__TaskFinishInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__TaskFinishInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__TaskFinishInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__TaskFinishInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__TaskFinishInfo * >*a, const char *type)
{
	for (std::vector<ns3__TaskFinishInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__TaskFinishInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__TaskFinishInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__TaskFinishInfo(struct soap *soap, const char *tag, std::vector<ns3__TaskFinishInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__TaskFinishInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__TaskFinishInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskFinishInfo, sizeof(ns3__TaskFinishInfo), 1))
				break;
			if (!soap_in_PointerTons3__TaskFinishInfo(soap, tag, NULL, "ns3:TaskFinishInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__TaskFinishInfo(soap, tag, &n, "ns3:TaskFinishInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__TaskFinishInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__TaskFinishInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__TaskFinishInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__TaskFinishInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskFinishInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__TaskFinishInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__TaskFinishInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__TaskFinishInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__TaskFinishInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__TaskFinishInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__TaskFinishInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__TaskFinishInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__TaskFinishInfo * >*)p = *(std::vector<ns3__TaskFinishInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__TaskPathInfo(struct soap *soap, std::vector<ns3__TaskPathInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__TaskPathInfo(struct soap *soap, const std::vector<ns3__TaskPathInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__TaskPathInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__TaskPathInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__TaskPathInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__TaskPathInfo * >*a, const char *type)
{
	for (std::vector<ns3__TaskPathInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__TaskPathInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__TaskPathInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__TaskPathInfo(struct soap *soap, const char *tag, std::vector<ns3__TaskPathInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__TaskPathInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__TaskPathInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskPathInfo, sizeof(ns3__TaskPathInfo), 1))
				break;
			if (!soap_in_PointerTons3__TaskPathInfo(soap, tag, NULL, "ns3:TaskPathInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__TaskPathInfo(soap, tag, &n, "ns3:TaskPathInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__TaskPathInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__TaskPathInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__TaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__TaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__TaskPathInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__TaskPathInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__TaskPathInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__TaskPathInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__TaskPathInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__TaskPathInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__TaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__TaskPathInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__TaskPathInfo * >*)p = *(std::vector<ns3__TaskPathInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__PatrolPointInfo(struct soap *soap, std::vector<ns3__PatrolPointInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__PatrolPointInfo(struct soap *soap, const std::vector<ns3__PatrolPointInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__PatrolPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__PatrolPointInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__PatrolPointInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__PatrolPointInfo * >*a, const char *type)
{
	for (std::vector<ns3__PatrolPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__PatrolPointInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__PatrolPointInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__PatrolPointInfo(struct soap *soap, const char *tag, std::vector<ns3__PatrolPointInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__PatrolPointInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__PatrolPointInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolPointInfo, sizeof(ns3__PatrolPointInfo), 1))
				break;
			if (!soap_in_PointerTons3__PatrolPointInfo(soap, tag, NULL, "ns3:PatrolPointInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__PatrolPointInfo(soap, tag, &n, "ns3:PatrolPointInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__PatrolPointInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__PatrolPointInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__PatrolPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__PatrolPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolPointInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__PatrolPointInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__PatrolPointInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__PatrolPointInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__PatrolPointInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__PatrolPointInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__PatrolPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__PatrolPointInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__PatrolPointInfo * >*)p = *(std::vector<ns3__PatrolPointInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__DockPointInfo(struct soap *soap, std::vector<ns3__DockPointInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__DockPointInfo(struct soap *soap, const std::vector<ns3__DockPointInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__DockPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__DockPointInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__DockPointInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__DockPointInfo * >*a, const char *type)
{
	for (std::vector<ns3__DockPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__DockPointInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__DockPointInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__DockPointInfo(struct soap *soap, const char *tag, std::vector<ns3__DockPointInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__DockPointInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__DockPointInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__DockPointInfo, sizeof(ns3__DockPointInfo), 1))
				break;
			if (!soap_in_PointerTons3__DockPointInfo(soap, tag, NULL, "ns3:DockPointInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__DockPointInfo(soap, tag, &n, "ns3:DockPointInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__DockPointInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__DockPointInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__DockPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__DockPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__DockPointInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__DockPointInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__DockPointInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__DockPointInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__DockPointInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__DockPointInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__DockPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__DockPointInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__DockPointInfo * >*)p = *(std::vector<ns3__DockPointInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_std__string(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_std__string, SOAP_TYPE_RobotData_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfstd__string, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__MapEdgeInfo(struct soap *soap, std::vector<ns3__MapEdgeInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__MapEdgeInfo(struct soap *soap, const std::vector<ns3__MapEdgeInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__MapEdgeInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__MapEdgeInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__MapEdgeInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__MapEdgeInfo * >*a, const char *type)
{
	for (std::vector<ns3__MapEdgeInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__MapEdgeInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__MapEdgeInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__MapEdgeInfo(struct soap *soap, const char *tag, std::vector<ns3__MapEdgeInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__MapEdgeInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__MapEdgeInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapEdgeInfo, sizeof(ns3__MapEdgeInfo), 1))
				break;
			if (!soap_in_PointerTons3__MapEdgeInfo(soap, tag, NULL, "ns3:MapEdgeInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__MapEdgeInfo(soap, tag, &n, "ns3:MapEdgeInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__MapEdgeInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__MapEdgeInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__MapEdgeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__MapEdgeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapEdgeInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__MapEdgeInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__MapEdgeInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__MapEdgeInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__MapEdgeInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__MapEdgeInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__MapEdgeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__MapEdgeInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__MapEdgeInfo * >*)p = *(std::vector<ns3__MapEdgeInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(struct soap *soap, std::vector<ns3__PatrolAreaInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(struct soap *soap, const std::vector<ns3__PatrolAreaInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__PatrolAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__PatrolAreaInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__PatrolAreaInfo * >*a, const char *type)
{
	for (std::vector<ns3__PatrolAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__PatrolAreaInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__PatrolAreaInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(struct soap *soap, const char *tag, std::vector<ns3__PatrolAreaInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__PatrolAreaInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__PatrolAreaInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolAreaInfo, sizeof(ns3__PatrolAreaInfo), 1))
				break;
			if (!soap_in_PointerTons3__PatrolAreaInfo(soap, tag, NULL, "ns3:PatrolAreaInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__PatrolAreaInfo(soap, tag, &n, "ns3:PatrolAreaInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__PatrolAreaInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__PatrolAreaInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__PatrolAreaInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__PatrolAreaInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__PatrolAreaInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__PatrolAreaInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__PatrolAreaInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__PatrolAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__PatrolAreaInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__PatrolAreaInfo * >*)p = *(std::vector<ns3__PatrolAreaInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__MapAreaInfo(struct soap *soap, std::vector<ns3__MapAreaInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__MapAreaInfo(struct soap *soap, const std::vector<ns3__MapAreaInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__MapAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__MapAreaInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__MapAreaInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__MapAreaInfo * >*a, const char *type)
{
	for (std::vector<ns3__MapAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__MapAreaInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__MapAreaInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__MapAreaInfo(struct soap *soap, const char *tag, std::vector<ns3__MapAreaInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__MapAreaInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__MapAreaInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapAreaInfo, sizeof(ns3__MapAreaInfo), 1))
				break;
			if (!soap_in_PointerTons3__MapAreaInfo(soap, tag, NULL, "ns3:MapAreaInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__MapAreaInfo(soap, tag, &n, "ns3:MapAreaInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__MapAreaInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__MapAreaInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__MapAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__MapAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__MapAreaInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__MapAreaInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__MapAreaInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__MapAreaInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__MapAreaInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__MapAreaInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__MapAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__MapAreaInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__MapAreaInfo * >*)p = *(std::vector<ns3__MapAreaInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(struct soap *soap, std::vector<ns3__RobotAlarmInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(struct soap *soap, const std::vector<ns3__RobotAlarmInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__RobotAlarmInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__RobotAlarmInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__RobotAlarmInfo * >*a, const char *type)
{
	for (std::vector<ns3__RobotAlarmInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__RobotAlarmInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__RobotAlarmInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(struct soap *soap, const char *tag, std::vector<ns3__RobotAlarmInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__RobotAlarmInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__RobotAlarmInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotAlarmInfo, sizeof(ns3__RobotAlarmInfo), 1))
				break;
			if (!soap_in_PointerTons3__RobotAlarmInfo(soap, tag, NULL, "ns3:RobotAlarmInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__RobotAlarmInfo(soap, tag, &n, "ns3:RobotAlarmInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__RobotAlarmInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotAlarmInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__RobotAlarmInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__RobotAlarmInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__RobotAlarmInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__RobotAlarmInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__RobotAlarmInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__RobotAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__RobotAlarmInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__RobotAlarmInfo * >*)p = *(std::vector<ns3__RobotAlarmInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__RobotGasInfo(struct soap *soap, std::vector<ns3__RobotGasInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__RobotGasInfo(struct soap *soap, const std::vector<ns3__RobotGasInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__RobotGasInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__RobotGasInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__RobotGasInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__RobotGasInfo * >*a, const char *type)
{
	for (std::vector<ns3__RobotGasInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__RobotGasInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__RobotGasInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__RobotGasInfo(struct soap *soap, const char *tag, std::vector<ns3__RobotGasInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__RobotGasInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__RobotGasInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotGasInfo, sizeof(ns3__RobotGasInfo), 1))
				break;
			if (!soap_in_PointerTons3__RobotGasInfo(soap, tag, NULL, "ns3:RobotGasInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__RobotGasInfo(soap, tag, &n, "ns3:RobotGasInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__RobotGasInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__RobotGasInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__RobotGasInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__RobotGasInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotGasInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__RobotGasInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__RobotGasInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__RobotGasInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__RobotGasInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__RobotGasInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__RobotGasInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__RobotGasInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__RobotGasInfo * >*)p = *(std::vector<ns3__RobotGasInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__RobotMileageInfo(struct soap *soap, std::vector<ns3__RobotMileageInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__RobotMileageInfo(struct soap *soap, const std::vector<ns3__RobotMileageInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__RobotMileageInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__RobotMileageInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__RobotMileageInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__RobotMileageInfo * >*a, const char *type)
{
	for (std::vector<ns3__RobotMileageInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__RobotMileageInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__RobotMileageInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__RobotMileageInfo(struct soap *soap, const char *tag, std::vector<ns3__RobotMileageInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__RobotMileageInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__RobotMileageInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotMileageInfo, sizeof(ns3__RobotMileageInfo), 1))
				break;
			if (!soap_in_PointerTons3__RobotMileageInfo(soap, tag, NULL, "ns3:RobotMileageInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__RobotMileageInfo(soap, tag, &n, "ns3:RobotMileageInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__RobotMileageInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__RobotMileageInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__RobotMileageInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__RobotMileageInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotMileageInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__RobotMileageInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__RobotMileageInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__RobotMileageInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__RobotMileageInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__RobotMileageInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__RobotMileageInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__RobotMileageInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__RobotMileageInfo * >*)p = *(std::vector<ns3__RobotMileageInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(struct soap *soap, std::vector<ns3__RobotYunTaiInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(struct soap *soap, const std::vector<ns3__RobotYunTaiInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__RobotYunTaiInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__RobotYunTaiInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__RobotYunTaiInfo * >*a, const char *type)
{
	for (std::vector<ns3__RobotYunTaiInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__RobotYunTaiInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__RobotYunTaiInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(struct soap *soap, const char *tag, std::vector<ns3__RobotYunTaiInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__RobotYunTaiInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__RobotYunTaiInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo, sizeof(ns3__RobotYunTaiInfo), 1))
				break;
			if (!soap_in_PointerTons3__RobotYunTaiInfo(soap, tag, NULL, "ns3:RobotYunTaiInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__RobotYunTaiInfo(soap, tag, &n, "ns3:RobotYunTaiInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__RobotYunTaiInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__RobotYunTaiInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__RobotYunTaiInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__RobotYunTaiInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__RobotYunTaiInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__RobotYunTaiInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__RobotYunTaiInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__RobotYunTaiInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__RobotYunTaiInfo * >*)p = *(std::vector<ns3__RobotYunTaiInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__RobotPosInfo(struct soap *soap, std::vector<ns3__RobotPosInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__RobotPosInfo(struct soap *soap, const std::vector<ns3__RobotPosInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__RobotPosInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__RobotPosInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__RobotPosInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__RobotPosInfo * >*a, const char *type)
{
	for (std::vector<ns3__RobotPosInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__RobotPosInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__RobotPosInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__RobotPosInfo(struct soap *soap, const char *tag, std::vector<ns3__RobotPosInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__RobotPosInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__RobotPosInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotPosInfo, sizeof(ns3__RobotPosInfo), 1))
				break;
			if (!soap_in_PointerTons3__RobotPosInfo(soap, tag, NULL, "ns3:RobotPosInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__RobotPosInfo(soap, tag, &n, "ns3:RobotPosInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__RobotPosInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__RobotPosInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__RobotPosInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__RobotPosInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotPosInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__RobotPosInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__RobotPosInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__RobotPosInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__RobotPosInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__RobotPosInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__RobotPosInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__RobotPosInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__RobotPosInfo * >*)p = *(std::vector<ns3__RobotPosInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__RobotTaskState(struct soap *soap, std::vector<ns3__RobotTaskState * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__RobotTaskState(struct soap *soap, const std::vector<ns3__RobotTaskState * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__RobotTaskState * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__RobotTaskState(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__RobotTaskState(struct soap *soap, const char *tag, int id, const std::vector<ns3__RobotTaskState * >*a, const char *type)
{
	for (std::vector<ns3__RobotTaskState * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__RobotTaskState(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__RobotTaskState * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__RobotTaskState(struct soap *soap, const char *tag, std::vector<ns3__RobotTaskState * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__RobotTaskState *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__RobotTaskState, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotTaskState, sizeof(ns3__RobotTaskState), 1))
				break;
			if (!soap_in_PointerTons3__RobotTaskState(soap, tag, NULL, "ns3:RobotTaskState"))
				break;
		}
		else if (!soap_in_PointerTons3__RobotTaskState(soap, tag, &n, "ns3:RobotTaskState"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__RobotTaskState(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__RobotTaskState * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__RobotTaskState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__RobotTaskState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotTaskState, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__RobotTaskState * >);
		if (size)
			*size = sizeof(std::vector<ns3__RobotTaskState * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__RobotTaskState * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__RobotTaskState * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__RobotTaskState * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__RobotTaskState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__RobotTaskState * > %p -> %p\n", q, p));
	*(std::vector<ns3__RobotTaskState * >*)p = *(std::vector<ns3__RobotTaskState * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__SpeedInfo(struct soap *soap, std::vector<ns3__SpeedInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__SpeedInfo(struct soap *soap, const std::vector<ns3__SpeedInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__SpeedInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__SpeedInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__SpeedInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__SpeedInfo * >*a, const char *type)
{
	for (std::vector<ns3__SpeedInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__SpeedInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__SpeedInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__SpeedInfo(struct soap *soap, const char *tag, std::vector<ns3__SpeedInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__SpeedInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__SpeedInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__SpeedInfo, sizeof(ns3__SpeedInfo), 1))
				break;
			if (!soap_in_PointerTons3__SpeedInfo(soap, tag, NULL, "ns3:SpeedInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__SpeedInfo(soap, tag, &n, "ns3:SpeedInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__SpeedInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__SpeedInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__SpeedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__SpeedInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__SpeedInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__SpeedInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__SpeedInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__SpeedInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__SpeedInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__SpeedInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__SpeedInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__SpeedInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__SpeedInfo * >*)p = *(std::vector<ns3__SpeedInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__BatteryInfo(struct soap *soap, std::vector<ns3__BatteryInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__BatteryInfo(struct soap *soap, const std::vector<ns3__BatteryInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__BatteryInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__BatteryInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__BatteryInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__BatteryInfo * >*a, const char *type)
{
	for (std::vector<ns3__BatteryInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__BatteryInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__BatteryInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__BatteryInfo(struct soap *soap, const char *tag, std::vector<ns3__BatteryInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__BatteryInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__BatteryInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__BatteryInfo, sizeof(ns3__BatteryInfo), 1))
				break;
			if (!soap_in_PointerTons3__BatteryInfo(soap, tag, NULL, "ns3:BatteryInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__BatteryInfo(soap, tag, &n, "ns3:BatteryInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__BatteryInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__BatteryInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__BatteryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__BatteryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__BatteryInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__BatteryInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__BatteryInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__BatteryInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__BatteryInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__BatteryInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__BatteryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__BatteryInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__BatteryInfo * >*)p = *(std::vector<ns3__BatteryInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__RobotInfo(struct soap *soap, std::vector<ns3__RobotInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__RobotInfo(struct soap *soap, const std::vector<ns3__RobotInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__RobotInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__RobotInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__RobotInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__RobotInfo * >*a, const char *type)
{
	for (std::vector<ns3__RobotInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__RobotInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__RobotInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__RobotInfo(struct soap *soap, const char *tag, std::vector<ns3__RobotInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__RobotInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__RobotInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotInfo, sizeof(ns3__RobotInfo), 1))
				break;
			if (!soap_in_PointerTons3__RobotInfo(soap, tag, NULL, "ns3:RobotInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__RobotInfo(soap, tag, &n, "ns3:RobotInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__RobotInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__RobotInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__RobotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__RobotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__RobotInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__RobotInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__RobotInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__RobotInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__RobotInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__RobotInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__RobotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__RobotInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__RobotInfo * >*)p = *(std::vector<ns3__RobotInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__ConnectInfo(struct soap *soap, std::vector<ns3__ConnectInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__ConnectInfo(struct soap *soap, const std::vector<ns3__ConnectInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns3__ConnectInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__ConnectInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__ConnectInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__ConnectInfo * >*a, const char *type)
{
	for (std::vector<ns3__ConnectInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__ConnectInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__ConnectInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__ConnectInfo(struct soap *soap, const char *tag, std::vector<ns3__ConnectInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns3__ConnectInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_RobotData_ns3__ConnectInfo, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__ConnectInfo, sizeof(ns3__ConnectInfo), 1))
				break;
			if (!soap_in_PointerTons3__ConnectInfo(soap, tag, NULL, "ns3:ConnectInfo"))
				break;
		}
		else if (!soap_in_PointerTons3__ConnectInfo(soap, tag, &n, "ns3:ConnectInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__ConnectInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__ConnectInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__ConnectInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__ConnectInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RobotData_std__vectorTemplateOfPointerTons3__ConnectInfo, n, RobotData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__ConnectInfo * >);
		if (size)
			*size = sizeof(std::vector<ns3__ConnectInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns3__ConnectInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns3__ConnectInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns3__ConnectInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__ConnectInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__ConnectInfo * > %p -> %p\n", q, p));
	*(std::vector<ns3__ConnectInfo * >*)p = *(std::vector<ns3__ConnectInfo * >*)q;
}

} // namespace RobotData


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of RobotDataC.cpp */
