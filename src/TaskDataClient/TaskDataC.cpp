/* TaskDataC.cpp
   Generated by gSOAP 2.8.16 from .\taskdata.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "TaskDataH.h"

namespace TaskData {

SOAP_SOURCE_STAMP("@(#) TaskDataC.cpp ver 2.8.16 2020-03-04 05:59:40 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_TaskData_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_TaskData_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_TaskData_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_TaskData_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_TaskData_ns4__ControlTaskType:
		return soap_in_ns4__ControlTaskType(soap, NULL, NULL, "ns4:ControlTaskType");
	case SOAP_TYPE_TaskData_ns4__PdControlType:
		return soap_in_ns4__PdControlType(soap, NULL, NULL, "ns4:PdControlType");
	case SOAP_TYPE_TaskData_ns4__LifterControlType:
		return soap_in_ns4__LifterControlType(soap, NULL, NULL, "ns4:LifterControlType");
	case SOAP_TYPE_TaskData_ns4__FilrControlType:
		return soap_in_ns4__FilrControlType(soap, NULL, NULL, "ns4:FilrControlType");
	case SOAP_TYPE_TaskData_ns4__WiperControlType:
		return soap_in_ns4__WiperControlType(soap, NULL, NULL, "ns4:WiperControlType");
	case SOAP_TYPE_TaskData_ns4__LightControlType:
		return soap_in_ns4__LightControlType(soap, NULL, NULL, "ns4:LightControlType");
	case SOAP_TYPE_TaskData_ns4__CameraControlType:
		return soap_in_ns4__CameraControlType(soap, NULL, NULL, "ns4:CameraControlType");
	case SOAP_TYPE_TaskData_ns4__YuntaiControlType:
		return soap_in_ns4__YuntaiControlType(soap, NULL, NULL, "ns4:YuntaiControlType");
	case SOAP_TYPE_TaskData_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfos:
		return soap_in_ns4__TaskExcuteInfos(soap, NULL, NULL, "ns4:TaskExcuteInfos");
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfo:
		return soap_in_ns4__TaskExcuteInfo(soap, NULL, NULL, "ns4:TaskExcuteInfo");
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfos:
		return soap_in_ns4__TaskFinishInfos(soap, NULL, NULL, "ns4:TaskFinishInfos");
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfo:
		return soap_in_ns4__TaskFinishInfo(soap, NULL, NULL, "ns4:TaskFinishInfo");
	case SOAP_TYPE_TaskData_ns4__TaskExcuteData:
		return soap_in_ns4__TaskExcuteData(soap, NULL, NULL, "ns4:TaskExcuteData");
	case SOAP_TYPE_TaskData_ns4__TaskPathInfos:
		return soap_in_ns4__TaskPathInfos(soap, NULL, NULL, "ns4:TaskPathInfos");
	case SOAP_TYPE_TaskData_ns4__TaskPathInfo:
		return soap_in_ns4__TaskPathInfo(soap, NULL, NULL, "ns4:TaskPathInfo");
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfos:
		return soap_in_ns4__PatrolPointInfos(soap, NULL, NULL, "ns4:PatrolPointInfos");
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfo:
		return soap_in_ns4__PatrolPointInfo(soap, NULL, NULL, "ns4:PatrolPointInfo");
	case SOAP_TYPE_TaskData_ns4__DockPointInfos:
		return soap_in_ns4__DockPointInfos(soap, NULL, NULL, "ns4:DockPointInfos");
	case SOAP_TYPE_TaskData_ns4__DockPointInfo:
		return soap_in_ns4__DockPointInfo(soap, NULL, NULL, "ns4:DockPointInfo");
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfos:
		return soap_in_ns4__MapEdgeInfos(soap, NULL, NULL, "ns4:MapEdgeInfos");
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfo:
		return soap_in_ns4__MapEdgeInfo(soap, NULL, NULL, "ns4:MapEdgeInfo");
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfos:
		return soap_in_ns4__PatrolAreaInfos(soap, NULL, NULL, "ns4:PatrolAreaInfos");
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfo:
		return soap_in_ns4__PatrolAreaInfo(soap, NULL, NULL, "ns4:PatrolAreaInfo");
	case SOAP_TYPE_TaskData_ns4__MapAreaInfos:
		return soap_in_ns4__MapAreaInfos(soap, NULL, NULL, "ns4:MapAreaInfos");
	case SOAP_TYPE_TaskData_ns4__MapAreaInfo:
		return soap_in_ns4__MapAreaInfo(soap, NULL, NULL, "ns4:MapAreaInfo");
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfos:
		return soap_in_ns4__RobotAlarmInfos(soap, NULL, NULL, "ns4:RobotAlarmInfos");
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfo:
		return soap_in_ns4__RobotAlarmInfo(soap, NULL, NULL, "ns4:RobotAlarmInfo");
	case SOAP_TYPE_TaskData_ns4__RobotGasInfos:
		return soap_in_ns4__RobotGasInfos(soap, NULL, NULL, "ns4:RobotGasInfos");
	case SOAP_TYPE_TaskData_ns4__RobotGasInfo:
		return soap_in_ns4__RobotGasInfo(soap, NULL, NULL, "ns4:RobotGasInfo");
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfos:
		return soap_in_ns4__RobotMileageInfos(soap, NULL, NULL, "ns4:RobotMileageInfos");
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfo:
		return soap_in_ns4__RobotMileageInfo(soap, NULL, NULL, "ns4:RobotMileageInfo");
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos:
		return soap_in_ns4__RobotYunTaiInfos(soap, NULL, NULL, "ns4:RobotYunTaiInfos");
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo:
		return soap_in_ns4__RobotYunTaiInfo(soap, NULL, NULL, "ns4:RobotYunTaiInfo");
	case SOAP_TYPE_TaskData_ns4__RobotPosInfos:
		return soap_in_ns4__RobotPosInfos(soap, NULL, NULL, "ns4:RobotPosInfos");
	case SOAP_TYPE_TaskData_ns4__RobotPosInfo:
		return soap_in_ns4__RobotPosInfo(soap, NULL, NULL, "ns4:RobotPosInfo");
	case SOAP_TYPE_TaskData_ns4__RobotTaskStates:
		return soap_in_ns4__RobotTaskStates(soap, NULL, NULL, "ns4:RobotTaskStates");
	case SOAP_TYPE_TaskData_ns4__RobotTaskState:
		return soap_in_ns4__RobotTaskState(soap, NULL, NULL, "ns4:RobotTaskState");
	case SOAP_TYPE_TaskData_ns4__SpeedInfos:
		return soap_in_ns4__SpeedInfos(soap, NULL, NULL, "ns4:SpeedInfos");
	case SOAP_TYPE_TaskData_ns4__SpeedInfo:
		return soap_in_ns4__SpeedInfo(soap, NULL, NULL, "ns4:SpeedInfo");
	case SOAP_TYPE_TaskData_ns4__BatteryInfos:
		return soap_in_ns4__BatteryInfos(soap, NULL, NULL, "ns4:BatteryInfos");
	case SOAP_TYPE_TaskData_ns4__BatteryInfo:
		return soap_in_ns4__BatteryInfo(soap, NULL, NULL, "ns4:BatteryInfo");
	case SOAP_TYPE_TaskData_ns4__RobotInfos:
		return soap_in_ns4__RobotInfos(soap, NULL, NULL, "ns4:RobotInfos");
	case SOAP_TYPE_TaskData_ns4__RobotInfo:
		return soap_in_ns4__RobotInfo(soap, NULL, NULL, "ns4:RobotInfo");
	case SOAP_TYPE_TaskData_ns4__ConnectInfos:
		return soap_in_ns4__ConnectInfos(soap, NULL, NULL, "ns4:ConnectInfos");
	case SOAP_TYPE_TaskData_ns4__ConnectInfo:
		return soap_in_ns4__ConnectInfo(soap, NULL, NULL, "ns4:ConnectInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskExcuteDataResponse:
		return soap_in_PointerTo_ns4__GetTaskExcuteDataResponse(soap, NULL, NULL, "ns4:GetTaskExcuteDataResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskExcuteData:
		return soap_in_PointerTo_ns4__GetTaskExcuteData(soap, NULL, NULL, "ns4:GetTaskExcuteData");
	case SOAP_TYPE_TaskData_PointerTo_ns4__RobotControlTaskResponse:
		return soap_in_PointerTo_ns4__RobotControlTaskResponse(soap, NULL, NULL, "ns4:RobotControlTaskResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__RobotControlTask:
		return soap_in_PointerTo_ns4__RobotControlTask(soap, NULL, NULL, "ns4:RobotControlTask");
	case SOAP_TYPE_TaskData_PointerTo_ns4__SetTaskPathInfoResponse:
		return soap_in_PointerTo_ns4__SetTaskPathInfoResponse(soap, NULL, NULL, "ns4:SetTaskPathInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__SetTaskPathInfo:
		return soap_in_PointerTo_ns4__SetTaskPathInfo(soap, NULL, NULL, "ns4:SetTaskPathInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPointListResponse:
		return soap_in_PointerTo_ns4__StartTaskByPointListResponse(soap, NULL, NULL, "ns4:StartTaskByPointListResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPointList:
		return soap_in_PointerTo_ns4__StartTaskByPointList(soap, NULL, NULL, "ns4:StartTaskByPointList");
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPathIdResponse:
		return soap_in_PointerTo_ns4__StartTaskByPathIdResponse(soap, NULL, NULL, "ns4:StartTaskByPathIdResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPathId:
		return soap_in_PointerTo_ns4__StartTaskByPathId(soap, NULL, NULL, "ns4:StartTaskByPathId");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskPathInfoResponse:
		return soap_in_PointerTo_ns4__GetTaskPathInfoResponse(soap, NULL, NULL, "ns4:GetTaskPathInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskPathInfo:
		return soap_in_PointerTo_ns4__GetTaskPathInfo(soap, NULL, NULL, "ns4:GetTaskPathInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolPointInfoResponse:
		return soap_in_PointerTo_ns4__GetPatrolPointInfoResponse(soap, NULL, NULL, "ns4:GetPatrolPointInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolPointInfo:
		return soap_in_PointerTo_ns4__GetPatrolPointInfo(soap, NULL, NULL, "ns4:GetPatrolPointInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetDockPointInfoResponse:
		return soap_in_PointerTo_ns4__GetDockPointInfoResponse(soap, NULL, NULL, "ns4:GetDockPointInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetDockPointInfo:
		return soap_in_PointerTo_ns4__GetDockPointInfo(soap, NULL, NULL, "ns4:GetDockPointInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapEdgeInfoResponse:
		return soap_in_PointerTo_ns4__GetMapEdgeInfoResponse(soap, NULL, NULL, "ns4:GetMapEdgeInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapEdgeInfo:
		return soap_in_PointerTo_ns4__GetMapEdgeInfo(soap, NULL, NULL, "ns4:GetMapEdgeInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolAreaInfoResponse:
		return soap_in_PointerTo_ns4__GetPatrolAreaInfoResponse(soap, NULL, NULL, "ns4:GetPatrolAreaInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolAreaInfo:
		return soap_in_PointerTo_ns4__GetPatrolAreaInfo(soap, NULL, NULL, "ns4:GetPatrolAreaInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapAreaInfoResponse:
		return soap_in_PointerTo_ns4__GetMapAreaInfoResponse(soap, NULL, NULL, "ns4:GetMapAreaInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapAreaInfo:
		return soap_in_PointerTo_ns4__GetMapAreaInfo(soap, NULL, NULL, "ns4:GetMapAreaInfo");
	case SOAP_TYPE_TaskData_PointerTons4__TaskExcuteData:
		return soap_in_PointerTons4__TaskExcuteData(soap, NULL, NULL, "ns4:TaskExcuteData");
	case SOAP_TYPE_TaskData_PointerTons4__TaskPathInfos:
		return soap_in_PointerTons4__TaskPathInfos(soap, NULL, NULL, "ns4:TaskPathInfos");
	case SOAP_TYPE_TaskData_PointerTons4__PatrolPointInfos:
		return soap_in_PointerTons4__PatrolPointInfos(soap, NULL, NULL, "ns4:PatrolPointInfos");
	case SOAP_TYPE_TaskData_PointerTons4__DockPointInfos:
		return soap_in_PointerTons4__DockPointInfos(soap, NULL, NULL, "ns4:DockPointInfos");
	case SOAP_TYPE_TaskData_PointerTons4__MapEdgeInfos:
		return soap_in_PointerTons4__MapEdgeInfos(soap, NULL, NULL, "ns4:MapEdgeInfos");
	case SOAP_TYPE_TaskData_PointerTons4__PatrolAreaInfos:
		return soap_in_PointerTons4__PatrolAreaInfos(soap, NULL, NULL, "ns4:PatrolAreaInfos");
	case SOAP_TYPE_TaskData_PointerTons4__MapAreaInfos:
		return soap_in_PointerTons4__MapAreaInfos(soap, NULL, NULL, "ns4:MapAreaInfos");
	case SOAP_TYPE_TaskData_PointerTons4__TaskExcuteInfo:
		return soap_in_PointerTons4__TaskExcuteInfo(soap, NULL, NULL, "ns4:TaskExcuteInfo");
	case SOAP_TYPE_TaskData_PointerTons4__TaskFinishInfo:
		return soap_in_PointerTons4__TaskFinishInfo(soap, NULL, NULL, "ns4:TaskFinishInfo");
	case SOAP_TYPE_TaskData_PointerTons4__TaskPathInfo:
		return soap_in_PointerTons4__TaskPathInfo(soap, NULL, NULL, "ns4:TaskPathInfo");
	case SOAP_TYPE_TaskData_PointerTons4__PatrolPointInfo:
		return soap_in_PointerTons4__PatrolPointInfo(soap, NULL, NULL, "ns4:PatrolPointInfo");
	case SOAP_TYPE_TaskData_PointerTons4__DockPointInfo:
		return soap_in_PointerTons4__DockPointInfo(soap, NULL, NULL, "ns4:DockPointInfo");
	case SOAP_TYPE_TaskData_PointerTons4__MapEdgeInfo:
		return soap_in_PointerTons4__MapEdgeInfo(soap, NULL, NULL, "ns4:MapEdgeInfo");
	case SOAP_TYPE_TaskData_PointerTons4__PatrolAreaInfo:
		return soap_in_PointerTons4__PatrolAreaInfo(soap, NULL, NULL, "ns4:PatrolAreaInfo");
	case SOAP_TYPE_TaskData_PointerTons4__MapAreaInfo:
		return soap_in_PointerTons4__MapAreaInfo(soap, NULL, NULL, "ns4:MapAreaInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotAlarmInfo:
		return soap_in_PointerTons4__RobotAlarmInfo(soap, NULL, NULL, "ns4:RobotAlarmInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotGasInfo:
		return soap_in_PointerTons4__RobotGasInfo(soap, NULL, NULL, "ns4:RobotGasInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotMileageInfo:
		return soap_in_PointerTons4__RobotMileageInfo(soap, NULL, NULL, "ns4:RobotMileageInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotYunTaiInfo:
		return soap_in_PointerTons4__RobotYunTaiInfo(soap, NULL, NULL, "ns4:RobotYunTaiInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotPosInfo:
		return soap_in_PointerTons4__RobotPosInfo(soap, NULL, NULL, "ns4:RobotPosInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotTaskState:
		return soap_in_PointerTons4__RobotTaskState(soap, NULL, NULL, "ns4:RobotTaskState");
	case SOAP_TYPE_TaskData_PointerTons4__SpeedInfo:
		return soap_in_PointerTons4__SpeedInfo(soap, NULL, NULL, "ns4:SpeedInfo");
	case SOAP_TYPE_TaskData_PointerTons4__BatteryInfo:
		return soap_in_PointerTons4__BatteryInfo(soap, NULL, NULL, "ns4:BatteryInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotInfo:
		return soap_in_PointerTons4__RobotInfo(soap, NULL, NULL, "ns4:RobotInfo");
	case SOAP_TYPE_TaskData_PointerTons4__ConnectInfo:
		return soap_in_PointerTons4__ConnectInfo(soap, NULL, NULL, "ns4:ConnectInfo");
	case SOAP_TYPE_TaskData__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_TaskData_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_TaskData_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TaskExcuteInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__TaskExcuteInfos;
			return soap_in_ns4__TaskExcuteInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TaskExcuteInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__TaskExcuteInfo;
			return soap_in_ns4__TaskExcuteInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TaskFinishInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__TaskFinishInfos;
			return soap_in_ns4__TaskFinishInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TaskFinishInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__TaskFinishInfo;
			return soap_in_ns4__TaskFinishInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TaskExcuteData"))
		{	*type = SOAP_TYPE_TaskData_ns4__TaskExcuteData;
			return soap_in_ns4__TaskExcuteData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TaskPathInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__TaskPathInfos;
			return soap_in_ns4__TaskPathInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TaskPathInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__TaskPathInfo;
			return soap_in_ns4__TaskPathInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PatrolPointInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__PatrolPointInfos;
			return soap_in_ns4__PatrolPointInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PatrolPointInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__PatrolPointInfo;
			return soap_in_ns4__PatrolPointInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DockPointInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__DockPointInfos;
			return soap_in_ns4__DockPointInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DockPointInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__DockPointInfo;
			return soap_in_ns4__DockPointInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MapEdgeInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__MapEdgeInfos;
			return soap_in_ns4__MapEdgeInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MapEdgeInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__MapEdgeInfo;
			return soap_in_ns4__MapEdgeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PatrolAreaInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__PatrolAreaInfos;
			return soap_in_ns4__PatrolAreaInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PatrolAreaInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__PatrolAreaInfo;
			return soap_in_ns4__PatrolAreaInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MapAreaInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__MapAreaInfos;
			return soap_in_ns4__MapAreaInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MapAreaInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__MapAreaInfo;
			return soap_in_ns4__MapAreaInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotAlarmInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotAlarmInfos;
			return soap_in_ns4__RobotAlarmInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotAlarmInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotAlarmInfo;
			return soap_in_ns4__RobotAlarmInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotGasInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotGasInfos;
			return soap_in_ns4__RobotGasInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotGasInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotGasInfo;
			return soap_in_ns4__RobotGasInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotMileageInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotMileageInfos;
			return soap_in_ns4__RobotMileageInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotMileageInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotMileageInfo;
			return soap_in_ns4__RobotMileageInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotYunTaiInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos;
			return soap_in_ns4__RobotYunTaiInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotYunTaiInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo;
			return soap_in_ns4__RobotYunTaiInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotPosInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotPosInfos;
			return soap_in_ns4__RobotPosInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotPosInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotPosInfo;
			return soap_in_ns4__RobotPosInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotTaskStates"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotTaskStates;
			return soap_in_ns4__RobotTaskStates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotTaskState"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotTaskState;
			return soap_in_ns4__RobotTaskState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SpeedInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__SpeedInfos;
			return soap_in_ns4__SpeedInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SpeedInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__SpeedInfo;
			return soap_in_ns4__SpeedInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:BatteryInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__BatteryInfos;
			return soap_in_ns4__BatteryInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:BatteryInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__BatteryInfo;
			return soap_in_ns4__BatteryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotInfos;
			return soap_in_ns4__RobotInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__RobotInfo;
			return soap_in_ns4__RobotInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ConnectInfos"))
		{	*type = SOAP_TYPE_TaskData_ns4__ConnectInfos;
			return soap_in_ns4__ConnectInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ConnectInfo"))
		{	*type = SOAP_TYPE_TaskData_ns4__ConnectInfo;
			return soap_in_ns4__ConnectInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_TaskData_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_TaskData_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_TaskData_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_TaskData_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ControlTaskType"))
		{	*type = SOAP_TYPE_TaskData_ns4__ControlTaskType;
			return soap_in_ns4__ControlTaskType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PdControlType"))
		{	*type = SOAP_TYPE_TaskData_ns4__PdControlType;
			return soap_in_ns4__PdControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:LifterControlType"))
		{	*type = SOAP_TYPE_TaskData_ns4__LifterControlType;
			return soap_in_ns4__LifterControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FilrControlType"))
		{	*type = SOAP_TYPE_TaskData_ns4__FilrControlType;
			return soap_in_ns4__FilrControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:WiperControlType"))
		{	*type = SOAP_TYPE_TaskData_ns4__WiperControlType;
			return soap_in_ns4__WiperControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:LightControlType"))
		{	*type = SOAP_TYPE_TaskData_ns4__LightControlType;
			return soap_in_ns4__LightControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CameraControlType"))
		{	*type = SOAP_TYPE_TaskData_ns4__CameraControlType;
			return soap_in_ns4__CameraControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:YuntaiControlType"))
		{	*type = SOAP_TYPE_TaskData_ns4__YuntaiControlType;
			return soap_in_ns4__YuntaiControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_TaskData__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_TaskData_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns4:GetTaskExcuteDataResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse;
			return soap_in__ns4__GetTaskExcuteDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTaskExcuteData"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetTaskExcuteData;
			return soap_in__ns4__GetTaskExcuteData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotControlTaskResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse;
			return soap_in__ns4__RobotControlTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RobotControlTask"))
		{	*type = SOAP_TYPE_TaskData__ns4__RobotControlTask;
			return soap_in__ns4__RobotControlTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetTaskPathInfoResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse;
			return soap_in__ns4__SetTaskPathInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetTaskPathInfo"))
		{	*type = SOAP_TYPE_TaskData__ns4__SetTaskPathInfo;
			return soap_in__ns4__SetTaskPathInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:StartTaskByPointListResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse;
			return soap_in__ns4__StartTaskByPointListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:StartTaskByPointList"))
		{	*type = SOAP_TYPE_TaskData__ns4__StartTaskByPointList;
			return soap_in__ns4__StartTaskByPointList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:StartTaskByPathIdResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse;
			return soap_in__ns4__StartTaskByPathIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:StartTaskByPathId"))
		{	*type = SOAP_TYPE_TaskData__ns4__StartTaskByPathId;
			return soap_in__ns4__StartTaskByPathId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTaskPathInfoResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse;
			return soap_in__ns4__GetTaskPathInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTaskPathInfo"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetTaskPathInfo;
			return soap_in__ns4__GetTaskPathInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetPatrolPointInfoResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse;
			return soap_in__ns4__GetPatrolPointInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetPatrolPointInfo"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo;
			return soap_in__ns4__GetPatrolPointInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetDockPointInfoResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse;
			return soap_in__ns4__GetDockPointInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetDockPointInfo"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetDockPointInfo;
			return soap_in__ns4__GetDockPointInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMapEdgeInfoResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse;
			return soap_in__ns4__GetMapEdgeInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMapEdgeInfo"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo;
			return soap_in__ns4__GetMapEdgeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetPatrolAreaInfoResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse;
			return soap_in__ns4__GetPatrolAreaInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetPatrolAreaInfo"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo;
			return soap_in__ns4__GetPatrolAreaInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMapAreaInfoResponse"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse;
			return soap_in__ns4__GetMapAreaInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMapAreaInfo"))
		{	*type = SOAP_TYPE_TaskData__ns4__GetMapAreaInfo;
			return soap_in__ns4__GetMapAreaInfo(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_TaskData_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_TaskData_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_TaskData_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_TaskData_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_TaskData_ns4__ControlTaskType:
		return soap_out_ns4__ControlTaskType(soap, tag, id, (const enum ns4__ControlTaskType *)ptr, "ns4:ControlTaskType");
	case SOAP_TYPE_TaskData_ns4__PdControlType:
		return soap_out_ns4__PdControlType(soap, tag, id, (const enum ns4__PdControlType *)ptr, "ns4:PdControlType");
	case SOAP_TYPE_TaskData_ns4__LifterControlType:
		return soap_out_ns4__LifterControlType(soap, tag, id, (const enum ns4__LifterControlType *)ptr, "ns4:LifterControlType");
	case SOAP_TYPE_TaskData_ns4__FilrControlType:
		return soap_out_ns4__FilrControlType(soap, tag, id, (const enum ns4__FilrControlType *)ptr, "ns4:FilrControlType");
	case SOAP_TYPE_TaskData_ns4__WiperControlType:
		return soap_out_ns4__WiperControlType(soap, tag, id, (const enum ns4__WiperControlType *)ptr, "ns4:WiperControlType");
	case SOAP_TYPE_TaskData_ns4__LightControlType:
		return soap_out_ns4__LightControlType(soap, tag, id, (const enum ns4__LightControlType *)ptr, "ns4:LightControlType");
	case SOAP_TYPE_TaskData_ns4__CameraControlType:
		return soap_out_ns4__CameraControlType(soap, tag, id, (const enum ns4__CameraControlType *)ptr, "ns4:CameraControlType");
	case SOAP_TYPE_TaskData_ns4__YuntaiControlType:
		return soap_out_ns4__YuntaiControlType(soap, tag, id, (const enum ns4__YuntaiControlType *)ptr, "ns4:YuntaiControlType");
	case SOAP_TYPE_TaskData_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse:
		return ((_ns4__GetTaskExcuteDataResponse *)ptr)->soap_out(soap, "ns4:GetTaskExcuteDataResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetTaskExcuteData:
		return ((_ns4__GetTaskExcuteData *)ptr)->soap_out(soap, "ns4:GetTaskExcuteData", id, NULL);
	case SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse:
		return ((_ns4__RobotControlTaskResponse *)ptr)->soap_out(soap, "ns4:RobotControlTaskResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__RobotControlTask:
		return ((_ns4__RobotControlTask *)ptr)->soap_out(soap, "ns4:RobotControlTask", id, NULL);
	case SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse:
		return ((_ns4__SetTaskPathInfoResponse *)ptr)->soap_out(soap, "ns4:SetTaskPathInfoResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__SetTaskPathInfo:
		return ((_ns4__SetTaskPathInfo *)ptr)->soap_out(soap, "ns4:SetTaskPathInfo", id, NULL);
	case SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse:
		return ((_ns4__StartTaskByPointListResponse *)ptr)->soap_out(soap, "ns4:StartTaskByPointListResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__StartTaskByPointList:
		return ((_ns4__StartTaskByPointList *)ptr)->soap_out(soap, "ns4:StartTaskByPointList", id, NULL);
	case SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse:
		return ((_ns4__StartTaskByPathIdResponse *)ptr)->soap_out(soap, "ns4:StartTaskByPathIdResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__StartTaskByPathId:
		return ((_ns4__StartTaskByPathId *)ptr)->soap_out(soap, "ns4:StartTaskByPathId", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse:
		return ((_ns4__GetTaskPathInfoResponse *)ptr)->soap_out(soap, "ns4:GetTaskPathInfoResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetTaskPathInfo:
		return ((_ns4__GetTaskPathInfo *)ptr)->soap_out(soap, "ns4:GetTaskPathInfo", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse:
		return ((_ns4__GetPatrolPointInfoResponse *)ptr)->soap_out(soap, "ns4:GetPatrolPointInfoResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo:
		return ((_ns4__GetPatrolPointInfo *)ptr)->soap_out(soap, "ns4:GetPatrolPointInfo", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse:
		return ((_ns4__GetDockPointInfoResponse *)ptr)->soap_out(soap, "ns4:GetDockPointInfoResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetDockPointInfo:
		return ((_ns4__GetDockPointInfo *)ptr)->soap_out(soap, "ns4:GetDockPointInfo", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse:
		return ((_ns4__GetMapEdgeInfoResponse *)ptr)->soap_out(soap, "ns4:GetMapEdgeInfoResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo:
		return ((_ns4__GetMapEdgeInfo *)ptr)->soap_out(soap, "ns4:GetMapEdgeInfo", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse:
		return ((_ns4__GetPatrolAreaInfoResponse *)ptr)->soap_out(soap, "ns4:GetPatrolAreaInfoResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo:
		return ((_ns4__GetPatrolAreaInfo *)ptr)->soap_out(soap, "ns4:GetPatrolAreaInfo", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse:
		return ((_ns4__GetMapAreaInfoResponse *)ptr)->soap_out(soap, "ns4:GetMapAreaInfoResponse", id, NULL);
	case SOAP_TYPE_TaskData__ns4__GetMapAreaInfo:
		return ((_ns4__GetMapAreaInfo *)ptr)->soap_out(soap, "ns4:GetMapAreaInfo", id, NULL);
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfos:
		return ((ns4__TaskExcuteInfos *)ptr)->soap_out(soap, tag, id, "ns4:TaskExcuteInfos");
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfo:
		return ((ns4__TaskExcuteInfo *)ptr)->soap_out(soap, tag, id, "ns4:TaskExcuteInfo");
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfos:
		return ((ns4__TaskFinishInfos *)ptr)->soap_out(soap, tag, id, "ns4:TaskFinishInfos");
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfo:
		return ((ns4__TaskFinishInfo *)ptr)->soap_out(soap, tag, id, "ns4:TaskFinishInfo");
	case SOAP_TYPE_TaskData_ns4__TaskExcuteData:
		return ((ns4__TaskExcuteData *)ptr)->soap_out(soap, tag, id, "ns4:TaskExcuteData");
	case SOAP_TYPE_TaskData_ns4__TaskPathInfos:
		return ((ns4__TaskPathInfos *)ptr)->soap_out(soap, tag, id, "ns4:TaskPathInfos");
	case SOAP_TYPE_TaskData_ns4__TaskPathInfo:
		return ((ns4__TaskPathInfo *)ptr)->soap_out(soap, tag, id, "ns4:TaskPathInfo");
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfos:
		return ((ns4__PatrolPointInfos *)ptr)->soap_out(soap, tag, id, "ns4:PatrolPointInfos");
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfo:
		return ((ns4__PatrolPointInfo *)ptr)->soap_out(soap, tag, id, "ns4:PatrolPointInfo");
	case SOAP_TYPE_TaskData_ns4__DockPointInfos:
		return ((ns4__DockPointInfos *)ptr)->soap_out(soap, tag, id, "ns4:DockPointInfos");
	case SOAP_TYPE_TaskData_ns4__DockPointInfo:
		return ((ns4__DockPointInfo *)ptr)->soap_out(soap, tag, id, "ns4:DockPointInfo");
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfos:
		return ((ns4__MapEdgeInfos *)ptr)->soap_out(soap, tag, id, "ns4:MapEdgeInfos");
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfo:
		return ((ns4__MapEdgeInfo *)ptr)->soap_out(soap, tag, id, "ns4:MapEdgeInfo");
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfos:
		return ((ns4__PatrolAreaInfos *)ptr)->soap_out(soap, tag, id, "ns4:PatrolAreaInfos");
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfo:
		return ((ns4__PatrolAreaInfo *)ptr)->soap_out(soap, tag, id, "ns4:PatrolAreaInfo");
	case SOAP_TYPE_TaskData_ns4__MapAreaInfos:
		return ((ns4__MapAreaInfos *)ptr)->soap_out(soap, tag, id, "ns4:MapAreaInfos");
	case SOAP_TYPE_TaskData_ns4__MapAreaInfo:
		return ((ns4__MapAreaInfo *)ptr)->soap_out(soap, tag, id, "ns4:MapAreaInfo");
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfos:
		return ((ns4__RobotAlarmInfos *)ptr)->soap_out(soap, tag, id, "ns4:RobotAlarmInfos");
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfo:
		return ((ns4__RobotAlarmInfo *)ptr)->soap_out(soap, tag, id, "ns4:RobotAlarmInfo");
	case SOAP_TYPE_TaskData_ns4__RobotGasInfos:
		return ((ns4__RobotGasInfos *)ptr)->soap_out(soap, tag, id, "ns4:RobotGasInfos");
	case SOAP_TYPE_TaskData_ns4__RobotGasInfo:
		return ((ns4__RobotGasInfo *)ptr)->soap_out(soap, tag, id, "ns4:RobotGasInfo");
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfos:
		return ((ns4__RobotMileageInfos *)ptr)->soap_out(soap, tag, id, "ns4:RobotMileageInfos");
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfo:
		return ((ns4__RobotMileageInfo *)ptr)->soap_out(soap, tag, id, "ns4:RobotMileageInfo");
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos:
		return ((ns4__RobotYunTaiInfos *)ptr)->soap_out(soap, tag, id, "ns4:RobotYunTaiInfos");
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo:
		return ((ns4__RobotYunTaiInfo *)ptr)->soap_out(soap, tag, id, "ns4:RobotYunTaiInfo");
	case SOAP_TYPE_TaskData_ns4__RobotPosInfos:
		return ((ns4__RobotPosInfos *)ptr)->soap_out(soap, tag, id, "ns4:RobotPosInfos");
	case SOAP_TYPE_TaskData_ns4__RobotPosInfo:
		return ((ns4__RobotPosInfo *)ptr)->soap_out(soap, tag, id, "ns4:RobotPosInfo");
	case SOAP_TYPE_TaskData_ns4__RobotTaskStates:
		return ((ns4__RobotTaskStates *)ptr)->soap_out(soap, tag, id, "ns4:RobotTaskStates");
	case SOAP_TYPE_TaskData_ns4__RobotTaskState:
		return ((ns4__RobotTaskState *)ptr)->soap_out(soap, tag, id, "ns4:RobotTaskState");
	case SOAP_TYPE_TaskData_ns4__SpeedInfos:
		return ((ns4__SpeedInfos *)ptr)->soap_out(soap, tag, id, "ns4:SpeedInfos");
	case SOAP_TYPE_TaskData_ns4__SpeedInfo:
		return ((ns4__SpeedInfo *)ptr)->soap_out(soap, tag, id, "ns4:SpeedInfo");
	case SOAP_TYPE_TaskData_ns4__BatteryInfos:
		return ((ns4__BatteryInfos *)ptr)->soap_out(soap, tag, id, "ns4:BatteryInfos");
	case SOAP_TYPE_TaskData_ns4__BatteryInfo:
		return ((ns4__BatteryInfo *)ptr)->soap_out(soap, tag, id, "ns4:BatteryInfo");
	case SOAP_TYPE_TaskData_ns4__RobotInfos:
		return ((ns4__RobotInfos *)ptr)->soap_out(soap, tag, id, "ns4:RobotInfos");
	case SOAP_TYPE_TaskData_ns4__RobotInfo:
		return ((ns4__RobotInfo *)ptr)->soap_out(soap, tag, id, "ns4:RobotInfo");
	case SOAP_TYPE_TaskData_ns4__ConnectInfos:
		return ((ns4__ConnectInfos *)ptr)->soap_out(soap, tag, id, "ns4:ConnectInfos");
	case SOAP_TYPE_TaskData_ns4__ConnectInfo:
		return ((ns4__ConnectInfo *)ptr)->soap_out(soap, tag, id, "ns4:ConnectInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskExcuteDataResponse:
		return soap_out_PointerTo_ns4__GetTaskExcuteDataResponse(soap, tag, id, (_ns4__GetTaskExcuteDataResponse *const*)ptr, "ns4:GetTaskExcuteDataResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskExcuteData:
		return soap_out_PointerTo_ns4__GetTaskExcuteData(soap, tag, id, (_ns4__GetTaskExcuteData *const*)ptr, "ns4:GetTaskExcuteData");
	case SOAP_TYPE_TaskData_PointerTo_ns4__RobotControlTaskResponse:
		return soap_out_PointerTo_ns4__RobotControlTaskResponse(soap, tag, id, (_ns4__RobotControlTaskResponse *const*)ptr, "ns4:RobotControlTaskResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__RobotControlTask:
		return soap_out_PointerTo_ns4__RobotControlTask(soap, tag, id, (_ns4__RobotControlTask *const*)ptr, "ns4:RobotControlTask");
	case SOAP_TYPE_TaskData_PointerTo_ns4__SetTaskPathInfoResponse:
		return soap_out_PointerTo_ns4__SetTaskPathInfoResponse(soap, tag, id, (_ns4__SetTaskPathInfoResponse *const*)ptr, "ns4:SetTaskPathInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__SetTaskPathInfo:
		return soap_out_PointerTo_ns4__SetTaskPathInfo(soap, tag, id, (_ns4__SetTaskPathInfo *const*)ptr, "ns4:SetTaskPathInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPointListResponse:
		return soap_out_PointerTo_ns4__StartTaskByPointListResponse(soap, tag, id, (_ns4__StartTaskByPointListResponse *const*)ptr, "ns4:StartTaskByPointListResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPointList:
		return soap_out_PointerTo_ns4__StartTaskByPointList(soap, tag, id, (_ns4__StartTaskByPointList *const*)ptr, "ns4:StartTaskByPointList");
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPathIdResponse:
		return soap_out_PointerTo_ns4__StartTaskByPathIdResponse(soap, tag, id, (_ns4__StartTaskByPathIdResponse *const*)ptr, "ns4:StartTaskByPathIdResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPathId:
		return soap_out_PointerTo_ns4__StartTaskByPathId(soap, tag, id, (_ns4__StartTaskByPathId *const*)ptr, "ns4:StartTaskByPathId");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskPathInfoResponse:
		return soap_out_PointerTo_ns4__GetTaskPathInfoResponse(soap, tag, id, (_ns4__GetTaskPathInfoResponse *const*)ptr, "ns4:GetTaskPathInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskPathInfo:
		return soap_out_PointerTo_ns4__GetTaskPathInfo(soap, tag, id, (_ns4__GetTaskPathInfo *const*)ptr, "ns4:GetTaskPathInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolPointInfoResponse:
		return soap_out_PointerTo_ns4__GetPatrolPointInfoResponse(soap, tag, id, (_ns4__GetPatrolPointInfoResponse *const*)ptr, "ns4:GetPatrolPointInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolPointInfo:
		return soap_out_PointerTo_ns4__GetPatrolPointInfo(soap, tag, id, (_ns4__GetPatrolPointInfo *const*)ptr, "ns4:GetPatrolPointInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetDockPointInfoResponse:
		return soap_out_PointerTo_ns4__GetDockPointInfoResponse(soap, tag, id, (_ns4__GetDockPointInfoResponse *const*)ptr, "ns4:GetDockPointInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetDockPointInfo:
		return soap_out_PointerTo_ns4__GetDockPointInfo(soap, tag, id, (_ns4__GetDockPointInfo *const*)ptr, "ns4:GetDockPointInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapEdgeInfoResponse:
		return soap_out_PointerTo_ns4__GetMapEdgeInfoResponse(soap, tag, id, (_ns4__GetMapEdgeInfoResponse *const*)ptr, "ns4:GetMapEdgeInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapEdgeInfo:
		return soap_out_PointerTo_ns4__GetMapEdgeInfo(soap, tag, id, (_ns4__GetMapEdgeInfo *const*)ptr, "ns4:GetMapEdgeInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolAreaInfoResponse:
		return soap_out_PointerTo_ns4__GetPatrolAreaInfoResponse(soap, tag, id, (_ns4__GetPatrolAreaInfoResponse *const*)ptr, "ns4:GetPatrolAreaInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolAreaInfo:
		return soap_out_PointerTo_ns4__GetPatrolAreaInfo(soap, tag, id, (_ns4__GetPatrolAreaInfo *const*)ptr, "ns4:GetPatrolAreaInfo");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapAreaInfoResponse:
		return soap_out_PointerTo_ns4__GetMapAreaInfoResponse(soap, tag, id, (_ns4__GetMapAreaInfoResponse *const*)ptr, "ns4:GetMapAreaInfoResponse");
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapAreaInfo:
		return soap_out_PointerTo_ns4__GetMapAreaInfo(soap, tag, id, (_ns4__GetMapAreaInfo *const*)ptr, "ns4:GetMapAreaInfo");
	case SOAP_TYPE_TaskData_PointerTons4__TaskExcuteData:
		return soap_out_PointerTons4__TaskExcuteData(soap, tag, id, (ns4__TaskExcuteData *const*)ptr, "ns4:TaskExcuteData");
	case SOAP_TYPE_TaskData_PointerTons4__TaskPathInfos:
		return soap_out_PointerTons4__TaskPathInfos(soap, tag, id, (ns4__TaskPathInfos *const*)ptr, "ns4:TaskPathInfos");
	case SOAP_TYPE_TaskData_PointerTons4__PatrolPointInfos:
		return soap_out_PointerTons4__PatrolPointInfos(soap, tag, id, (ns4__PatrolPointInfos *const*)ptr, "ns4:PatrolPointInfos");
	case SOAP_TYPE_TaskData_PointerTons4__DockPointInfos:
		return soap_out_PointerTons4__DockPointInfos(soap, tag, id, (ns4__DockPointInfos *const*)ptr, "ns4:DockPointInfos");
	case SOAP_TYPE_TaskData_PointerTons4__MapEdgeInfos:
		return soap_out_PointerTons4__MapEdgeInfos(soap, tag, id, (ns4__MapEdgeInfos *const*)ptr, "ns4:MapEdgeInfos");
	case SOAP_TYPE_TaskData_PointerTons4__PatrolAreaInfos:
		return soap_out_PointerTons4__PatrolAreaInfos(soap, tag, id, (ns4__PatrolAreaInfos *const*)ptr, "ns4:PatrolAreaInfos");
	case SOAP_TYPE_TaskData_PointerTons4__MapAreaInfos:
		return soap_out_PointerTons4__MapAreaInfos(soap, tag, id, (ns4__MapAreaInfos *const*)ptr, "ns4:MapAreaInfos");
	case SOAP_TYPE_TaskData_PointerTons4__TaskExcuteInfo:
		return soap_out_PointerTons4__TaskExcuteInfo(soap, tag, id, (ns4__TaskExcuteInfo *const*)ptr, "ns4:TaskExcuteInfo");
	case SOAP_TYPE_TaskData_PointerTons4__TaskFinishInfo:
		return soap_out_PointerTons4__TaskFinishInfo(soap, tag, id, (ns4__TaskFinishInfo *const*)ptr, "ns4:TaskFinishInfo");
	case SOAP_TYPE_TaskData_PointerTons4__TaskPathInfo:
		return soap_out_PointerTons4__TaskPathInfo(soap, tag, id, (ns4__TaskPathInfo *const*)ptr, "ns4:TaskPathInfo");
	case SOAP_TYPE_TaskData_PointerTons4__PatrolPointInfo:
		return soap_out_PointerTons4__PatrolPointInfo(soap, tag, id, (ns4__PatrolPointInfo *const*)ptr, "ns4:PatrolPointInfo");
	case SOAP_TYPE_TaskData_PointerTons4__DockPointInfo:
		return soap_out_PointerTons4__DockPointInfo(soap, tag, id, (ns4__DockPointInfo *const*)ptr, "ns4:DockPointInfo");
	case SOAP_TYPE_TaskData_PointerTons4__MapEdgeInfo:
		return soap_out_PointerTons4__MapEdgeInfo(soap, tag, id, (ns4__MapEdgeInfo *const*)ptr, "ns4:MapEdgeInfo");
	case SOAP_TYPE_TaskData_PointerTons4__PatrolAreaInfo:
		return soap_out_PointerTons4__PatrolAreaInfo(soap, tag, id, (ns4__PatrolAreaInfo *const*)ptr, "ns4:PatrolAreaInfo");
	case SOAP_TYPE_TaskData_PointerTons4__MapAreaInfo:
		return soap_out_PointerTons4__MapAreaInfo(soap, tag, id, (ns4__MapAreaInfo *const*)ptr, "ns4:MapAreaInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotAlarmInfo:
		return soap_out_PointerTons4__RobotAlarmInfo(soap, tag, id, (ns4__RobotAlarmInfo *const*)ptr, "ns4:RobotAlarmInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotGasInfo:
		return soap_out_PointerTons4__RobotGasInfo(soap, tag, id, (ns4__RobotGasInfo *const*)ptr, "ns4:RobotGasInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotMileageInfo:
		return soap_out_PointerTons4__RobotMileageInfo(soap, tag, id, (ns4__RobotMileageInfo *const*)ptr, "ns4:RobotMileageInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotYunTaiInfo:
		return soap_out_PointerTons4__RobotYunTaiInfo(soap, tag, id, (ns4__RobotYunTaiInfo *const*)ptr, "ns4:RobotYunTaiInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotPosInfo:
		return soap_out_PointerTons4__RobotPosInfo(soap, tag, id, (ns4__RobotPosInfo *const*)ptr, "ns4:RobotPosInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotTaskState:
		return soap_out_PointerTons4__RobotTaskState(soap, tag, id, (ns4__RobotTaskState *const*)ptr, "ns4:RobotTaskState");
	case SOAP_TYPE_TaskData_PointerTons4__SpeedInfo:
		return soap_out_PointerTons4__SpeedInfo(soap, tag, id, (ns4__SpeedInfo *const*)ptr, "ns4:SpeedInfo");
	case SOAP_TYPE_TaskData_PointerTons4__BatteryInfo:
		return soap_out_PointerTons4__BatteryInfo(soap, tag, id, (ns4__BatteryInfo *const*)ptr, "ns4:BatteryInfo");
	case SOAP_TYPE_TaskData_PointerTons4__RobotInfo:
		return soap_out_PointerTons4__RobotInfo(soap, tag, id, (ns4__RobotInfo *const*)ptr, "ns4:RobotInfo");
	case SOAP_TYPE_TaskData_PointerTons4__ConnectInfo:
		return soap_out_PointerTons4__ConnectInfo(soap, tag, id, (ns4__ConnectInfo *const*)ptr, "ns4:ConnectInfo");
	case SOAP_TYPE_TaskData__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_TaskData_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_TaskData_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse:
		((_ns4__GetTaskExcuteDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetTaskExcuteData:
		((_ns4__GetTaskExcuteData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse:
		((_ns4__RobotControlTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__RobotControlTask:
		((_ns4__RobotControlTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse:
		((_ns4__SetTaskPathInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__SetTaskPathInfo:
		((_ns4__SetTaskPathInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse:
		((_ns4__StartTaskByPointListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__StartTaskByPointList:
		((_ns4__StartTaskByPointList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse:
		((_ns4__StartTaskByPathIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__StartTaskByPathId:
		((_ns4__StartTaskByPathId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse:
		((_ns4__GetTaskPathInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetTaskPathInfo:
		((_ns4__GetTaskPathInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse:
		((_ns4__GetPatrolPointInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo:
		((_ns4__GetPatrolPointInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse:
		((_ns4__GetDockPointInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetDockPointInfo:
		((_ns4__GetDockPointInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse:
		((_ns4__GetMapEdgeInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo:
		((_ns4__GetMapEdgeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse:
		((_ns4__GetPatrolAreaInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo:
		((_ns4__GetPatrolAreaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse:
		((_ns4__GetMapAreaInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData__ns4__GetMapAreaInfo:
		((_ns4__GetMapAreaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfos:
		((ns4__TaskExcuteInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfo:
		((ns4__TaskExcuteInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfos:
		((ns4__TaskFinishInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfo:
		((ns4__TaskFinishInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskExcuteData:
		((ns4__TaskExcuteData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskPathInfos:
		((ns4__TaskPathInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskPathInfo:
		((ns4__TaskPathInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfos:
		((ns4__PatrolPointInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfo:
		((ns4__PatrolPointInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__DockPointInfos:
		((ns4__DockPointInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__DockPointInfo:
		((ns4__DockPointInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfos:
		((ns4__MapEdgeInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfo:
		((ns4__MapEdgeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfos:
		((ns4__PatrolAreaInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfo:
		((ns4__PatrolAreaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__MapAreaInfos:
		((ns4__MapAreaInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__MapAreaInfo:
		((ns4__MapAreaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfos:
		((ns4__RobotAlarmInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfo:
		((ns4__RobotAlarmInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotGasInfos:
		((ns4__RobotGasInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotGasInfo:
		((ns4__RobotGasInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfos:
		((ns4__RobotMileageInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfo:
		((ns4__RobotMileageInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos:
		((ns4__RobotYunTaiInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo:
		((ns4__RobotYunTaiInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotPosInfos:
		((ns4__RobotPosInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotPosInfo:
		((ns4__RobotPosInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotTaskStates:
		((ns4__RobotTaskStates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotTaskState:
		((ns4__RobotTaskState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__SpeedInfos:
		((ns4__SpeedInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__SpeedInfo:
		((ns4__SpeedInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__BatteryInfos:
		((ns4__BatteryInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__BatteryInfo:
		((ns4__BatteryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotInfos:
		((ns4__RobotInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotInfo:
		((ns4__RobotInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__ConnectInfos:
		((ns4__ConnectInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData_ns4__ConnectInfo:
		((ns4__ConnectInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskData___ns1__GetTaskExcuteData:
		soap_serialize___ns1__GetTaskExcuteData(soap, (const struct __ns1__GetTaskExcuteData *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__RobotControlTask:
		soap_serialize___ns1__RobotControlTask(soap, (const struct __ns1__RobotControlTask *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__SetTaskPathInfo:
		soap_serialize___ns1__SetTaskPathInfo(soap, (const struct __ns1__SetTaskPathInfo *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__StartTaskByPointList:
		soap_serialize___ns1__StartTaskByPointList(soap, (const struct __ns1__StartTaskByPointList *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__StartTaskByPathId:
		soap_serialize___ns1__StartTaskByPathId(soap, (const struct __ns1__StartTaskByPathId *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetTaskPathInfo:
		soap_serialize___ns1__GetTaskPathInfo(soap, (const struct __ns1__GetTaskPathInfo *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetPatrolPointInfo:
		soap_serialize___ns1__GetPatrolPointInfo(soap, (const struct __ns1__GetPatrolPointInfo *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetDockPointInfo:
		soap_serialize___ns1__GetDockPointInfo(soap, (const struct __ns1__GetDockPointInfo *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetMapEdgeInfo:
		soap_serialize___ns1__GetMapEdgeInfo(soap, (const struct __ns1__GetMapEdgeInfo *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetPatrolAreaInfo:
		soap_serialize___ns1__GetPatrolAreaInfo(soap, (const struct __ns1__GetPatrolAreaInfo *)ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetMapAreaInfo:
		soap_serialize___ns1__GetMapAreaInfo(soap, (const struct __ns1__GetMapAreaInfo *)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskExcuteDataResponse:
		soap_serialize_PointerTo_ns4__GetTaskExcuteDataResponse(soap, (_ns4__GetTaskExcuteDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskExcuteData:
		soap_serialize_PointerTo_ns4__GetTaskExcuteData(soap, (_ns4__GetTaskExcuteData *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__RobotControlTaskResponse:
		soap_serialize_PointerTo_ns4__RobotControlTaskResponse(soap, (_ns4__RobotControlTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__RobotControlTask:
		soap_serialize_PointerTo_ns4__RobotControlTask(soap, (_ns4__RobotControlTask *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__SetTaskPathInfoResponse:
		soap_serialize_PointerTo_ns4__SetTaskPathInfoResponse(soap, (_ns4__SetTaskPathInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__SetTaskPathInfo:
		soap_serialize_PointerTo_ns4__SetTaskPathInfo(soap, (_ns4__SetTaskPathInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPointListResponse:
		soap_serialize_PointerTo_ns4__StartTaskByPointListResponse(soap, (_ns4__StartTaskByPointListResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPointList:
		soap_serialize_PointerTo_ns4__StartTaskByPointList(soap, (_ns4__StartTaskByPointList *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPathIdResponse:
		soap_serialize_PointerTo_ns4__StartTaskByPathIdResponse(soap, (_ns4__StartTaskByPathIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPathId:
		soap_serialize_PointerTo_ns4__StartTaskByPathId(soap, (_ns4__StartTaskByPathId *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskPathInfoResponse:
		soap_serialize_PointerTo_ns4__GetTaskPathInfoResponse(soap, (_ns4__GetTaskPathInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskPathInfo:
		soap_serialize_PointerTo_ns4__GetTaskPathInfo(soap, (_ns4__GetTaskPathInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolPointInfoResponse:
		soap_serialize_PointerTo_ns4__GetPatrolPointInfoResponse(soap, (_ns4__GetPatrolPointInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolPointInfo:
		soap_serialize_PointerTo_ns4__GetPatrolPointInfo(soap, (_ns4__GetPatrolPointInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetDockPointInfoResponse:
		soap_serialize_PointerTo_ns4__GetDockPointInfoResponse(soap, (_ns4__GetDockPointInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetDockPointInfo:
		soap_serialize_PointerTo_ns4__GetDockPointInfo(soap, (_ns4__GetDockPointInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapEdgeInfoResponse:
		soap_serialize_PointerTo_ns4__GetMapEdgeInfoResponse(soap, (_ns4__GetMapEdgeInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapEdgeInfo:
		soap_serialize_PointerTo_ns4__GetMapEdgeInfo(soap, (_ns4__GetMapEdgeInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolAreaInfoResponse:
		soap_serialize_PointerTo_ns4__GetPatrolAreaInfoResponse(soap, (_ns4__GetPatrolAreaInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolAreaInfo:
		soap_serialize_PointerTo_ns4__GetPatrolAreaInfo(soap, (_ns4__GetPatrolAreaInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapAreaInfoResponse:
		soap_serialize_PointerTo_ns4__GetMapAreaInfoResponse(soap, (_ns4__GetMapAreaInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTo_ns4__GetMapAreaInfo:
		soap_serialize_PointerTo_ns4__GetMapAreaInfo(soap, (_ns4__GetMapAreaInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__TaskExcuteData:
		soap_serialize_PointerTons4__TaskExcuteData(soap, (ns4__TaskExcuteData *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__TaskPathInfos:
		soap_serialize_PointerTons4__TaskPathInfos(soap, (ns4__TaskPathInfos *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__PatrolPointInfos:
		soap_serialize_PointerTons4__PatrolPointInfos(soap, (ns4__PatrolPointInfos *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__DockPointInfos:
		soap_serialize_PointerTons4__DockPointInfos(soap, (ns4__DockPointInfos *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__MapEdgeInfos:
		soap_serialize_PointerTons4__MapEdgeInfos(soap, (ns4__MapEdgeInfos *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__PatrolAreaInfos:
		soap_serialize_PointerTons4__PatrolAreaInfos(soap, (ns4__PatrolAreaInfos *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__MapAreaInfos:
		soap_serialize_PointerTons4__MapAreaInfos(soap, (ns4__MapAreaInfos *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__TaskExcuteInfo:
		soap_serialize_PointerTons4__TaskExcuteInfo(soap, (ns4__TaskExcuteInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__TaskFinishInfo:
		soap_serialize_PointerTons4__TaskFinishInfo(soap, (ns4__TaskFinishInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__TaskPathInfo:
		soap_serialize_PointerTons4__TaskPathInfo(soap, (ns4__TaskPathInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__PatrolPointInfo:
		soap_serialize_PointerTons4__PatrolPointInfo(soap, (ns4__PatrolPointInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__DockPointInfo:
		soap_serialize_PointerTons4__DockPointInfo(soap, (ns4__DockPointInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__MapEdgeInfo:
		soap_serialize_PointerTons4__MapEdgeInfo(soap, (ns4__MapEdgeInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__PatrolAreaInfo:
		soap_serialize_PointerTons4__PatrolAreaInfo(soap, (ns4__PatrolAreaInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__MapAreaInfo:
		soap_serialize_PointerTons4__MapAreaInfo(soap, (ns4__MapAreaInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__RobotAlarmInfo:
		soap_serialize_PointerTons4__RobotAlarmInfo(soap, (ns4__RobotAlarmInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__RobotGasInfo:
		soap_serialize_PointerTons4__RobotGasInfo(soap, (ns4__RobotGasInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__RobotMileageInfo:
		soap_serialize_PointerTons4__RobotMileageInfo(soap, (ns4__RobotMileageInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__RobotYunTaiInfo:
		soap_serialize_PointerTons4__RobotYunTaiInfo(soap, (ns4__RobotYunTaiInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__RobotPosInfo:
		soap_serialize_PointerTons4__RobotPosInfo(soap, (ns4__RobotPosInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__RobotTaskState:
		soap_serialize_PointerTons4__RobotTaskState(soap, (ns4__RobotTaskState *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__SpeedInfo:
		soap_serialize_PointerTons4__SpeedInfo(soap, (ns4__SpeedInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__BatteryInfo:
		soap_serialize_PointerTons4__BatteryInfo(soap, (ns4__BatteryInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__RobotInfo:
		soap_serialize_PointerTons4__RobotInfo(soap, (ns4__RobotInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData_PointerTons4__ConnectInfo:
		soap_serialize_PointerTons4__ConnectInfo(soap, (ns4__ConnectInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskData__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_TaskData_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 TaskData_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_TaskData_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__ConnectInfo:
		return (void*)soap_instantiate_ns4__ConnectInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__ConnectInfos:
		return (void*)soap_instantiate_ns4__ConnectInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotInfo:
		return (void*)soap_instantiate_ns4__RobotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotInfos:
		return (void*)soap_instantiate_ns4__RobotInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__BatteryInfo:
		return (void*)soap_instantiate_ns4__BatteryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__BatteryInfos:
		return (void*)soap_instantiate_ns4__BatteryInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__SpeedInfo:
		return (void*)soap_instantiate_ns4__SpeedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__SpeedInfos:
		return (void*)soap_instantiate_ns4__SpeedInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotTaskState:
		return (void*)soap_instantiate_ns4__RobotTaskState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotTaskStates:
		return (void*)soap_instantiate_ns4__RobotTaskStates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotPosInfo:
		return (void*)soap_instantiate_ns4__RobotPosInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotPosInfos:
		return (void*)soap_instantiate_ns4__RobotPosInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo:
		return (void*)soap_instantiate_ns4__RobotYunTaiInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos:
		return (void*)soap_instantiate_ns4__RobotYunTaiInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfo:
		return (void*)soap_instantiate_ns4__RobotMileageInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfos:
		return (void*)soap_instantiate_ns4__RobotMileageInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotGasInfo:
		return (void*)soap_instantiate_ns4__RobotGasInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotGasInfos:
		return (void*)soap_instantiate_ns4__RobotGasInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfo:
		return (void*)soap_instantiate_ns4__RobotAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfos:
		return (void*)soap_instantiate_ns4__RobotAlarmInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__MapAreaInfo:
		return (void*)soap_instantiate_ns4__MapAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__MapAreaInfos:
		return (void*)soap_instantiate_ns4__MapAreaInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfo:
		return (void*)soap_instantiate_ns4__PatrolAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfos:
		return (void*)soap_instantiate_ns4__PatrolAreaInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfo:
		return (void*)soap_instantiate_ns4__MapEdgeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfos:
		return (void*)soap_instantiate_ns4__MapEdgeInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__DockPointInfo:
		return (void*)soap_instantiate_ns4__DockPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__DockPointInfos:
		return (void*)soap_instantiate_ns4__DockPointInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfo:
		return (void*)soap_instantiate_ns4__PatrolPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfos:
		return (void*)soap_instantiate_ns4__PatrolPointInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__TaskPathInfo:
		return (void*)soap_instantiate_ns4__TaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__TaskPathInfos:
		return (void*)soap_instantiate_ns4__TaskPathInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__TaskExcuteData:
		return (void*)soap_instantiate_ns4__TaskExcuteData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfo:
		return (void*)soap_instantiate_ns4__TaskFinishInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfos:
		return (void*)soap_instantiate_ns4__TaskFinishInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfo:
		return (void*)soap_instantiate_ns4__TaskExcuteInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfos:
		return (void*)soap_instantiate_ns4__TaskExcuteInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetMapAreaInfo:
		return (void*)soap_instantiate__ns4__GetMapAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse:
		return (void*)soap_instantiate__ns4__GetMapAreaInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo:
		return (void*)soap_instantiate__ns4__GetPatrolAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse:
		return (void*)soap_instantiate__ns4__GetPatrolAreaInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo:
		return (void*)soap_instantiate__ns4__GetMapEdgeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse:
		return (void*)soap_instantiate__ns4__GetMapEdgeInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetDockPointInfo:
		return (void*)soap_instantiate__ns4__GetDockPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse:
		return (void*)soap_instantiate__ns4__GetDockPointInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo:
		return (void*)soap_instantiate__ns4__GetPatrolPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse:
		return (void*)soap_instantiate__ns4__GetPatrolPointInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetTaskPathInfo:
		return (void*)soap_instantiate__ns4__GetTaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse:
		return (void*)soap_instantiate__ns4__GetTaskPathInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__StartTaskByPathId:
		return (void*)soap_instantiate__ns4__StartTaskByPathId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse:
		return (void*)soap_instantiate__ns4__StartTaskByPathIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__StartTaskByPointList:
		return (void*)soap_instantiate__ns4__StartTaskByPointList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse:
		return (void*)soap_instantiate__ns4__StartTaskByPointListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__SetTaskPathInfo:
		return (void*)soap_instantiate__ns4__SetTaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse:
		return (void*)soap_instantiate__ns4__SetTaskPathInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__RobotControlTask:
		return (void*)soap_instantiate__ns4__RobotControlTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse:
		return (void*)soap_instantiate__ns4__RobotControlTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetTaskExcuteData:
		return (void*)soap_instantiate__ns4__GetTaskExcuteData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse:
		return (void*)soap_instantiate__ns4__GetTaskExcuteDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__GetMapAreaInfo:
		return (void*)soap_instantiate___ns1__GetMapAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__GetPatrolAreaInfo:
		return (void*)soap_instantiate___ns1__GetPatrolAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__GetMapEdgeInfo:
		return (void*)soap_instantiate___ns1__GetMapEdgeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__GetDockPointInfo:
		return (void*)soap_instantiate___ns1__GetDockPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__GetPatrolPointInfo:
		return (void*)soap_instantiate___ns1__GetPatrolPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__GetTaskPathInfo:
		return (void*)soap_instantiate___ns1__GetTaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__StartTaskByPathId:
		return (void*)soap_instantiate___ns1__StartTaskByPathId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__StartTaskByPointList:
		return (void*)soap_instantiate___ns1__StartTaskByPointList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__SetTaskPathInfo:
		return (void*)soap_instantiate___ns1__SetTaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__RobotControlTask:
		return (void*)soap_instantiate___ns1__RobotControlTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData___ns1__GetTaskExcuteData:
		return (void*)soap_instantiate___ns1__GetTaskExcuteData(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskExcuteInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskFinishInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__TaskFinishInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskPathInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__TaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolPointInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__PatrolPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__DockPointInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__DockPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapEdgeInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__MapEdgeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolAreaInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapAreaInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__MapAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotAlarmInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotGasInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__RobotGasInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotMileageInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__RobotMileageInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotPosInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__RobotPosInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotTaskState:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__RobotTaskState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__SpeedInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__SpeedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__BatteryInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__BatteryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__RobotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__ConnectInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__ConnectInfo(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 TaskData_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_TaskData_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__ConnectInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__ConnectInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__ConnectInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__ConnectInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__ConnectInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__ConnectInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__BatteryInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__BatteryInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__BatteryInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__BatteryInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__BatteryInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__BatteryInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__SpeedInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__SpeedInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__SpeedInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__SpeedInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__SpeedInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__SpeedInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotTaskState:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotTaskState*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotTaskState*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotTaskStates:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotTaskStates*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotTaskStates*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotPosInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotPosInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotPosInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotPosInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotPosInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotPosInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotYunTaiInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotYunTaiInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotYunTaiInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotYunTaiInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotMileageInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotMileageInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotMileageInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotMileageInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotMileageInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotGasInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotGasInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotGasInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotGasInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotGasInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotGasInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotAlarmInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotAlarmInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__RobotAlarmInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__RobotAlarmInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__RobotAlarmInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__MapAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__MapAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__MapAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__MapAreaInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__MapAreaInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__MapAreaInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__PatrolAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__PatrolAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__PatrolAreaInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__PatrolAreaInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__PatrolAreaInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__MapEdgeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__MapEdgeInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__MapEdgeInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__MapEdgeInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__MapEdgeInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__DockPointInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__DockPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__DockPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__DockPointInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__DockPointInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__DockPointInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__PatrolPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__PatrolPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__PatrolPointInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__PatrolPointInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__PatrolPointInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__TaskPathInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__TaskPathInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskPathInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__TaskPathInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__TaskPathInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskExcuteData:
		if (p->size < 0)
			SOAP_DELETE((ns4__TaskExcuteData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__TaskExcuteData*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__TaskFinishInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__TaskFinishInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskFinishInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__TaskFinishInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__TaskFinishInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfo:
		if (p->size < 0)
			SOAP_DELETE((ns4__TaskExcuteInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__TaskExcuteInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_ns4__TaskExcuteInfos:
		if (p->size < 0)
			SOAP_DELETE((ns4__TaskExcuteInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__TaskExcuteInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetMapAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetMapAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetMapAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetMapAreaInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetMapAreaInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetPatrolAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetPatrolAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetPatrolAreaInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetPatrolAreaInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetMapEdgeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetMapEdgeInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetMapEdgeInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetMapEdgeInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetDockPointInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetDockPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetDockPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetDockPointInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetDockPointInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetPatrolPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetPatrolPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetPatrolPointInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetPatrolPointInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetTaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetTaskPathInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetTaskPathInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetTaskPathInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetTaskPathInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__StartTaskByPathId:
		if (p->size < 0)
			SOAP_DELETE((_ns4__StartTaskByPathId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__StartTaskByPathId*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__StartTaskByPathIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__StartTaskByPathIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__StartTaskByPointList:
		if (p->size < 0)
			SOAP_DELETE((_ns4__StartTaskByPointList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__StartTaskByPointList*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__StartTaskByPointListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__StartTaskByPointListResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__SetTaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns4__SetTaskPathInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__SetTaskPathInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__SetTaskPathInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__SetTaskPathInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__RobotControlTask:
		if (p->size < 0)
			SOAP_DELETE((_ns4__RobotControlTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__RobotControlTask*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__RobotControlTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__RobotControlTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetTaskExcuteData:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetTaskExcuteData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetTaskExcuteData*)p->ptr);
		break;
	case SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__GetTaskExcuteDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__GetTaskExcuteDataResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetMapAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetMapAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetMapAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetPatrolAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPatrolAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPatrolAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetMapEdgeInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetMapEdgeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetMapEdgeInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetDockPointInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetDockPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetDockPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetPatrolPointInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPatrolPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPatrolPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetTaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetTaskPathInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetTaskPathInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__StartTaskByPathId:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__StartTaskByPathId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__StartTaskByPathId*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__StartTaskByPointList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__StartTaskByPointList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__StartTaskByPointList*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__SetTaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetTaskPathInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetTaskPathInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__RobotControlTask:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RobotControlTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RobotControlTask*)p->ptr);
		break;
	case SOAP_TYPE_TaskData___ns1__GetTaskExcuteData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetTaskExcuteData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetTaskExcuteData*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskData_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskExcuteInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__TaskExcuteInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__TaskExcuteInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskFinishInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__TaskFinishInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__TaskFinishInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__TaskPathInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__TaskPathInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolPointInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__PatrolPointInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__PatrolPointInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__DockPointInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__DockPointInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__DockPointInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapEdgeInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__MapEdgeInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__MapEdgeInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__PatrolAreaInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__PatrolAreaInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__MapAreaInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__MapAreaInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__RobotAlarmInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__RobotAlarmInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotGasInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__RobotGasInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__RobotGasInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotMileageInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__RobotMileageInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__RobotMileageInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__RobotYunTaiInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__RobotYunTaiInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotPosInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__RobotPosInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__RobotPosInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotTaskState:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__RobotTaskState * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__RobotTaskState * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__SpeedInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__SpeedInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__SpeedInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__BatteryInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__BatteryInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__BatteryInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__RobotInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__RobotInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__ConnectInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__ConnectInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__ConnectInfo * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, TaskData_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, TaskData_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 TaskData_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskExcuteInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__TaskExcuteInfo * >*)p)[len] = *(ns4__TaskExcuteInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskFinishInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__TaskFinishInfo * >*)p)[len] = *(ns4__TaskFinishInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskPathInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__TaskPathInfo * >*)p)[len] = *(ns4__TaskPathInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolPointInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__PatrolPointInfo * >*)p)[len] = *(ns4__PatrolPointInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__DockPointInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__DockPointInfo * >*)p)[len] = *(ns4__DockPointInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapEdgeInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__MapEdgeInfo * >*)p)[len] = *(ns4__MapEdgeInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolAreaInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__PatrolAreaInfo * >*)p)[len] = *(ns4__PatrolAreaInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapAreaInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__MapAreaInfo * >*)p)[len] = *(ns4__MapAreaInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotAlarmInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__RobotAlarmInfo * >*)p)[len] = *(ns4__RobotAlarmInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotGasInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__RobotGasInfo * >*)p)[len] = *(ns4__RobotGasInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotMileageInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__RobotMileageInfo * >*)p)[len] = *(ns4__RobotMileageInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__RobotYunTaiInfo * >*)p)[len] = *(ns4__RobotYunTaiInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotPosInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__RobotPosInfo * >*)p)[len] = *(ns4__RobotPosInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotTaskState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__RobotTaskState * >*)p)[len] = *(ns4__RobotTaskState **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__SpeedInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__SpeedInfo * >*)p)[len] = *(ns4__SpeedInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__BatteryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__BatteryInfo * >*)p)[len] = *(ns4__BatteryInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__RobotInfo * >*)p)[len] = *(ns4__RobotInfo **)q;
		break;
	case SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__ConnectInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskData_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__ConnectInfo * >*)p)[len] = *(ns4__ConnectInfo **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_TaskData_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_TaskData_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_TaskData_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_TaskData_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_TaskData_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_TaskData_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ControlTaskType(struct soap *soap, enum ns4__ControlTaskType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__ControlTaskType
	*a = SOAP_DEFAULT_ns4__ControlTaskType;
#else
	*a = (enum ns4__ControlTaskType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__ControlTaskType[] =
{	{ (long)ns4__ControlTaskType__CancelTask, "CancelTask" },
	{ (long)ns4__ControlTaskType__PauseTask, "PauseTask" },
	{ (long)ns4__ControlTaskType__ResumeTask, "ResumeTask" },
	{ (long)ns4__ControlTaskType__ChargeTask, "ChargeTask" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__ControlTaskType2s(struct soap *soap, enum ns4__ControlTaskType n)
{	const char *s = soap_code_str(soap_codes_ns4__ControlTaskType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ControlTaskType(struct soap *soap, const char *tag, int id, const enum ns4__ControlTaskType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__ControlTaskType), type) || soap_send(soap, soap_ns4__ControlTaskType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__ControlTaskType(struct soap *soap, const char *s, enum ns4__ControlTaskType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__ControlTaskType, s);
	if (map)
		*a = (enum ns4__ControlTaskType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__ControlTaskType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__ControlTaskType * SOAP_FMAC4 soap_in_ns4__ControlTaskType(struct soap *soap, const char *tag, enum ns4__ControlTaskType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__ControlTaskType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__ControlTaskType, sizeof(enum ns4__ControlTaskType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__ControlTaskType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__ControlTaskType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__ControlTaskType, 0, sizeof(enum ns4__ControlTaskType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ControlTaskType(struct soap *soap, const enum ns4__ControlTaskType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__ControlTaskType);
	if (soap_out_ns4__ControlTaskType(soap, tag?tag:"ns4:ControlTaskType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__ControlTaskType * SOAP_FMAC4 soap_get_ns4__ControlTaskType(struct soap *soap, enum ns4__ControlTaskType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ControlTaskType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__PdControlType(struct soap *soap, enum ns4__PdControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__PdControlType
	*a = SOAP_DEFAULT_ns4__PdControlType;
#else
	*a = (enum ns4__PdControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__PdControlType[] =
{	{ (long)ns4__PdControlType__PdForWard, "PdForWard" },
	{ (long)ns4__PdControlType__PdBackWord, "PdBackWord" },
	{ (long)ns4__PdControlType__PdStop, "PdStop" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__PdControlType2s(struct soap *soap, enum ns4__PdControlType n)
{	const char *s = soap_code_str(soap_codes_ns4__PdControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PdControlType(struct soap *soap, const char *tag, int id, const enum ns4__PdControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__PdControlType), type) || soap_send(soap, soap_ns4__PdControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__PdControlType(struct soap *soap, const char *s, enum ns4__PdControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__PdControlType, s);
	if (map)
		*a = (enum ns4__PdControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__PdControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__PdControlType * SOAP_FMAC4 soap_in_ns4__PdControlType(struct soap *soap, const char *tag, enum ns4__PdControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__PdControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__PdControlType, sizeof(enum ns4__PdControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__PdControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__PdControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__PdControlType, 0, sizeof(enum ns4__PdControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__PdControlType(struct soap *soap, const enum ns4__PdControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__PdControlType);
	if (soap_out_ns4__PdControlType(soap, tag?tag:"ns4:PdControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__PdControlType * SOAP_FMAC4 soap_get_ns4__PdControlType(struct soap *soap, enum ns4__PdControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PdControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__LifterControlType(struct soap *soap, enum ns4__LifterControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__LifterControlType
	*a = SOAP_DEFAULT_ns4__LifterControlType;
#else
	*a = (enum ns4__LifterControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__LifterControlType[] =
{	{ (long)ns4__LifterControlType__LifterUp, "LifterUp" },
	{ (long)ns4__LifterControlType__LifterDown, "LifterDown" },
	{ (long)ns4__LifterControlType__LifterStop, "LifterStop" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__LifterControlType2s(struct soap *soap, enum ns4__LifterControlType n)
{	const char *s = soap_code_str(soap_codes_ns4__LifterControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__LifterControlType(struct soap *soap, const char *tag, int id, const enum ns4__LifterControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__LifterControlType), type) || soap_send(soap, soap_ns4__LifterControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__LifterControlType(struct soap *soap, const char *s, enum ns4__LifterControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__LifterControlType, s);
	if (map)
		*a = (enum ns4__LifterControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__LifterControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__LifterControlType * SOAP_FMAC4 soap_in_ns4__LifterControlType(struct soap *soap, const char *tag, enum ns4__LifterControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__LifterControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__LifterControlType, sizeof(enum ns4__LifterControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__LifterControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__LifterControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__LifterControlType, 0, sizeof(enum ns4__LifterControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__LifterControlType(struct soap *soap, const enum ns4__LifterControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__LifterControlType);
	if (soap_out_ns4__LifterControlType(soap, tag?tag:"ns4:LifterControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__LifterControlType * SOAP_FMAC4 soap_get_ns4__LifterControlType(struct soap *soap, enum ns4__LifterControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__LifterControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FilrControlType(struct soap *soap, enum ns4__FilrControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__FilrControlType
	*a = SOAP_DEFAULT_ns4__FilrControlType;
#else
	*a = (enum ns4__FilrControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__FilrControlType[] =
{	{ (long)ns4__FilrControlType__FocusUp, "FocusUp" },
	{ (long)ns4__FilrControlType__FocusDown, "FocusDown" },
	{ (long)ns4__FilrControlType__AutoFocus, "AutoFocus" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__FilrControlType2s(struct soap *soap, enum ns4__FilrControlType n)
{	const char *s = soap_code_str(soap_codes_ns4__FilrControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FilrControlType(struct soap *soap, const char *tag, int id, const enum ns4__FilrControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__FilrControlType), type) || soap_send(soap, soap_ns4__FilrControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__FilrControlType(struct soap *soap, const char *s, enum ns4__FilrControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__FilrControlType, s);
	if (map)
		*a = (enum ns4__FilrControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__FilrControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__FilrControlType * SOAP_FMAC4 soap_in_ns4__FilrControlType(struct soap *soap, const char *tag, enum ns4__FilrControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__FilrControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__FilrControlType, sizeof(enum ns4__FilrControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__FilrControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__FilrControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__FilrControlType, 0, sizeof(enum ns4__FilrControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FilrControlType(struct soap *soap, const enum ns4__FilrControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__FilrControlType);
	if (soap_out_ns4__FilrControlType(soap, tag?tag:"ns4:FilrControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__FilrControlType * SOAP_FMAC4 soap_get_ns4__FilrControlType(struct soap *soap, enum ns4__FilrControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FilrControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__WiperControlType(struct soap *soap, enum ns4__WiperControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__WiperControlType
	*a = SOAP_DEFAULT_ns4__WiperControlType;
#else
	*a = (enum ns4__WiperControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__WiperControlType[] =
{	{ (long)ns4__WiperControlType__WiperOn, "WiperOn" },
	{ (long)ns4__WiperControlType__WiperOff, "WiperOff" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__WiperControlType2s(struct soap *soap, enum ns4__WiperControlType n)
{	const char *s = soap_code_str(soap_codes_ns4__WiperControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__WiperControlType(struct soap *soap, const char *tag, int id, const enum ns4__WiperControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__WiperControlType), type) || soap_send(soap, soap_ns4__WiperControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__WiperControlType(struct soap *soap, const char *s, enum ns4__WiperControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__WiperControlType, s);
	if (map)
		*a = (enum ns4__WiperControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__WiperControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__WiperControlType * SOAP_FMAC4 soap_in_ns4__WiperControlType(struct soap *soap, const char *tag, enum ns4__WiperControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__WiperControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__WiperControlType, sizeof(enum ns4__WiperControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__WiperControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__WiperControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__WiperControlType, 0, sizeof(enum ns4__WiperControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__WiperControlType(struct soap *soap, const enum ns4__WiperControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__WiperControlType);
	if (soap_out_ns4__WiperControlType(soap, tag?tag:"ns4:WiperControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__WiperControlType * SOAP_FMAC4 soap_get_ns4__WiperControlType(struct soap *soap, enum ns4__WiperControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__WiperControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__LightControlType(struct soap *soap, enum ns4__LightControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__LightControlType
	*a = SOAP_DEFAULT_ns4__LightControlType;
#else
	*a = (enum ns4__LightControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__LightControlType[] =
{	{ (long)ns4__LightControlType__LightOn, "LightOn" },
	{ (long)ns4__LightControlType__LightOff, "LightOff" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__LightControlType2s(struct soap *soap, enum ns4__LightControlType n)
{	const char *s = soap_code_str(soap_codes_ns4__LightControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__LightControlType(struct soap *soap, const char *tag, int id, const enum ns4__LightControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__LightControlType), type) || soap_send(soap, soap_ns4__LightControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__LightControlType(struct soap *soap, const char *s, enum ns4__LightControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__LightControlType, s);
	if (map)
		*a = (enum ns4__LightControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__LightControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__LightControlType * SOAP_FMAC4 soap_in_ns4__LightControlType(struct soap *soap, const char *tag, enum ns4__LightControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__LightControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__LightControlType, sizeof(enum ns4__LightControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__LightControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__LightControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__LightControlType, 0, sizeof(enum ns4__LightControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__LightControlType(struct soap *soap, const enum ns4__LightControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__LightControlType);
	if (soap_out_ns4__LightControlType(soap, tag?tag:"ns4:LightControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__LightControlType * SOAP_FMAC4 soap_get_ns4__LightControlType(struct soap *soap, enum ns4__LightControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__LightControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__CameraControlType(struct soap *soap, enum ns4__CameraControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__CameraControlType
	*a = SOAP_DEFAULT_ns4__CameraControlType;
#else
	*a = (enum ns4__CameraControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__CameraControlType[] =
{	{ (long)ns4__CameraControlType__ZoomUp, "ZoomUp" },
	{ (long)ns4__CameraControlType__ZoomUpStop, "ZoomUpStop" },
	{ (long)ns4__CameraControlType__ZoomDown, "ZoomDown" },
	{ (long)ns4__CameraControlType__ZoomDownStop, "ZoomDownStop" },
	{ (long)ns4__CameraControlType__FocusNear, "FocusNear" },
	{ (long)ns4__CameraControlType__FocusNearStop, "FocusNearStop" },
	{ (long)ns4__CameraControlType__FocusFar, "FocusFar" },
	{ (long)ns4__CameraControlType__FocusFarStop, "FocusFarStop" },
	{ (long)ns4__CameraControlType__CameraReset, "CameraReset" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__CameraControlType2s(struct soap *soap, enum ns4__CameraControlType n)
{	const char *s = soap_code_str(soap_codes_ns4__CameraControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CameraControlType(struct soap *soap, const char *tag, int id, const enum ns4__CameraControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__CameraControlType), type) || soap_send(soap, soap_ns4__CameraControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__CameraControlType(struct soap *soap, const char *s, enum ns4__CameraControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__CameraControlType, s);
	if (map)
		*a = (enum ns4__CameraControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__CameraControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__CameraControlType * SOAP_FMAC4 soap_in_ns4__CameraControlType(struct soap *soap, const char *tag, enum ns4__CameraControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__CameraControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__CameraControlType, sizeof(enum ns4__CameraControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__CameraControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__CameraControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__CameraControlType, 0, sizeof(enum ns4__CameraControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__CameraControlType(struct soap *soap, const enum ns4__CameraControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__CameraControlType);
	if (soap_out_ns4__CameraControlType(soap, tag?tag:"ns4:CameraControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__CameraControlType * SOAP_FMAC4 soap_get_ns4__CameraControlType(struct soap *soap, enum ns4__CameraControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CameraControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__YuntaiControlType(struct soap *soap, enum ns4__YuntaiControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__YuntaiControlType
	*a = SOAP_DEFAULT_ns4__YuntaiControlType;
#else
	*a = (enum ns4__YuntaiControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__YuntaiControlType[] =
{	{ (long)ns4__YuntaiControlType__TurnUp, "TurnUp" },
	{ (long)ns4__YuntaiControlType__TurnDown, "TurnDown" },
	{ (long)ns4__YuntaiControlType__TurnLeft, "TurnLeft" },
	{ (long)ns4__YuntaiControlType__TurnRight, "TurnRight" },
	{ (long)ns4__YuntaiControlType__TurnStop, "TurnStop" },
	{ (long)ns4__YuntaiControlType__TurnReset, "TurnReset" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__YuntaiControlType2s(struct soap *soap, enum ns4__YuntaiControlType n)
{	const char *s = soap_code_str(soap_codes_ns4__YuntaiControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__YuntaiControlType(struct soap *soap, const char *tag, int id, const enum ns4__YuntaiControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__YuntaiControlType), type) || soap_send(soap, soap_ns4__YuntaiControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__YuntaiControlType(struct soap *soap, const char *s, enum ns4__YuntaiControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__YuntaiControlType, s);
	if (map)
		*a = (enum ns4__YuntaiControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__YuntaiControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__YuntaiControlType * SOAP_FMAC4 soap_in_ns4__YuntaiControlType(struct soap *soap, const char *tag, enum ns4__YuntaiControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__YuntaiControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__YuntaiControlType, sizeof(enum ns4__YuntaiControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__YuntaiControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__YuntaiControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__YuntaiControlType, 0, sizeof(enum ns4__YuntaiControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__YuntaiControlType(struct soap *soap, const enum ns4__YuntaiControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__YuntaiControlType);
	if (soap_out_ns4__YuntaiControlType(soap, tag?tag:"ns4:YuntaiControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__YuntaiControlType * SOAP_FMAC4 soap_get_ns4__YuntaiControlType(struct soap *soap, enum ns4__YuntaiControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__YuntaiControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_TaskData_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_TaskData_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_TaskData_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_TaskData_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__string, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns4__GetTaskExcuteDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__GetTaskExcuteDataResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns4__GetTaskExcuteDataResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TaskExcuteData(soap, &this->_ns4__GetTaskExcuteDataResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns4__GetTaskExcuteDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetTaskExcuteDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetTaskExcuteDataResponse(struct soap *soap, const char *tag, int id, const _ns4__GetTaskExcuteDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse), type))
		return soap->error;
	if (a->_ns4__GetTaskExcuteDataResponse::Data)
	{	if (soap_out_PointerTons4__TaskExcuteData(soap, "Data", -1, &a->_ns4__GetTaskExcuteDataResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetTaskExcuteDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetTaskExcuteDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetTaskExcuteDataResponse * SOAP_FMAC4 soap_in__ns4__GetTaskExcuteDataResponse(struct soap *soap, const char *tag, _ns4__GetTaskExcuteDataResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetTaskExcuteDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse, sizeof(_ns4__GetTaskExcuteDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetTaskExcuteDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TaskExcuteData(soap, "Data", &(a->_ns4__GetTaskExcuteDataResponse::Data), "ns4:TaskExcuteData"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetTaskExcuteDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse, 0, sizeof(_ns4__GetTaskExcuteDataResponse), 0, soap_copy__ns4__GetTaskExcuteDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetTaskExcuteDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse);
	if (this->soap_out(soap, tag?tag:"ns4:GetTaskExcuteDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetTaskExcuteDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetTaskExcuteDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetTaskExcuteDataResponse * SOAP_FMAC4 soap_get__ns4__GetTaskExcuteDataResponse(struct soap *soap, _ns4__GetTaskExcuteDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetTaskExcuteDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetTaskExcuteDataResponse * SOAP_FMAC2 soap_instantiate__ns4__GetTaskExcuteDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetTaskExcuteDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetTaskExcuteDataResponse);
		if (size)
			*size = sizeof(_ns4__GetTaskExcuteDataResponse);
		((_ns4__GetTaskExcuteDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetTaskExcuteDataResponse, n);
		if (size)
			*size = n * sizeof(_ns4__GetTaskExcuteDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetTaskExcuteDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetTaskExcuteDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetTaskExcuteDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetTaskExcuteDataResponse %p -> %p\n", q, p));
	*(_ns4__GetTaskExcuteDataResponse*)p = *(_ns4__GetTaskExcuteDataResponse*)q;
}

void _ns4__GetTaskExcuteData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns4__GetTaskExcuteData::robotIp);
	/* transient soap skipped */
}

void _ns4__GetTaskExcuteData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns4__GetTaskExcuteData::robotIp);
	/* transient soap skipped */
#endif
}

int _ns4__GetTaskExcuteData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetTaskExcuteData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetTaskExcuteData(struct soap *soap, const char *tag, int id, const _ns4__GetTaskExcuteData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetTaskExcuteData), type))
		return soap->error;
	if (soap_out_std__string(soap, "robotIp", -1, &(a->_ns4__GetTaskExcuteData::robotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetTaskExcuteData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetTaskExcuteData(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetTaskExcuteData * SOAP_FMAC4 soap_in__ns4__GetTaskExcuteData(struct soap *soap, const char *tag, _ns4__GetTaskExcuteData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetTaskExcuteData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetTaskExcuteData, sizeof(_ns4__GetTaskExcuteData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetTaskExcuteData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetTaskExcuteData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "robotIp", &(a->_ns4__GetTaskExcuteData::robotIp), "xsd:string"))
				{	soap_flag_robotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetTaskExcuteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetTaskExcuteData, 0, sizeof(_ns4__GetTaskExcuteData), 0, soap_copy__ns4__GetTaskExcuteData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetTaskExcuteData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetTaskExcuteData);
	if (this->soap_out(soap, tag?tag:"ns4:GetTaskExcuteData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetTaskExcuteData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetTaskExcuteData(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetTaskExcuteData * SOAP_FMAC4 soap_get__ns4__GetTaskExcuteData(struct soap *soap, _ns4__GetTaskExcuteData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetTaskExcuteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetTaskExcuteData * SOAP_FMAC2 soap_instantiate__ns4__GetTaskExcuteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetTaskExcuteData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetTaskExcuteData, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetTaskExcuteData);
		if (size)
			*size = sizeof(_ns4__GetTaskExcuteData);
		((_ns4__GetTaskExcuteData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetTaskExcuteData, n);
		if (size)
			*size = n * sizeof(_ns4__GetTaskExcuteData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetTaskExcuteData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetTaskExcuteData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetTaskExcuteData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetTaskExcuteData %p -> %p\n", q, p));
	*(_ns4__GetTaskExcuteData*)p = *(_ns4__GetTaskExcuteData*)q;
}

void _ns4__RobotControlTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns4__RobotControlTaskResponse::Result);
	/* transient soap skipped */
}

void _ns4__RobotControlTaskResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__RobotControlTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__RobotControlTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__RobotControlTaskResponse(struct soap *soap, const char *tag, int id, const _ns4__RobotControlTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns4__RobotControlTaskResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__RobotControlTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__RobotControlTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__RobotControlTaskResponse * SOAP_FMAC4 soap_in__ns4__RobotControlTaskResponse(struct soap *soap, const char *tag, _ns4__RobotControlTaskResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__RobotControlTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse, sizeof(_ns4__RobotControlTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__RobotControlTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns4__RobotControlTaskResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__RobotControlTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse, 0, sizeof(_ns4__RobotControlTaskResponse), 0, soap_copy__ns4__RobotControlTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__RobotControlTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse);
	if (this->soap_out(soap, tag?tag:"ns4:RobotControlTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__RobotControlTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__RobotControlTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__RobotControlTaskResponse * SOAP_FMAC4 soap_get__ns4__RobotControlTaskResponse(struct soap *soap, _ns4__RobotControlTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__RobotControlTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__RobotControlTaskResponse * SOAP_FMAC2 soap_instantiate__ns4__RobotControlTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__RobotControlTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__RobotControlTaskResponse);
		if (size)
			*size = sizeof(_ns4__RobotControlTaskResponse);
		((_ns4__RobotControlTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__RobotControlTaskResponse, n);
		if (size)
			*size = n * sizeof(_ns4__RobotControlTaskResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__RobotControlTaskResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__RobotControlTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__RobotControlTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__RobotControlTaskResponse %p -> %p\n", q, p));
	*(_ns4__RobotControlTaskResponse*)p = *(_ns4__RobotControlTaskResponse*)q;
}

void _ns4__RobotControlTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ControlTaskType(soap, &this->_ns4__RobotControlTask::Type);
	/* transient soap skipped */
}

void _ns4__RobotControlTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__RobotControlTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__RobotControlTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__RobotControlTask(struct soap *soap, const char *tag, int id, const _ns4__RobotControlTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__RobotControlTask), type))
		return soap->error;
	if (soap_out_ns4__ControlTaskType(soap, "Type", -1, &(a->_ns4__RobotControlTask::Type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__RobotControlTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__RobotControlTask(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__RobotControlTask * SOAP_FMAC4 soap_in__ns4__RobotControlTask(struct soap *soap, const char *tag, _ns4__RobotControlTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__RobotControlTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__RobotControlTask, sizeof(_ns4__RobotControlTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__RobotControlTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__RobotControlTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns4__ControlTaskType(soap, "Type", &(a->_ns4__RobotControlTask::Type), "ns4:ControlTaskType"))
				{	soap_flag_Type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__RobotControlTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__RobotControlTask, 0, sizeof(_ns4__RobotControlTask), 0, soap_copy__ns4__RobotControlTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__RobotControlTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__RobotControlTask);
	if (this->soap_out(soap, tag?tag:"ns4:RobotControlTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__RobotControlTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__RobotControlTask(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__RobotControlTask * SOAP_FMAC4 soap_get__ns4__RobotControlTask(struct soap *soap, _ns4__RobotControlTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__RobotControlTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__RobotControlTask * SOAP_FMAC2 soap_instantiate__ns4__RobotControlTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__RobotControlTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__RobotControlTask, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__RobotControlTask);
		if (size)
			*size = sizeof(_ns4__RobotControlTask);
		((_ns4__RobotControlTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__RobotControlTask, n);
		if (size)
			*size = n * sizeof(_ns4__RobotControlTask);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__RobotControlTask*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__RobotControlTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__RobotControlTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__RobotControlTask %p -> %p\n", q, p));
	*(_ns4__RobotControlTask*)p = *(_ns4__RobotControlTask*)q;
}

void _ns4__SetTaskPathInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns4__SetTaskPathInfoResponse::Result);
	/* transient soap skipped */
}

void _ns4__SetTaskPathInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__SetTaskPathInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__SetTaskPathInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__SetTaskPathInfoResponse(struct soap *soap, const char *tag, int id, const _ns4__SetTaskPathInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns4__SetTaskPathInfoResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__SetTaskPathInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__SetTaskPathInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__SetTaskPathInfoResponse * SOAP_FMAC4 soap_in__ns4__SetTaskPathInfoResponse(struct soap *soap, const char *tag, _ns4__SetTaskPathInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__SetTaskPathInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse, sizeof(_ns4__SetTaskPathInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__SetTaskPathInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns4__SetTaskPathInfoResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__SetTaskPathInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse, 0, sizeof(_ns4__SetTaskPathInfoResponse), 0, soap_copy__ns4__SetTaskPathInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__SetTaskPathInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns4:SetTaskPathInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__SetTaskPathInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__SetTaskPathInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__SetTaskPathInfoResponse * SOAP_FMAC4 soap_get__ns4__SetTaskPathInfoResponse(struct soap *soap, _ns4__SetTaskPathInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__SetTaskPathInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__SetTaskPathInfoResponse * SOAP_FMAC2 soap_instantiate__ns4__SetTaskPathInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__SetTaskPathInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__SetTaskPathInfoResponse);
		if (size)
			*size = sizeof(_ns4__SetTaskPathInfoResponse);
		((_ns4__SetTaskPathInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__SetTaskPathInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns4__SetTaskPathInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__SetTaskPathInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__SetTaskPathInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__SetTaskPathInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__SetTaskPathInfoResponse %p -> %p\n", q, p));
	*(_ns4__SetTaskPathInfoResponse*)p = *(_ns4__SetTaskPathInfoResponse*)q;
}

void _ns4__SetTaskPathInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__SetTaskPathInfo::info = NULL;
	/* transient soap skipped */
}

void _ns4__SetTaskPathInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TaskPathInfo(soap, &this->_ns4__SetTaskPathInfo::info);
	/* transient soap skipped */
#endif
}

int _ns4__SetTaskPathInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__SetTaskPathInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__SetTaskPathInfo(struct soap *soap, const char *tag, int id, const _ns4__SetTaskPathInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__SetTaskPathInfo), type))
		return soap->error;
	if (a->_ns4__SetTaskPathInfo::info)
	{	if (soap_out_PointerTons4__TaskPathInfo(soap, "info", -1, &a->_ns4__SetTaskPathInfo::info, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "info"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__SetTaskPathInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__SetTaskPathInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__SetTaskPathInfo * SOAP_FMAC4 soap_in__ns4__SetTaskPathInfo(struct soap *soap, const char *tag, _ns4__SetTaskPathInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__SetTaskPathInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__SetTaskPathInfo, sizeof(_ns4__SetTaskPathInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__SetTaskPathInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__SetTaskPathInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_info1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TaskPathInfo(soap, "info", &(a->_ns4__SetTaskPathInfo::info), "ns4:TaskPathInfo"))
				{	soap_flag_info1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__SetTaskPathInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__SetTaskPathInfo, 0, sizeof(_ns4__SetTaskPathInfo), 0, soap_copy__ns4__SetTaskPathInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_info1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__SetTaskPathInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__SetTaskPathInfo);
	if (this->soap_out(soap, tag?tag:"ns4:SetTaskPathInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__SetTaskPathInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__SetTaskPathInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__SetTaskPathInfo * SOAP_FMAC4 soap_get__ns4__SetTaskPathInfo(struct soap *soap, _ns4__SetTaskPathInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__SetTaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__SetTaskPathInfo * SOAP_FMAC2 soap_instantiate__ns4__SetTaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__SetTaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__SetTaskPathInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__SetTaskPathInfo);
		if (size)
			*size = sizeof(_ns4__SetTaskPathInfo);
		((_ns4__SetTaskPathInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__SetTaskPathInfo, n);
		if (size)
			*size = n * sizeof(_ns4__SetTaskPathInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__SetTaskPathInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__SetTaskPathInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__SetTaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__SetTaskPathInfo %p -> %p\n", q, p));
	*(_ns4__SetTaskPathInfo*)p = *(_ns4__SetTaskPathInfo*)q;
}

void _ns4__StartTaskByPointListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns4__StartTaskByPointListResponse::Result);
	/* transient soap skipped */
}

void _ns4__StartTaskByPointListResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__StartTaskByPointListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__StartTaskByPointListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__StartTaskByPointListResponse(struct soap *soap, const char *tag, int id, const _ns4__StartTaskByPointListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns4__StartTaskByPointListResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__StartTaskByPointListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__StartTaskByPointListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__StartTaskByPointListResponse * SOAP_FMAC4 soap_in__ns4__StartTaskByPointListResponse(struct soap *soap, const char *tag, _ns4__StartTaskByPointListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__StartTaskByPointListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse, sizeof(_ns4__StartTaskByPointListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__StartTaskByPointListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns4__StartTaskByPointListResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__StartTaskByPointListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse, 0, sizeof(_ns4__StartTaskByPointListResponse), 0, soap_copy__ns4__StartTaskByPointListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__StartTaskByPointListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse);
	if (this->soap_out(soap, tag?tag:"ns4:StartTaskByPointListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__StartTaskByPointListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__StartTaskByPointListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__StartTaskByPointListResponse * SOAP_FMAC4 soap_get__ns4__StartTaskByPointListResponse(struct soap *soap, _ns4__StartTaskByPointListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__StartTaskByPointListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__StartTaskByPointListResponse * SOAP_FMAC2 soap_instantiate__ns4__StartTaskByPointListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__StartTaskByPointListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__StartTaskByPointListResponse);
		if (size)
			*size = sizeof(_ns4__StartTaskByPointListResponse);
		((_ns4__StartTaskByPointListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__StartTaskByPointListResponse, n);
		if (size)
			*size = n * sizeof(_ns4__StartTaskByPointListResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__StartTaskByPointListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__StartTaskByPointListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__StartTaskByPointListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__StartTaskByPointListResponse %p -> %p\n", q, p));
	*(_ns4__StartTaskByPointListResponse*)p = *(_ns4__StartTaskByPointListResponse*)q;
}

void _ns4__StartTaskByPointList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns4__StartTaskByPointList::TaskId);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_ns4__StartTaskByPointList::PointList);
	/* transient soap skipped */
}

void _ns4__StartTaskByPointList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns4__StartTaskByPointList::TaskId);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_ns4__StartTaskByPointList::PointList);
	/* transient soap skipped */
#endif
}

int _ns4__StartTaskByPointList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__StartTaskByPointList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__StartTaskByPointList(struct soap *soap, const char *tag, int id, const _ns4__StartTaskByPointList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__StartTaskByPointList), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->_ns4__StartTaskByPointList::TaskId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->_ns4__StartTaskByPointList::PointList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__StartTaskByPointList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__StartTaskByPointList(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__StartTaskByPointList * SOAP_FMAC4 soap_in__ns4__StartTaskByPointList(struct soap *soap, const char *tag, _ns4__StartTaskByPointList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__StartTaskByPointList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__StartTaskByPointList, sizeof(_ns4__StartTaskByPointList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__StartTaskByPointList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__StartTaskByPointList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->_ns4__StartTaskByPointList::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->_ns4__StartTaskByPointList::PointList), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__StartTaskByPointList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__StartTaskByPointList, 0, sizeof(_ns4__StartTaskByPointList), 0, soap_copy__ns4__StartTaskByPointList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0 || a->_ns4__StartTaskByPointList::PointList.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__StartTaskByPointList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__StartTaskByPointList);
	if (this->soap_out(soap, tag?tag:"ns4:StartTaskByPointList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__StartTaskByPointList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__StartTaskByPointList(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__StartTaskByPointList * SOAP_FMAC4 soap_get__ns4__StartTaskByPointList(struct soap *soap, _ns4__StartTaskByPointList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__StartTaskByPointList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__StartTaskByPointList * SOAP_FMAC2 soap_instantiate__ns4__StartTaskByPointList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__StartTaskByPointList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__StartTaskByPointList, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__StartTaskByPointList);
		if (size)
			*size = sizeof(_ns4__StartTaskByPointList);
		((_ns4__StartTaskByPointList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__StartTaskByPointList, n);
		if (size)
			*size = n * sizeof(_ns4__StartTaskByPointList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__StartTaskByPointList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__StartTaskByPointList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__StartTaskByPointList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__StartTaskByPointList %p -> %p\n", q, p));
	*(_ns4__StartTaskByPointList*)p = *(_ns4__StartTaskByPointList*)q;
}

void _ns4__StartTaskByPathIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns4__StartTaskByPathIdResponse::Result);
	/* transient soap skipped */
}

void _ns4__StartTaskByPathIdResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__StartTaskByPathIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__StartTaskByPathIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__StartTaskByPathIdResponse(struct soap *soap, const char *tag, int id, const _ns4__StartTaskByPathIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse), type))
		return soap->error;
	if (soap_out_int(soap, "Result", -1, &(a->_ns4__StartTaskByPathIdResponse::Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__StartTaskByPathIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__StartTaskByPathIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__StartTaskByPathIdResponse * SOAP_FMAC4 soap_in__ns4__StartTaskByPathIdResponse(struct soap *soap, const char *tag, _ns4__StartTaskByPathIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__StartTaskByPathIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse, sizeof(_ns4__StartTaskByPathIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__StartTaskByPathIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Result", &(a->_ns4__StartTaskByPathIdResponse::Result), "xsd:int"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__StartTaskByPathIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse, 0, sizeof(_ns4__StartTaskByPathIdResponse), 0, soap_copy__ns4__StartTaskByPathIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__StartTaskByPathIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse);
	if (this->soap_out(soap, tag?tag:"ns4:StartTaskByPathIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__StartTaskByPathIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__StartTaskByPathIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__StartTaskByPathIdResponse * SOAP_FMAC4 soap_get__ns4__StartTaskByPathIdResponse(struct soap *soap, _ns4__StartTaskByPathIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__StartTaskByPathIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__StartTaskByPathIdResponse * SOAP_FMAC2 soap_instantiate__ns4__StartTaskByPathIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__StartTaskByPathIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__StartTaskByPathIdResponse);
		if (size)
			*size = sizeof(_ns4__StartTaskByPathIdResponse);
		((_ns4__StartTaskByPathIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__StartTaskByPathIdResponse, n);
		if (size)
			*size = n * sizeof(_ns4__StartTaskByPathIdResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__StartTaskByPathIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__StartTaskByPathIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__StartTaskByPathIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__StartTaskByPathIdResponse %p -> %p\n", q, p));
	*(_ns4__StartTaskByPathIdResponse*)p = *(_ns4__StartTaskByPathIdResponse*)q;
}

void _ns4__StartTaskByPathId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns4__StartTaskByPathId::TaskId);
	soap_default_std__string(soap, &this->_ns4__StartTaskByPathId::TaskPathId);
	/* transient soap skipped */
}

void _ns4__StartTaskByPathId::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns4__StartTaskByPathId::TaskId);
	soap_serialize_std__string(soap, &this->_ns4__StartTaskByPathId::TaskPathId);
	/* transient soap skipped */
#endif
}

int _ns4__StartTaskByPathId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__StartTaskByPathId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__StartTaskByPathId(struct soap *soap, const char *tag, int id, const _ns4__StartTaskByPathId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__StartTaskByPathId), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->_ns4__StartTaskByPathId::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->_ns4__StartTaskByPathId::TaskPathId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__StartTaskByPathId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__StartTaskByPathId(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__StartTaskByPathId * SOAP_FMAC4 soap_in__ns4__StartTaskByPathId(struct soap *soap, const char *tag, _ns4__StartTaskByPathId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__StartTaskByPathId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__StartTaskByPathId, sizeof(_ns4__StartTaskByPathId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__StartTaskByPathId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__StartTaskByPathId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskPathId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->_ns4__StartTaskByPathId::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->_ns4__StartTaskByPathId::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__StartTaskByPathId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__StartTaskByPathId, 0, sizeof(_ns4__StartTaskByPathId), 0, soap_copy__ns4__StartTaskByPathId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0 || soap_flag_TaskPathId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__StartTaskByPathId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__StartTaskByPathId);
	if (this->soap_out(soap, tag?tag:"ns4:StartTaskByPathId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__StartTaskByPathId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__StartTaskByPathId(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__StartTaskByPathId * SOAP_FMAC4 soap_get__ns4__StartTaskByPathId(struct soap *soap, _ns4__StartTaskByPathId *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__StartTaskByPathId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__StartTaskByPathId * SOAP_FMAC2 soap_instantiate__ns4__StartTaskByPathId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__StartTaskByPathId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__StartTaskByPathId, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__StartTaskByPathId);
		if (size)
			*size = sizeof(_ns4__StartTaskByPathId);
		((_ns4__StartTaskByPathId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__StartTaskByPathId, n);
		if (size)
			*size = n * sizeof(_ns4__StartTaskByPathId);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__StartTaskByPathId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__StartTaskByPathId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__StartTaskByPathId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__StartTaskByPathId %p -> %p\n", q, p));
	*(_ns4__StartTaskByPathId*)p = *(_ns4__StartTaskByPathId*)q;
}

void _ns4__GetTaskPathInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__GetTaskPathInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns4__GetTaskPathInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TaskPathInfos(soap, &this->_ns4__GetTaskPathInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns4__GetTaskPathInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetTaskPathInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetTaskPathInfoResponse(struct soap *soap, const char *tag, int id, const _ns4__GetTaskPathInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse), type))
		return soap->error;
	if (a->_ns4__GetTaskPathInfoResponse::Data)
	{	if (soap_out_PointerTons4__TaskPathInfos(soap, "Data", -1, &a->_ns4__GetTaskPathInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetTaskPathInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetTaskPathInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetTaskPathInfoResponse * SOAP_FMAC4 soap_in__ns4__GetTaskPathInfoResponse(struct soap *soap, const char *tag, _ns4__GetTaskPathInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetTaskPathInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse, sizeof(_ns4__GetTaskPathInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetTaskPathInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TaskPathInfos(soap, "Data", &(a->_ns4__GetTaskPathInfoResponse::Data), "ns4:TaskPathInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetTaskPathInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse, 0, sizeof(_ns4__GetTaskPathInfoResponse), 0, soap_copy__ns4__GetTaskPathInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetTaskPathInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns4:GetTaskPathInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetTaskPathInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetTaskPathInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetTaskPathInfoResponse * SOAP_FMAC4 soap_get__ns4__GetTaskPathInfoResponse(struct soap *soap, _ns4__GetTaskPathInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetTaskPathInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetTaskPathInfoResponse * SOAP_FMAC2 soap_instantiate__ns4__GetTaskPathInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetTaskPathInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetTaskPathInfoResponse);
		if (size)
			*size = sizeof(_ns4__GetTaskPathInfoResponse);
		((_ns4__GetTaskPathInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetTaskPathInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns4__GetTaskPathInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetTaskPathInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetTaskPathInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetTaskPathInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetTaskPathInfoResponse %p -> %p\n", q, p));
	*(_ns4__GetTaskPathInfoResponse*)p = *(_ns4__GetTaskPathInfoResponse*)q;
}

void _ns4__GetTaskPathInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__GetTaskPathInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__GetTaskPathInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetTaskPathInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetTaskPathInfo(struct soap *soap, const char *tag, int id, const _ns4__GetTaskPathInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetTaskPathInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetTaskPathInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetTaskPathInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetTaskPathInfo * SOAP_FMAC4 soap_in__ns4__GetTaskPathInfo(struct soap *soap, const char *tag, _ns4__GetTaskPathInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetTaskPathInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetTaskPathInfo, sizeof(_ns4__GetTaskPathInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetTaskPathInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetTaskPathInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetTaskPathInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetTaskPathInfo, 0, sizeof(_ns4__GetTaskPathInfo), 0, soap_copy__ns4__GetTaskPathInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__GetTaskPathInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetTaskPathInfo);
	if (this->soap_out(soap, tag?tag:"ns4:GetTaskPathInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetTaskPathInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetTaskPathInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetTaskPathInfo * SOAP_FMAC4 soap_get__ns4__GetTaskPathInfo(struct soap *soap, _ns4__GetTaskPathInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetTaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetTaskPathInfo * SOAP_FMAC2 soap_instantiate__ns4__GetTaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetTaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetTaskPathInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetTaskPathInfo);
		if (size)
			*size = sizeof(_ns4__GetTaskPathInfo);
		((_ns4__GetTaskPathInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetTaskPathInfo, n);
		if (size)
			*size = n * sizeof(_ns4__GetTaskPathInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetTaskPathInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetTaskPathInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetTaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetTaskPathInfo %p -> %p\n", q, p));
	*(_ns4__GetTaskPathInfo*)p = *(_ns4__GetTaskPathInfo*)q;
}

void _ns4__GetPatrolPointInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__GetPatrolPointInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns4__GetPatrolPointInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PatrolPointInfos(soap, &this->_ns4__GetPatrolPointInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns4__GetPatrolPointInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetPatrolPointInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetPatrolPointInfoResponse(struct soap *soap, const char *tag, int id, const _ns4__GetPatrolPointInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse), type))
		return soap->error;
	if (a->_ns4__GetPatrolPointInfoResponse::Data)
	{	if (soap_out_PointerTons4__PatrolPointInfos(soap, "Data", -1, &a->_ns4__GetPatrolPointInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetPatrolPointInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetPatrolPointInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetPatrolPointInfoResponse * SOAP_FMAC4 soap_in__ns4__GetPatrolPointInfoResponse(struct soap *soap, const char *tag, _ns4__GetPatrolPointInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetPatrolPointInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse, sizeof(_ns4__GetPatrolPointInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetPatrolPointInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PatrolPointInfos(soap, "Data", &(a->_ns4__GetPatrolPointInfoResponse::Data), "ns4:PatrolPointInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetPatrolPointInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse, 0, sizeof(_ns4__GetPatrolPointInfoResponse), 0, soap_copy__ns4__GetPatrolPointInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetPatrolPointInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns4:GetPatrolPointInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetPatrolPointInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetPatrolPointInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetPatrolPointInfoResponse * SOAP_FMAC4 soap_get__ns4__GetPatrolPointInfoResponse(struct soap *soap, _ns4__GetPatrolPointInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetPatrolPointInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetPatrolPointInfoResponse * SOAP_FMAC2 soap_instantiate__ns4__GetPatrolPointInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetPatrolPointInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetPatrolPointInfoResponse);
		if (size)
			*size = sizeof(_ns4__GetPatrolPointInfoResponse);
		((_ns4__GetPatrolPointInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetPatrolPointInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns4__GetPatrolPointInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetPatrolPointInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetPatrolPointInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetPatrolPointInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetPatrolPointInfoResponse %p -> %p\n", q, p));
	*(_ns4__GetPatrolPointInfoResponse*)p = *(_ns4__GetPatrolPointInfoResponse*)q;
}

void _ns4__GetPatrolPointInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__GetPatrolPointInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__GetPatrolPointInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetPatrolPointInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetPatrolPointInfo(struct soap *soap, const char *tag, int id, const _ns4__GetPatrolPointInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetPatrolPointInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetPatrolPointInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetPatrolPointInfo * SOAP_FMAC4 soap_in__ns4__GetPatrolPointInfo(struct soap *soap, const char *tag, _ns4__GetPatrolPointInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetPatrolPointInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo, sizeof(_ns4__GetPatrolPointInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetPatrolPointInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetPatrolPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo, 0, sizeof(_ns4__GetPatrolPointInfo), 0, soap_copy__ns4__GetPatrolPointInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__GetPatrolPointInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo);
	if (this->soap_out(soap, tag?tag:"ns4:GetPatrolPointInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetPatrolPointInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetPatrolPointInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetPatrolPointInfo * SOAP_FMAC4 soap_get__ns4__GetPatrolPointInfo(struct soap *soap, _ns4__GetPatrolPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetPatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetPatrolPointInfo * SOAP_FMAC2 soap_instantiate__ns4__GetPatrolPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetPatrolPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetPatrolPointInfo);
		if (size)
			*size = sizeof(_ns4__GetPatrolPointInfo);
		((_ns4__GetPatrolPointInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetPatrolPointInfo, n);
		if (size)
			*size = n * sizeof(_ns4__GetPatrolPointInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetPatrolPointInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetPatrolPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetPatrolPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetPatrolPointInfo %p -> %p\n", q, p));
	*(_ns4__GetPatrolPointInfo*)p = *(_ns4__GetPatrolPointInfo*)q;
}

void _ns4__GetDockPointInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__GetDockPointInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns4__GetDockPointInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__DockPointInfos(soap, &this->_ns4__GetDockPointInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns4__GetDockPointInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetDockPointInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetDockPointInfoResponse(struct soap *soap, const char *tag, int id, const _ns4__GetDockPointInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse), type))
		return soap->error;
	if (a->_ns4__GetDockPointInfoResponse::Data)
	{	if (soap_out_PointerTons4__DockPointInfos(soap, "Data", -1, &a->_ns4__GetDockPointInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetDockPointInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetDockPointInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetDockPointInfoResponse * SOAP_FMAC4 soap_in__ns4__GetDockPointInfoResponse(struct soap *soap, const char *tag, _ns4__GetDockPointInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetDockPointInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse, sizeof(_ns4__GetDockPointInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetDockPointInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DockPointInfos(soap, "Data", &(a->_ns4__GetDockPointInfoResponse::Data), "ns4:DockPointInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetDockPointInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse, 0, sizeof(_ns4__GetDockPointInfoResponse), 0, soap_copy__ns4__GetDockPointInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetDockPointInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns4:GetDockPointInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetDockPointInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetDockPointInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetDockPointInfoResponse * SOAP_FMAC4 soap_get__ns4__GetDockPointInfoResponse(struct soap *soap, _ns4__GetDockPointInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetDockPointInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetDockPointInfoResponse * SOAP_FMAC2 soap_instantiate__ns4__GetDockPointInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetDockPointInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetDockPointInfoResponse);
		if (size)
			*size = sizeof(_ns4__GetDockPointInfoResponse);
		((_ns4__GetDockPointInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetDockPointInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns4__GetDockPointInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetDockPointInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetDockPointInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetDockPointInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetDockPointInfoResponse %p -> %p\n", q, p));
	*(_ns4__GetDockPointInfoResponse*)p = *(_ns4__GetDockPointInfoResponse*)q;
}

void _ns4__GetDockPointInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__GetDockPointInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__GetDockPointInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetDockPointInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetDockPointInfo(struct soap *soap, const char *tag, int id, const _ns4__GetDockPointInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetDockPointInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetDockPointInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetDockPointInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetDockPointInfo * SOAP_FMAC4 soap_in__ns4__GetDockPointInfo(struct soap *soap, const char *tag, _ns4__GetDockPointInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetDockPointInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetDockPointInfo, sizeof(_ns4__GetDockPointInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetDockPointInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetDockPointInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetDockPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetDockPointInfo, 0, sizeof(_ns4__GetDockPointInfo), 0, soap_copy__ns4__GetDockPointInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__GetDockPointInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetDockPointInfo);
	if (this->soap_out(soap, tag?tag:"ns4:GetDockPointInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetDockPointInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetDockPointInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetDockPointInfo * SOAP_FMAC4 soap_get__ns4__GetDockPointInfo(struct soap *soap, _ns4__GetDockPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetDockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetDockPointInfo * SOAP_FMAC2 soap_instantiate__ns4__GetDockPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetDockPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetDockPointInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetDockPointInfo);
		if (size)
			*size = sizeof(_ns4__GetDockPointInfo);
		((_ns4__GetDockPointInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetDockPointInfo, n);
		if (size)
			*size = n * sizeof(_ns4__GetDockPointInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetDockPointInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetDockPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetDockPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetDockPointInfo %p -> %p\n", q, p));
	*(_ns4__GetDockPointInfo*)p = *(_ns4__GetDockPointInfo*)q;
}

void _ns4__GetMapEdgeInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__GetMapEdgeInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns4__GetMapEdgeInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__MapEdgeInfos(soap, &this->_ns4__GetMapEdgeInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns4__GetMapEdgeInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetMapEdgeInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetMapEdgeInfoResponse(struct soap *soap, const char *tag, int id, const _ns4__GetMapEdgeInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse), type))
		return soap->error;
	if (a->_ns4__GetMapEdgeInfoResponse::Data)
	{	if (soap_out_PointerTons4__MapEdgeInfos(soap, "Data", -1, &a->_ns4__GetMapEdgeInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetMapEdgeInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetMapEdgeInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetMapEdgeInfoResponse * SOAP_FMAC4 soap_in__ns4__GetMapEdgeInfoResponse(struct soap *soap, const char *tag, _ns4__GetMapEdgeInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetMapEdgeInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse, sizeof(_ns4__GetMapEdgeInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetMapEdgeInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__MapEdgeInfos(soap, "Data", &(a->_ns4__GetMapEdgeInfoResponse::Data), "ns4:MapEdgeInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetMapEdgeInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse, 0, sizeof(_ns4__GetMapEdgeInfoResponse), 0, soap_copy__ns4__GetMapEdgeInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetMapEdgeInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns4:GetMapEdgeInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetMapEdgeInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetMapEdgeInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetMapEdgeInfoResponse * SOAP_FMAC4 soap_get__ns4__GetMapEdgeInfoResponse(struct soap *soap, _ns4__GetMapEdgeInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetMapEdgeInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetMapEdgeInfoResponse * SOAP_FMAC2 soap_instantiate__ns4__GetMapEdgeInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetMapEdgeInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetMapEdgeInfoResponse);
		if (size)
			*size = sizeof(_ns4__GetMapEdgeInfoResponse);
		((_ns4__GetMapEdgeInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetMapEdgeInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns4__GetMapEdgeInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetMapEdgeInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetMapEdgeInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetMapEdgeInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetMapEdgeInfoResponse %p -> %p\n", q, p));
	*(_ns4__GetMapEdgeInfoResponse*)p = *(_ns4__GetMapEdgeInfoResponse*)q;
}

void _ns4__GetMapEdgeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns4__GetMapEdgeInfo::AreaId);
	/* transient soap skipped */
}

void _ns4__GetMapEdgeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns4__GetMapEdgeInfo::AreaId);
	/* transient soap skipped */
#endif
}

int _ns4__GetMapEdgeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetMapEdgeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetMapEdgeInfo(struct soap *soap, const char *tag, int id, const _ns4__GetMapEdgeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->_ns4__GetMapEdgeInfo::AreaId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetMapEdgeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetMapEdgeInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetMapEdgeInfo * SOAP_FMAC4 soap_in__ns4__GetMapEdgeInfo(struct soap *soap, const char *tag, _ns4__GetMapEdgeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetMapEdgeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo, sizeof(_ns4__GetMapEdgeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetMapEdgeInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AreaId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->_ns4__GetMapEdgeInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetMapEdgeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo, 0, sizeof(_ns4__GetMapEdgeInfo), 0, soap_copy__ns4__GetMapEdgeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AreaId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetMapEdgeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo);
	if (this->soap_out(soap, tag?tag:"ns4:GetMapEdgeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetMapEdgeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetMapEdgeInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetMapEdgeInfo * SOAP_FMAC4 soap_get__ns4__GetMapEdgeInfo(struct soap *soap, _ns4__GetMapEdgeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetMapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetMapEdgeInfo * SOAP_FMAC2 soap_instantiate__ns4__GetMapEdgeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetMapEdgeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetMapEdgeInfo);
		if (size)
			*size = sizeof(_ns4__GetMapEdgeInfo);
		((_ns4__GetMapEdgeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetMapEdgeInfo, n);
		if (size)
			*size = n * sizeof(_ns4__GetMapEdgeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetMapEdgeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetMapEdgeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetMapEdgeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetMapEdgeInfo %p -> %p\n", q, p));
	*(_ns4__GetMapEdgeInfo*)p = *(_ns4__GetMapEdgeInfo*)q;
}

void _ns4__GetPatrolAreaInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__GetPatrolAreaInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns4__GetPatrolAreaInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PatrolAreaInfos(soap, &this->_ns4__GetPatrolAreaInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns4__GetPatrolAreaInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetPatrolAreaInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetPatrolAreaInfoResponse(struct soap *soap, const char *tag, int id, const _ns4__GetPatrolAreaInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse), type))
		return soap->error;
	if (a->_ns4__GetPatrolAreaInfoResponse::Data)
	{	if (soap_out_PointerTons4__PatrolAreaInfos(soap, "Data", -1, &a->_ns4__GetPatrolAreaInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetPatrolAreaInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetPatrolAreaInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetPatrolAreaInfoResponse * SOAP_FMAC4 soap_in__ns4__GetPatrolAreaInfoResponse(struct soap *soap, const char *tag, _ns4__GetPatrolAreaInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetPatrolAreaInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse, sizeof(_ns4__GetPatrolAreaInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetPatrolAreaInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PatrolAreaInfos(soap, "Data", &(a->_ns4__GetPatrolAreaInfoResponse::Data), "ns4:PatrolAreaInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetPatrolAreaInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse, 0, sizeof(_ns4__GetPatrolAreaInfoResponse), 0, soap_copy__ns4__GetPatrolAreaInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetPatrolAreaInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns4:GetPatrolAreaInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetPatrolAreaInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetPatrolAreaInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetPatrolAreaInfoResponse * SOAP_FMAC4 soap_get__ns4__GetPatrolAreaInfoResponse(struct soap *soap, _ns4__GetPatrolAreaInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetPatrolAreaInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetPatrolAreaInfoResponse * SOAP_FMAC2 soap_instantiate__ns4__GetPatrolAreaInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetPatrolAreaInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetPatrolAreaInfoResponse);
		if (size)
			*size = sizeof(_ns4__GetPatrolAreaInfoResponse);
		((_ns4__GetPatrolAreaInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetPatrolAreaInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns4__GetPatrolAreaInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetPatrolAreaInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetPatrolAreaInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetPatrolAreaInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetPatrolAreaInfoResponse %p -> %p\n", q, p));
	*(_ns4__GetPatrolAreaInfoResponse*)p = *(_ns4__GetPatrolAreaInfoResponse*)q;
}

void _ns4__GetPatrolAreaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__GetPatrolAreaInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__GetPatrolAreaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetPatrolAreaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetPatrolAreaInfo(struct soap *soap, const char *tag, int id, const _ns4__GetPatrolAreaInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetPatrolAreaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetPatrolAreaInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetPatrolAreaInfo * SOAP_FMAC4 soap_in__ns4__GetPatrolAreaInfo(struct soap *soap, const char *tag, _ns4__GetPatrolAreaInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetPatrolAreaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo, sizeof(_ns4__GetPatrolAreaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetPatrolAreaInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetPatrolAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo, 0, sizeof(_ns4__GetPatrolAreaInfo), 0, soap_copy__ns4__GetPatrolAreaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__GetPatrolAreaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo);
	if (this->soap_out(soap, tag?tag:"ns4:GetPatrolAreaInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetPatrolAreaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetPatrolAreaInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetPatrolAreaInfo * SOAP_FMAC4 soap_get__ns4__GetPatrolAreaInfo(struct soap *soap, _ns4__GetPatrolAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetPatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetPatrolAreaInfo * SOAP_FMAC2 soap_instantiate__ns4__GetPatrolAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetPatrolAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetPatrolAreaInfo);
		if (size)
			*size = sizeof(_ns4__GetPatrolAreaInfo);
		((_ns4__GetPatrolAreaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetPatrolAreaInfo, n);
		if (size)
			*size = n * sizeof(_ns4__GetPatrolAreaInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetPatrolAreaInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetPatrolAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetPatrolAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetPatrolAreaInfo %p -> %p\n", q, p));
	*(_ns4__GetPatrolAreaInfo*)p = *(_ns4__GetPatrolAreaInfo*)q;
}

void _ns4__GetMapAreaInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__GetMapAreaInfoResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns4__GetMapAreaInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__MapAreaInfos(soap, &this->_ns4__GetMapAreaInfoResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns4__GetMapAreaInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetMapAreaInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetMapAreaInfoResponse(struct soap *soap, const char *tag, int id, const _ns4__GetMapAreaInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse), type))
		return soap->error;
	if (a->_ns4__GetMapAreaInfoResponse::Data)
	{	if (soap_out_PointerTons4__MapAreaInfos(soap, "Data", -1, &a->_ns4__GetMapAreaInfoResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetMapAreaInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetMapAreaInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetMapAreaInfoResponse * SOAP_FMAC4 soap_in__ns4__GetMapAreaInfoResponse(struct soap *soap, const char *tag, _ns4__GetMapAreaInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetMapAreaInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse, sizeof(_ns4__GetMapAreaInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetMapAreaInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__MapAreaInfos(soap, "Data", &(a->_ns4__GetMapAreaInfoResponse::Data), "ns4:MapAreaInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetMapAreaInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse, 0, sizeof(_ns4__GetMapAreaInfoResponse), 0, soap_copy__ns4__GetMapAreaInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__GetMapAreaInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns4:GetMapAreaInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetMapAreaInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetMapAreaInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetMapAreaInfoResponse * SOAP_FMAC4 soap_get__ns4__GetMapAreaInfoResponse(struct soap *soap, _ns4__GetMapAreaInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetMapAreaInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetMapAreaInfoResponse * SOAP_FMAC2 soap_instantiate__ns4__GetMapAreaInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetMapAreaInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetMapAreaInfoResponse);
		if (size)
			*size = sizeof(_ns4__GetMapAreaInfoResponse);
		((_ns4__GetMapAreaInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetMapAreaInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns4__GetMapAreaInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetMapAreaInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetMapAreaInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetMapAreaInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetMapAreaInfoResponse %p -> %p\n", q, p));
	*(_ns4__GetMapAreaInfoResponse*)p = *(_ns4__GetMapAreaInfoResponse*)q;
}

void _ns4__GetMapAreaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns4__GetMapAreaInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns4__GetMapAreaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__GetMapAreaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetMapAreaInfo(struct soap *soap, const char *tag, int id, const _ns4__GetMapAreaInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData__ns4__GetMapAreaInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__GetMapAreaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__GetMapAreaInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__GetMapAreaInfo * SOAP_FMAC4 soap_in__ns4__GetMapAreaInfo(struct soap *soap, const char *tag, _ns4__GetMapAreaInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__GetMapAreaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData__ns4__GetMapAreaInfo, sizeof(_ns4__GetMapAreaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData__ns4__GetMapAreaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__GetMapAreaInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__GetMapAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData__ns4__GetMapAreaInfo, 0, sizeof(_ns4__GetMapAreaInfo), 0, soap_copy__ns4__GetMapAreaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns4__GetMapAreaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData__ns4__GetMapAreaInfo);
	if (this->soap_out(soap, tag?tag:"ns4:GetMapAreaInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__GetMapAreaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__GetMapAreaInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__GetMapAreaInfo * SOAP_FMAC4 soap_get__ns4__GetMapAreaInfo(struct soap *soap, _ns4__GetMapAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetMapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__GetMapAreaInfo * SOAP_FMAC2 soap_instantiate__ns4__GetMapAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__GetMapAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData__ns4__GetMapAreaInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__GetMapAreaInfo);
		if (size)
			*size = sizeof(_ns4__GetMapAreaInfo);
		((_ns4__GetMapAreaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns4__GetMapAreaInfo, n);
		if (size)
			*size = n * sizeof(_ns4__GetMapAreaInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns4__GetMapAreaInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns4__GetMapAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__GetMapAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__GetMapAreaInfo %p -> %p\n", q, p));
	*(_ns4__GetMapAreaInfo*)p = *(_ns4__GetMapAreaInfo*)q;
}

void ns4__TaskExcuteInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(soap, &this->ns4__TaskExcuteInfos::Infos);
	/* transient soap skipped */
}

void ns4__TaskExcuteInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(soap, &this->ns4__TaskExcuteInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__TaskExcuteInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TaskExcuteInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TaskExcuteInfos(struct soap *soap, const char *tag, int id, const ns4__TaskExcuteInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__TaskExcuteInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(soap, "Infos", -1, &(a->ns4__TaskExcuteInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__TaskExcuteInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TaskExcuteInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TaskExcuteInfos * SOAP_FMAC4 soap_in_ns4__TaskExcuteInfos(struct soap *soap, const char *tag, ns4__TaskExcuteInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TaskExcuteInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__TaskExcuteInfos, sizeof(ns4__TaskExcuteInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__TaskExcuteInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TaskExcuteInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(soap, "Infos", &(a->ns4__TaskExcuteInfos::Infos), "ns4:TaskExcuteInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TaskExcuteInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__TaskExcuteInfos, 0, sizeof(ns4__TaskExcuteInfos), 0, soap_copy_ns4__TaskExcuteInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__TaskExcuteInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__TaskExcuteInfos);
	if (this->soap_out(soap, tag?tag:"ns4:TaskExcuteInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__TaskExcuteInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TaskExcuteInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TaskExcuteInfos * SOAP_FMAC4 soap_get_ns4__TaskExcuteInfos(struct soap *soap, ns4__TaskExcuteInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TaskExcuteInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__TaskExcuteInfos * SOAP_FMAC2 soap_instantiate_ns4__TaskExcuteInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TaskExcuteInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__TaskExcuteInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__TaskExcuteInfos);
		if (size)
			*size = sizeof(ns4__TaskExcuteInfos);
		((ns4__TaskExcuteInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__TaskExcuteInfos, n);
		if (size)
			*size = n * sizeof(ns4__TaskExcuteInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__TaskExcuteInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__TaskExcuteInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TaskExcuteInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TaskExcuteInfos %p -> %p\n", q, p));
	*(ns4__TaskExcuteInfos*)p = *(ns4__TaskExcuteInfos*)q;
}

void ns4__TaskExcuteInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::TaskId);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::TaskName);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::TaskType);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::TaskPathId);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::TargetId);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::PointId);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::PointName);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::PointType);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteTime);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteValue);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteUnit);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteState);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteDesc);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::HDPicture);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::InfraredPicture);
	soap_default_std__string(soap, &this->ns4__TaskExcuteInfo::OtherFile);
	/* transient soap skipped */
}

void ns4__TaskExcuteInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::TaskId);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::TaskName);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::TaskType);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::TaskPathId);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::TargetId);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::PointId);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::PointName);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::PointType);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteTime);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteValue);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteUnit);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteState);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::ExcuteDesc);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::HDPicture);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::InfraredPicture);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteInfo::OtherFile);
	/* transient soap skipped */
#endif
}

int ns4__TaskExcuteInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TaskExcuteInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TaskExcuteInfo(struct soap *soap, const char *tag, int id, const ns4__TaskExcuteInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__TaskExcuteInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns4__TaskExcuteInfo::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns4__TaskExcuteInfo::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns4__TaskExcuteInfo::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns4__TaskExcuteInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TargetId", -1, &(a->ns4__TaskExcuteInfo::TargetId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointId", -1, &(a->ns4__TaskExcuteInfo::PointId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointName", -1, &(a->ns4__TaskExcuteInfo::PointName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointType", -1, &(a->ns4__TaskExcuteInfo::PointType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteTime", -1, &(a->ns4__TaskExcuteInfo::ExcuteTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteValue", -1, &(a->ns4__TaskExcuteInfo::ExcuteValue), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteUnit", -1, &(a->ns4__TaskExcuteInfo::ExcuteUnit), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteState", -1, &(a->ns4__TaskExcuteInfo::ExcuteState), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteDesc", -1, &(a->ns4__TaskExcuteInfo::ExcuteDesc), ""))
		return soap->error;
	if (soap_out_std__string(soap, "HDPicture", -1, &(a->ns4__TaskExcuteInfo::HDPicture), ""))
		return soap->error;
	if (soap_out_std__string(soap, "InfraredPicture", -1, &(a->ns4__TaskExcuteInfo::InfraredPicture), ""))
		return soap->error;
	if (soap_out_std__string(soap, "OtherFile", -1, &(a->ns4__TaskExcuteInfo::OtherFile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__TaskExcuteInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TaskExcuteInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TaskExcuteInfo * SOAP_FMAC4 soap_in_ns4__TaskExcuteInfo(struct soap *soap, const char *tag, ns4__TaskExcuteInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TaskExcuteInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__TaskExcuteInfo, sizeof(ns4__TaskExcuteInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__TaskExcuteInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TaskExcuteInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_TargetId1 = 1;
	size_t soap_flag_PointId1 = 1;
	size_t soap_flag_PointName1 = 1;
	size_t soap_flag_PointType1 = 1;
	size_t soap_flag_ExcuteTime1 = 1;
	size_t soap_flag_ExcuteValue1 = 1;
	size_t soap_flag_ExcuteUnit1 = 1;
	size_t soap_flag_ExcuteState1 = 1;
	size_t soap_flag_ExcuteDesc1 = 1;
	size_t soap_flag_HDPicture1 = 1;
	size_t soap_flag_InfraredPicture1 = 1;
	size_t soap_flag_OtherFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns4__TaskExcuteInfo::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns4__TaskExcuteInfo::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns4__TaskExcuteInfo::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns4__TaskExcuteInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap_flag_TargetId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TargetId", &(a->ns4__TaskExcuteInfo::TargetId), "xsd:string"))
				{	soap_flag_TargetId1--;
					continue;
				}
			if (soap_flag_PointId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointId", &(a->ns4__TaskExcuteInfo::PointId), "xsd:string"))
				{	soap_flag_PointId1--;
					continue;
				}
			if (soap_flag_PointName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointName", &(a->ns4__TaskExcuteInfo::PointName), "xsd:string"))
				{	soap_flag_PointName1--;
					continue;
				}
			if (soap_flag_PointType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointType", &(a->ns4__TaskExcuteInfo::PointType), "xsd:string"))
				{	soap_flag_PointType1--;
					continue;
				}
			if (soap_flag_ExcuteTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteTime", &(a->ns4__TaskExcuteInfo::ExcuteTime), "xsd:string"))
				{	soap_flag_ExcuteTime1--;
					continue;
				}
			if (soap_flag_ExcuteValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteValue", &(a->ns4__TaskExcuteInfo::ExcuteValue), "xsd:string"))
				{	soap_flag_ExcuteValue1--;
					continue;
				}
			if (soap_flag_ExcuteUnit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteUnit", &(a->ns4__TaskExcuteInfo::ExcuteUnit), "xsd:string"))
				{	soap_flag_ExcuteUnit1--;
					continue;
				}
			if (soap_flag_ExcuteState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteState", &(a->ns4__TaskExcuteInfo::ExcuteState), "xsd:string"))
				{	soap_flag_ExcuteState1--;
					continue;
				}
			if (soap_flag_ExcuteDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteDesc", &(a->ns4__TaskExcuteInfo::ExcuteDesc), "xsd:string"))
				{	soap_flag_ExcuteDesc1--;
					continue;
				}
			if (soap_flag_HDPicture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HDPicture", &(a->ns4__TaskExcuteInfo::HDPicture), "xsd:string"))
				{	soap_flag_HDPicture1--;
					continue;
				}
			if (soap_flag_InfraredPicture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "InfraredPicture", &(a->ns4__TaskExcuteInfo::InfraredPicture), "xsd:string"))
				{	soap_flag_InfraredPicture1--;
					continue;
				}
			if (soap_flag_OtherFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "OtherFile", &(a->ns4__TaskExcuteInfo::OtherFile), "xsd:string"))
				{	soap_flag_OtherFile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TaskExcuteInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__TaskExcuteInfo, 0, sizeof(ns4__TaskExcuteInfo), 0, soap_copy_ns4__TaskExcuteInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskPathId1 > 0 || soap_flag_TargetId1 > 0 || soap_flag_PointId1 > 0 || soap_flag_PointName1 > 0 || soap_flag_PointType1 > 0 || soap_flag_ExcuteTime1 > 0 || soap_flag_ExcuteValue1 > 0 || soap_flag_ExcuteUnit1 > 0 || soap_flag_ExcuteState1 > 0 || soap_flag_ExcuteDesc1 > 0 || soap_flag_HDPicture1 > 0 || soap_flag_InfraredPicture1 > 0 || soap_flag_OtherFile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__TaskExcuteInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__TaskExcuteInfo);
	if (this->soap_out(soap, tag?tag:"ns4:TaskExcuteInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__TaskExcuteInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TaskExcuteInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TaskExcuteInfo * SOAP_FMAC4 soap_get_ns4__TaskExcuteInfo(struct soap *soap, ns4__TaskExcuteInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TaskExcuteInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__TaskExcuteInfo * SOAP_FMAC2 soap_instantiate_ns4__TaskExcuteInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TaskExcuteInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__TaskExcuteInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__TaskExcuteInfo);
		if (size)
			*size = sizeof(ns4__TaskExcuteInfo);
		((ns4__TaskExcuteInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__TaskExcuteInfo, n);
		if (size)
			*size = n * sizeof(ns4__TaskExcuteInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__TaskExcuteInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__TaskExcuteInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TaskExcuteInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TaskExcuteInfo %p -> %p\n", q, p));
	*(ns4__TaskExcuteInfo*)p = *(ns4__TaskExcuteInfo*)q;
}

void ns4__TaskFinishInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__TaskFinishInfo(soap, &this->ns4__TaskFinishInfos::Infos);
	/* transient soap skipped */
}

void ns4__TaskFinishInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__TaskFinishInfo(soap, &this->ns4__TaskFinishInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__TaskFinishInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TaskFinishInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TaskFinishInfos(struct soap *soap, const char *tag, int id, const ns4__TaskFinishInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__TaskFinishInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__TaskFinishInfo(soap, "Infos", -1, &(a->ns4__TaskFinishInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__TaskFinishInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TaskFinishInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TaskFinishInfos * SOAP_FMAC4 soap_in_ns4__TaskFinishInfos(struct soap *soap, const char *tag, ns4__TaskFinishInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TaskFinishInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__TaskFinishInfos, sizeof(ns4__TaskFinishInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__TaskFinishInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TaskFinishInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__TaskFinishInfo(soap, "Infos", &(a->ns4__TaskFinishInfos::Infos), "ns4:TaskFinishInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TaskFinishInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__TaskFinishInfos, 0, sizeof(ns4__TaskFinishInfos), 0, soap_copy_ns4__TaskFinishInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__TaskFinishInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__TaskFinishInfos);
	if (this->soap_out(soap, tag?tag:"ns4:TaskFinishInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__TaskFinishInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TaskFinishInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TaskFinishInfos * SOAP_FMAC4 soap_get_ns4__TaskFinishInfos(struct soap *soap, ns4__TaskFinishInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TaskFinishInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__TaskFinishInfos * SOAP_FMAC2 soap_instantiate_ns4__TaskFinishInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TaskFinishInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__TaskFinishInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__TaskFinishInfos);
		if (size)
			*size = sizeof(ns4__TaskFinishInfos);
		((ns4__TaskFinishInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__TaskFinishInfos, n);
		if (size)
			*size = n * sizeof(ns4__TaskFinishInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__TaskFinishInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__TaskFinishInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TaskFinishInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TaskFinishInfos %p -> %p\n", q, p));
	*(ns4__TaskFinishInfos*)p = *(ns4__TaskFinishInfos*)q;
}

void ns4__TaskFinishInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__TaskFinishInfo::TaskId);
	soap_default_std__string(soap, &this->ns4__TaskFinishInfo::TaskName);
	soap_default_std__string(soap, &this->ns4__TaskFinishInfo::TaskType);
	soap_default_std__string(soap, &this->ns4__TaskFinishInfo::TaskPathId);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns4__TaskFinishInfo::PointList);
	soap_default_std__string(soap, &this->ns4__TaskFinishInfo::StartTime);
	soap_default_std__string(soap, &this->ns4__TaskFinishInfo::EndTime);
	soap_default_std__string(soap, &this->ns4__TaskFinishInfo::FinishState);
	soap_default_std__string(soap, &this->ns4__TaskFinishInfo::ExcuteRobot);
	/* transient soap skipped */
}

void ns4__TaskFinishInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__TaskFinishInfo::TaskId);
	soap_serialize_std__string(soap, &this->ns4__TaskFinishInfo::TaskName);
	soap_serialize_std__string(soap, &this->ns4__TaskFinishInfo::TaskType);
	soap_serialize_std__string(soap, &this->ns4__TaskFinishInfo::TaskPathId);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns4__TaskFinishInfo::PointList);
	soap_serialize_std__string(soap, &this->ns4__TaskFinishInfo::StartTime);
	soap_serialize_std__string(soap, &this->ns4__TaskFinishInfo::EndTime);
	soap_serialize_std__string(soap, &this->ns4__TaskFinishInfo::FinishState);
	soap_serialize_std__string(soap, &this->ns4__TaskFinishInfo::ExcuteRobot);
	/* transient soap skipped */
#endif
}

int ns4__TaskFinishInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TaskFinishInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TaskFinishInfo(struct soap *soap, const char *tag, int id, const ns4__TaskFinishInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__TaskFinishInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns4__TaskFinishInfo::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns4__TaskFinishInfo::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns4__TaskFinishInfo::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns4__TaskFinishInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns4__TaskFinishInfo::PointList), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartTime", -1, &(a->ns4__TaskFinishInfo::StartTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndTime", -1, &(a->ns4__TaskFinishInfo::EndTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FinishState", -1, &(a->ns4__TaskFinishInfo::FinishState), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteRobot", -1, &(a->ns4__TaskFinishInfo::ExcuteRobot), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__TaskFinishInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TaskFinishInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TaskFinishInfo * SOAP_FMAC4 soap_in_ns4__TaskFinishInfo(struct soap *soap, const char *tag, ns4__TaskFinishInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TaskFinishInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__TaskFinishInfo, sizeof(ns4__TaskFinishInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__TaskFinishInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TaskFinishInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_StartTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	size_t soap_flag_FinishState1 = 1;
	size_t soap_flag_ExcuteRobot1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns4__TaskFinishInfo::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns4__TaskFinishInfo::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns4__TaskFinishInfo::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns4__TaskFinishInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns4__TaskFinishInfo::PointList), "xsd:string"))
					continue;
			if (soap_flag_StartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartTime", &(a->ns4__TaskFinishInfo::StartTime), "xsd:string"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag_EndTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndTime", &(a->ns4__TaskFinishInfo::EndTime), "xsd:string"))
				{	soap_flag_EndTime1--;
					continue;
				}
			if (soap_flag_FinishState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FinishState", &(a->ns4__TaskFinishInfo::FinishState), "xsd:string"))
				{	soap_flag_FinishState1--;
					continue;
				}
			if (soap_flag_ExcuteRobot1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteRobot", &(a->ns4__TaskFinishInfo::ExcuteRobot), "xsd:string"))
				{	soap_flag_ExcuteRobot1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TaskFinishInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__TaskFinishInfo, 0, sizeof(ns4__TaskFinishInfo), 0, soap_copy_ns4__TaskFinishInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskPathId1 > 0 || soap_flag_StartTime1 > 0 || soap_flag_EndTime1 > 0 || soap_flag_FinishState1 > 0 || soap_flag_ExcuteRobot1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__TaskFinishInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__TaskFinishInfo);
	if (this->soap_out(soap, tag?tag:"ns4:TaskFinishInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__TaskFinishInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TaskFinishInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TaskFinishInfo * SOAP_FMAC4 soap_get_ns4__TaskFinishInfo(struct soap *soap, ns4__TaskFinishInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TaskFinishInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__TaskFinishInfo * SOAP_FMAC2 soap_instantiate_ns4__TaskFinishInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TaskFinishInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__TaskFinishInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__TaskFinishInfo);
		if (size)
			*size = sizeof(ns4__TaskFinishInfo);
		((ns4__TaskFinishInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__TaskFinishInfo, n);
		if (size)
			*size = n * sizeof(ns4__TaskFinishInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__TaskFinishInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__TaskFinishInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TaskFinishInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TaskFinishInfo %p -> %p\n", q, p));
	*(ns4__TaskFinishInfo*)p = *(ns4__TaskFinishInfo*)q;
}

void ns4__TaskExcuteData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__TaskExcuteData::RobotIp);
	soap_default_std__string(soap, &this->ns4__TaskExcuteData::TaskType);
	soap_default_std__string(soap, &this->ns4__TaskExcuteData::TaskId);
	soap_default_std__string(soap, &this->ns4__TaskExcuteData::TaskName);
	soap_default_std__string(soap, &this->ns4__TaskExcuteData::PatrolDeviceName);
	soap_default_std__string(soap, &this->ns4__TaskExcuteData::PatrolDeviceId);
	soap_default_int(soap, &this->ns4__TaskExcuteData::TotalDeviceSize);
	soap_default_int(soap, &this->ns4__TaskExcuteData::ErrorDeviceSize);
	soap_default_int(soap, &this->ns4__TaskExcuteData::FinishDeviceSize);
	soap_default_int(soap, &this->ns4__TaskExcuteData::TaskFinishPercentage);
	/* transient soap skipped */
}

void ns4__TaskExcuteData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteData::RobotIp);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteData::TaskType);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteData::TaskId);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteData::TaskName);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteData::PatrolDeviceName);
	soap_serialize_std__string(soap, &this->ns4__TaskExcuteData::PatrolDeviceId);
	/* transient soap skipped */
#endif
}

int ns4__TaskExcuteData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TaskExcuteData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TaskExcuteData(struct soap *soap, const char *tag, int id, const ns4__TaskExcuteData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__TaskExcuteData), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__TaskExcuteData::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns4__TaskExcuteData::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns4__TaskExcuteData::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns4__TaskExcuteData::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PatrolDeviceName", -1, &(a->ns4__TaskExcuteData::PatrolDeviceName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PatrolDeviceId", -1, &(a->ns4__TaskExcuteData::PatrolDeviceId), ""))
		return soap->error;
	if (soap_out_int(soap, "TotalDeviceSize", -1, &(a->ns4__TaskExcuteData::TotalDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "ErrorDeviceSize", -1, &(a->ns4__TaskExcuteData::ErrorDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "FinishDeviceSize", -1, &(a->ns4__TaskExcuteData::FinishDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "TaskFinishPercentage", -1, &(a->ns4__TaskExcuteData::TaskFinishPercentage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__TaskExcuteData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TaskExcuteData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TaskExcuteData * SOAP_FMAC4 soap_in_ns4__TaskExcuteData(struct soap *soap, const char *tag, ns4__TaskExcuteData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TaskExcuteData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__TaskExcuteData, sizeof(ns4__TaskExcuteData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__TaskExcuteData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TaskExcuteData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_PatrolDeviceName1 = 1;
	size_t soap_flag_PatrolDeviceId1 = 1;
	size_t soap_flag_TotalDeviceSize1 = 1;
	size_t soap_flag_ErrorDeviceSize1 = 1;
	size_t soap_flag_FinishDeviceSize1 = 1;
	size_t soap_flag_TaskFinishPercentage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__TaskExcuteData::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns4__TaskExcuteData::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns4__TaskExcuteData::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns4__TaskExcuteData::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_PatrolDeviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PatrolDeviceName", &(a->ns4__TaskExcuteData::PatrolDeviceName), "xsd:string"))
				{	soap_flag_PatrolDeviceName1--;
					continue;
				}
			if (soap_flag_PatrolDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PatrolDeviceId", &(a->ns4__TaskExcuteData::PatrolDeviceId), "xsd:string"))
				{	soap_flag_PatrolDeviceId1--;
					continue;
				}
			if (soap_flag_TotalDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TotalDeviceSize", &(a->ns4__TaskExcuteData::TotalDeviceSize), "xsd:int"))
				{	soap_flag_TotalDeviceSize1--;
					continue;
				}
			if (soap_flag_ErrorDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ErrorDeviceSize", &(a->ns4__TaskExcuteData::ErrorDeviceSize), "xsd:int"))
				{	soap_flag_ErrorDeviceSize1--;
					continue;
				}
			if (soap_flag_FinishDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FinishDeviceSize", &(a->ns4__TaskExcuteData::FinishDeviceSize), "xsd:int"))
				{	soap_flag_FinishDeviceSize1--;
					continue;
				}
			if (soap_flag_TaskFinishPercentage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TaskFinishPercentage", &(a->ns4__TaskExcuteData::TaskFinishPercentage), "xsd:int"))
				{	soap_flag_TaskFinishPercentage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TaskExcuteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__TaskExcuteData, 0, sizeof(ns4__TaskExcuteData), 0, soap_copy_ns4__TaskExcuteData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_PatrolDeviceName1 > 0 || soap_flag_PatrolDeviceId1 > 0 || soap_flag_TotalDeviceSize1 > 0 || soap_flag_ErrorDeviceSize1 > 0 || soap_flag_FinishDeviceSize1 > 0 || soap_flag_TaskFinishPercentage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__TaskExcuteData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__TaskExcuteData);
	if (this->soap_out(soap, tag?tag:"ns4:TaskExcuteData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__TaskExcuteData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TaskExcuteData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TaskExcuteData * SOAP_FMAC4 soap_get_ns4__TaskExcuteData(struct soap *soap, ns4__TaskExcuteData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TaskExcuteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__TaskExcuteData * SOAP_FMAC2 soap_instantiate_ns4__TaskExcuteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TaskExcuteData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__TaskExcuteData, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__TaskExcuteData);
		if (size)
			*size = sizeof(ns4__TaskExcuteData);
		((ns4__TaskExcuteData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__TaskExcuteData, n);
		if (size)
			*size = n * sizeof(ns4__TaskExcuteData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__TaskExcuteData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__TaskExcuteData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TaskExcuteData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TaskExcuteData %p -> %p\n", q, p));
	*(ns4__TaskExcuteData*)p = *(ns4__TaskExcuteData*)q;
}

void ns4__TaskPathInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__TaskPathInfo(soap, &this->ns4__TaskPathInfos::Infos);
	/* transient soap skipped */
}

void ns4__TaskPathInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__TaskPathInfo(soap, &this->ns4__TaskPathInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__TaskPathInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TaskPathInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TaskPathInfos(struct soap *soap, const char *tag, int id, const ns4__TaskPathInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__TaskPathInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__TaskPathInfo(soap, "Infos", -1, &(a->ns4__TaskPathInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__TaskPathInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TaskPathInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TaskPathInfos * SOAP_FMAC4 soap_in_ns4__TaskPathInfos(struct soap *soap, const char *tag, ns4__TaskPathInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TaskPathInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__TaskPathInfos, sizeof(ns4__TaskPathInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__TaskPathInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TaskPathInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__TaskPathInfo(soap, "Infos", &(a->ns4__TaskPathInfos::Infos), "ns4:TaskPathInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TaskPathInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__TaskPathInfos, 0, sizeof(ns4__TaskPathInfos), 0, soap_copy_ns4__TaskPathInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__TaskPathInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__TaskPathInfos);
	if (this->soap_out(soap, tag?tag:"ns4:TaskPathInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__TaskPathInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TaskPathInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TaskPathInfos * SOAP_FMAC4 soap_get_ns4__TaskPathInfos(struct soap *soap, ns4__TaskPathInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TaskPathInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__TaskPathInfos * SOAP_FMAC2 soap_instantiate_ns4__TaskPathInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TaskPathInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__TaskPathInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__TaskPathInfos);
		if (size)
			*size = sizeof(ns4__TaskPathInfos);
		((ns4__TaskPathInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__TaskPathInfos, n);
		if (size)
			*size = n * sizeof(ns4__TaskPathInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__TaskPathInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__TaskPathInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TaskPathInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TaskPathInfos %p -> %p\n", q, p));
	*(ns4__TaskPathInfos*)p = *(ns4__TaskPathInfos*)q;
}

void ns4__TaskPathInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__TaskPathInfo::TaskPathId);
	soap_default_std__string(soap, &this->ns4__TaskPathInfo::TaskPathName);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns4__TaskPathInfo::PointList);
	soap_default_std__string(soap, &this->ns4__TaskPathInfo::TaskPathType);
	soap_default_std__string(soap, &this->ns4__TaskPathInfo::CreateTime);
	soap_default_int(soap, &this->ns4__TaskPathInfo::FinishAction);
	/* transient soap skipped */
}

void ns4__TaskPathInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__TaskPathInfo::TaskPathId);
	soap_serialize_std__string(soap, &this->ns4__TaskPathInfo::TaskPathName);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns4__TaskPathInfo::PointList);
	soap_serialize_std__string(soap, &this->ns4__TaskPathInfo::TaskPathType);
	soap_serialize_std__string(soap, &this->ns4__TaskPathInfo::CreateTime);
	/* transient soap skipped */
#endif
}

int ns4__TaskPathInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TaskPathInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TaskPathInfo(struct soap *soap, const char *tag, int id, const ns4__TaskPathInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__TaskPathInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns4__TaskPathInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathName", -1, &(a->ns4__TaskPathInfo::TaskPathName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns4__TaskPathInfo::PointList), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathType", -1, &(a->ns4__TaskPathInfo::TaskPathType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CreateTime", -1, &(a->ns4__TaskPathInfo::CreateTime), ""))
		return soap->error;
	if (soap_out_int(soap, "FinishAction", -1, &(a->ns4__TaskPathInfo::FinishAction), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__TaskPathInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TaskPathInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TaskPathInfo * SOAP_FMAC4 soap_in_ns4__TaskPathInfo(struct soap *soap, const char *tag, ns4__TaskPathInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TaskPathInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__TaskPathInfo, sizeof(ns4__TaskPathInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__TaskPathInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TaskPathInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_TaskPathName1 = 1;
	size_t soap_flag_TaskPathType1 = 1;
	size_t soap_flag_CreateTime1 = 1;
	size_t soap_flag_FinishAction1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns4__TaskPathInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap_flag_TaskPathName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathName", &(a->ns4__TaskPathInfo::TaskPathName), "xsd:string"))
				{	soap_flag_TaskPathName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns4__TaskPathInfo::PointList), "xsd:string"))
					continue;
			if (soap_flag_TaskPathType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathType", &(a->ns4__TaskPathInfo::TaskPathType), "xsd:string"))
				{	soap_flag_TaskPathType1--;
					continue;
				}
			if (soap_flag_CreateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CreateTime", &(a->ns4__TaskPathInfo::CreateTime), "xsd:string"))
				{	soap_flag_CreateTime1--;
					continue;
				}
			if (soap_flag_FinishAction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FinishAction", &(a->ns4__TaskPathInfo::FinishAction), "xsd:int"))
				{	soap_flag_FinishAction1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TaskPathInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__TaskPathInfo, 0, sizeof(ns4__TaskPathInfo), 0, soap_copy_ns4__TaskPathInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskPathId1 > 0 || soap_flag_TaskPathName1 > 0 || soap_flag_TaskPathType1 > 0 || soap_flag_CreateTime1 > 0 || soap_flag_FinishAction1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__TaskPathInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__TaskPathInfo);
	if (this->soap_out(soap, tag?tag:"ns4:TaskPathInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__TaskPathInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TaskPathInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TaskPathInfo * SOAP_FMAC4 soap_get_ns4__TaskPathInfo(struct soap *soap, ns4__TaskPathInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__TaskPathInfo * SOAP_FMAC2 soap_instantiate_ns4__TaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__TaskPathInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__TaskPathInfo);
		if (size)
			*size = sizeof(ns4__TaskPathInfo);
		((ns4__TaskPathInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__TaskPathInfo, n);
		if (size)
			*size = n * sizeof(ns4__TaskPathInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__TaskPathInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__TaskPathInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TaskPathInfo %p -> %p\n", q, p));
	*(ns4__TaskPathInfo*)p = *(ns4__TaskPathInfo*)q;
}

void ns4__PatrolPointInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__PatrolPointInfo(soap, &this->ns4__PatrolPointInfos::Infos);
	/* transient soap skipped */
}

void ns4__PatrolPointInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__PatrolPointInfo(soap, &this->ns4__PatrolPointInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__PatrolPointInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__PatrolPointInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PatrolPointInfos(struct soap *soap, const char *tag, int id, const ns4__PatrolPointInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__PatrolPointInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__PatrolPointInfo(soap, "Infos", -1, &(a->ns4__PatrolPointInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__PatrolPointInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__PatrolPointInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__PatrolPointInfos * SOAP_FMAC4 soap_in_ns4__PatrolPointInfos(struct soap *soap, const char *tag, ns4__PatrolPointInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__PatrolPointInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__PatrolPointInfos, sizeof(ns4__PatrolPointInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__PatrolPointInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__PatrolPointInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__PatrolPointInfo(soap, "Infos", &(a->ns4__PatrolPointInfos::Infos), "ns4:PatrolPointInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__PatrolPointInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__PatrolPointInfos, 0, sizeof(ns4__PatrolPointInfos), 0, soap_copy_ns4__PatrolPointInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__PatrolPointInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__PatrolPointInfos);
	if (this->soap_out(soap, tag?tag:"ns4:PatrolPointInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__PatrolPointInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__PatrolPointInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__PatrolPointInfos * SOAP_FMAC4 soap_get_ns4__PatrolPointInfos(struct soap *soap, ns4__PatrolPointInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PatrolPointInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__PatrolPointInfos * SOAP_FMAC2 soap_instantiate_ns4__PatrolPointInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__PatrolPointInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__PatrolPointInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__PatrolPointInfos);
		if (size)
			*size = sizeof(ns4__PatrolPointInfos);
		((ns4__PatrolPointInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__PatrolPointInfos, n);
		if (size)
			*size = n * sizeof(ns4__PatrolPointInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__PatrolPointInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__PatrolPointInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__PatrolPointInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__PatrolPointInfos %p -> %p\n", q, p));
	*(ns4__PatrolPointInfos*)p = *(ns4__PatrolPointInfos*)q;
}

void ns4__PatrolPointInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__PatrolPointInfo::PointId);
	soap_default_std__string(soap, &this->ns4__PatrolPointInfo::PointName);
	soap_default_std__string(soap, &this->ns4__PatrolPointInfo::PointType);
	soap_default_std__string(soap, &this->ns4__PatrolPointInfo::DeviceType);
	soap_default_std__string(soap, &this->ns4__PatrolPointInfo::AreaId);
	soap_default_std__string(soap, &this->ns4__PatrolPointInfo::DockId);
	soap_default_std__string(soap, &this->ns4__PatrolPointInfo::RobotIp);
	/* transient soap skipped */
}

void ns4__PatrolPointInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__PatrolPointInfo::PointId);
	soap_serialize_std__string(soap, &this->ns4__PatrolPointInfo::PointName);
	soap_serialize_std__string(soap, &this->ns4__PatrolPointInfo::PointType);
	soap_serialize_std__string(soap, &this->ns4__PatrolPointInfo::DeviceType);
	soap_serialize_std__string(soap, &this->ns4__PatrolPointInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns4__PatrolPointInfo::DockId);
	soap_serialize_std__string(soap, &this->ns4__PatrolPointInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns4__PatrolPointInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__PatrolPointInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PatrolPointInfo(struct soap *soap, const char *tag, int id, const ns4__PatrolPointInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__PatrolPointInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "PointId", -1, &(a->ns4__PatrolPointInfo::PointId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointName", -1, &(a->ns4__PatrolPointInfo::PointName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointType", -1, &(a->ns4__PatrolPointInfo::PointType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DeviceType", -1, &(a->ns4__PatrolPointInfo::DeviceType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns4__PatrolPointInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockId", -1, &(a->ns4__PatrolPointInfo::DockId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__PatrolPointInfo::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__PatrolPointInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__PatrolPointInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__PatrolPointInfo * SOAP_FMAC4 soap_in_ns4__PatrolPointInfo(struct soap *soap, const char *tag, ns4__PatrolPointInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__PatrolPointInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__PatrolPointInfo, sizeof(ns4__PatrolPointInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__PatrolPointInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__PatrolPointInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PointId1 = 1;
	size_t soap_flag_PointName1 = 1;
	size_t soap_flag_PointType1 = 1;
	size_t soap_flag_DeviceType1 = 1;
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_DockId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PointId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointId", &(a->ns4__PatrolPointInfo::PointId), "xsd:string"))
				{	soap_flag_PointId1--;
					continue;
				}
			if (soap_flag_PointName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointName", &(a->ns4__PatrolPointInfo::PointName), "xsd:string"))
				{	soap_flag_PointName1--;
					continue;
				}
			if (soap_flag_PointType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointType", &(a->ns4__PatrolPointInfo::PointType), "xsd:string"))
				{	soap_flag_PointType1--;
					continue;
				}
			if (soap_flag_DeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DeviceType", &(a->ns4__PatrolPointInfo::DeviceType), "xsd:string"))
				{	soap_flag_DeviceType1--;
					continue;
				}
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns4__PatrolPointInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_DockId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockId", &(a->ns4__PatrolPointInfo::DockId), "xsd:string"))
				{	soap_flag_DockId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__PatrolPointInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__PatrolPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__PatrolPointInfo, 0, sizeof(ns4__PatrolPointInfo), 0, soap_copy_ns4__PatrolPointInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PointId1 > 0 || soap_flag_PointName1 > 0 || soap_flag_PointType1 > 0 || soap_flag_DeviceType1 > 0 || soap_flag_AreaId1 > 0 || soap_flag_DockId1 > 0 || soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__PatrolPointInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__PatrolPointInfo);
	if (this->soap_out(soap, tag?tag:"ns4:PatrolPointInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__PatrolPointInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__PatrolPointInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__PatrolPointInfo * SOAP_FMAC4 soap_get_ns4__PatrolPointInfo(struct soap *soap, ns4__PatrolPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__PatrolPointInfo * SOAP_FMAC2 soap_instantiate_ns4__PatrolPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__PatrolPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__PatrolPointInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__PatrolPointInfo);
		if (size)
			*size = sizeof(ns4__PatrolPointInfo);
		((ns4__PatrolPointInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__PatrolPointInfo, n);
		if (size)
			*size = n * sizeof(ns4__PatrolPointInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__PatrolPointInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__PatrolPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__PatrolPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__PatrolPointInfo %p -> %p\n", q, p));
	*(ns4__PatrolPointInfo*)p = *(ns4__PatrolPointInfo*)q;
}

void ns4__DockPointInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__DockPointInfo(soap, &this->ns4__DockPointInfos::Infos);
	/* transient soap skipped */
}

void ns4__DockPointInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__DockPointInfo(soap, &this->ns4__DockPointInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__DockPointInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__DockPointInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DockPointInfos(struct soap *soap, const char *tag, int id, const ns4__DockPointInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__DockPointInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__DockPointInfo(soap, "Infos", -1, &(a->ns4__DockPointInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__DockPointInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__DockPointInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__DockPointInfos * SOAP_FMAC4 soap_in_ns4__DockPointInfos(struct soap *soap, const char *tag, ns4__DockPointInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__DockPointInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__DockPointInfos, sizeof(ns4__DockPointInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__DockPointInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__DockPointInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__DockPointInfo(soap, "Infos", &(a->ns4__DockPointInfos::Infos), "ns4:DockPointInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__DockPointInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__DockPointInfos, 0, sizeof(ns4__DockPointInfos), 0, soap_copy_ns4__DockPointInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__DockPointInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__DockPointInfos);
	if (this->soap_out(soap, tag?tag:"ns4:DockPointInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__DockPointInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__DockPointInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__DockPointInfos * SOAP_FMAC4 soap_get_ns4__DockPointInfos(struct soap *soap, ns4__DockPointInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DockPointInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__DockPointInfos * SOAP_FMAC2 soap_instantiate_ns4__DockPointInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__DockPointInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__DockPointInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__DockPointInfos);
		if (size)
			*size = sizeof(ns4__DockPointInfos);
		((ns4__DockPointInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__DockPointInfos, n);
		if (size)
			*size = n * sizeof(ns4__DockPointInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__DockPointInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__DockPointInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__DockPointInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__DockPointInfos %p -> %p\n", q, p));
	*(ns4__DockPointInfos*)p = *(ns4__DockPointInfos*)q;
}

void ns4__DockPointInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__DockPointInfo::DockId);
	soap_default_std__string(soap, &this->ns4__DockPointInfo::DockX);
	soap_default_std__string(soap, &this->ns4__DockPointInfo::DockY);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns4__DockPointInfo::PointList);
	/* transient soap skipped */
}

void ns4__DockPointInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__DockPointInfo::DockId);
	soap_serialize_std__string(soap, &this->ns4__DockPointInfo::DockX);
	soap_serialize_std__string(soap, &this->ns4__DockPointInfo::DockY);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns4__DockPointInfo::PointList);
	/* transient soap skipped */
#endif
}

int ns4__DockPointInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__DockPointInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DockPointInfo(struct soap *soap, const char *tag, int id, const ns4__DockPointInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__DockPointInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "DockId", -1, &(a->ns4__DockPointInfo::DockId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockX", -1, &(a->ns4__DockPointInfo::DockX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockY", -1, &(a->ns4__DockPointInfo::DockY), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns4__DockPointInfo::PointList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__DockPointInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__DockPointInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__DockPointInfo * SOAP_FMAC4 soap_in_ns4__DockPointInfo(struct soap *soap, const char *tag, ns4__DockPointInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__DockPointInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__DockPointInfo, sizeof(ns4__DockPointInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__DockPointInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__DockPointInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DockId1 = 1;
	size_t soap_flag_DockX1 = 1;
	size_t soap_flag_DockY1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DockId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockId", &(a->ns4__DockPointInfo::DockId), "xsd:string"))
				{	soap_flag_DockId1--;
					continue;
				}
			if (soap_flag_DockX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockX", &(a->ns4__DockPointInfo::DockX), "xsd:string"))
				{	soap_flag_DockX1--;
					continue;
				}
			if (soap_flag_DockY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockY", &(a->ns4__DockPointInfo::DockY), "xsd:string"))
				{	soap_flag_DockY1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns4__DockPointInfo::PointList), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__DockPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__DockPointInfo, 0, sizeof(ns4__DockPointInfo), 0, soap_copy_ns4__DockPointInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DockId1 > 0 || soap_flag_DockX1 > 0 || soap_flag_DockY1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__DockPointInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__DockPointInfo);
	if (this->soap_out(soap, tag?tag:"ns4:DockPointInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__DockPointInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__DockPointInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__DockPointInfo * SOAP_FMAC4 soap_get_ns4__DockPointInfo(struct soap *soap, ns4__DockPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__DockPointInfo * SOAP_FMAC2 soap_instantiate_ns4__DockPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__DockPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__DockPointInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__DockPointInfo);
		if (size)
			*size = sizeof(ns4__DockPointInfo);
		((ns4__DockPointInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__DockPointInfo, n);
		if (size)
			*size = n * sizeof(ns4__DockPointInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__DockPointInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__DockPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__DockPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__DockPointInfo %p -> %p\n", q, p));
	*(ns4__DockPointInfo*)p = *(ns4__DockPointInfo*)q;
}

void ns4__MapEdgeInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__MapEdgeInfo(soap, &this->ns4__MapEdgeInfos::Infos);
	/* transient soap skipped */
}

void ns4__MapEdgeInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__MapEdgeInfo(soap, &this->ns4__MapEdgeInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__MapEdgeInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__MapEdgeInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MapEdgeInfos(struct soap *soap, const char *tag, int id, const ns4__MapEdgeInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__MapEdgeInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__MapEdgeInfo(soap, "Infos", -1, &(a->ns4__MapEdgeInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__MapEdgeInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__MapEdgeInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__MapEdgeInfos * SOAP_FMAC4 soap_in_ns4__MapEdgeInfos(struct soap *soap, const char *tag, ns4__MapEdgeInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__MapEdgeInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__MapEdgeInfos, sizeof(ns4__MapEdgeInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__MapEdgeInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__MapEdgeInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__MapEdgeInfo(soap, "Infos", &(a->ns4__MapEdgeInfos::Infos), "ns4:MapEdgeInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__MapEdgeInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__MapEdgeInfos, 0, sizeof(ns4__MapEdgeInfos), 0, soap_copy_ns4__MapEdgeInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__MapEdgeInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__MapEdgeInfos);
	if (this->soap_out(soap, tag?tag:"ns4:MapEdgeInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__MapEdgeInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__MapEdgeInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__MapEdgeInfos * SOAP_FMAC4 soap_get_ns4__MapEdgeInfos(struct soap *soap, ns4__MapEdgeInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MapEdgeInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__MapEdgeInfos * SOAP_FMAC2 soap_instantiate_ns4__MapEdgeInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__MapEdgeInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__MapEdgeInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__MapEdgeInfos);
		if (size)
			*size = sizeof(ns4__MapEdgeInfos);
		((ns4__MapEdgeInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__MapEdgeInfos, n);
		if (size)
			*size = n * sizeof(ns4__MapEdgeInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__MapEdgeInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__MapEdgeInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__MapEdgeInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__MapEdgeInfos %p -> %p\n", q, p));
	*(ns4__MapEdgeInfos*)p = *(ns4__MapEdgeInfos*)q;
}

void ns4__MapEdgeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::EdgeId);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::StartNodeId);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::EndNodeId);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::StartNodeX);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::StartNodeY);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::EndNodeX);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::EndNodeY);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::FirstControlX);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::FirstControlY);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::SecondControlX);
	soap_default_std__string(soap, &this->ns4__MapEdgeInfo::SecondControlY);
	/* transient soap skipped */
}

void ns4__MapEdgeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::EdgeId);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::StartNodeId);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::EndNodeId);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::StartNodeX);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::StartNodeY);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::EndNodeX);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::EndNodeY);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::FirstControlX);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::FirstControlY);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::SecondControlX);
	soap_serialize_std__string(soap, &this->ns4__MapEdgeInfo::SecondControlY);
	/* transient soap skipped */
#endif
}

int ns4__MapEdgeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__MapEdgeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MapEdgeInfo(struct soap *soap, const char *tag, int id, const ns4__MapEdgeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__MapEdgeInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "EdgeId", -1, &(a->ns4__MapEdgeInfo::EdgeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeId", -1, &(a->ns4__MapEdgeInfo::StartNodeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeId", -1, &(a->ns4__MapEdgeInfo::EndNodeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeX", -1, &(a->ns4__MapEdgeInfo::StartNodeX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeY", -1, &(a->ns4__MapEdgeInfo::StartNodeY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeX", -1, &(a->ns4__MapEdgeInfo::EndNodeX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeY", -1, &(a->ns4__MapEdgeInfo::EndNodeY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FirstControlX", -1, &(a->ns4__MapEdgeInfo::FirstControlX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FirstControlY", -1, &(a->ns4__MapEdgeInfo::FirstControlY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SecondControlX", -1, &(a->ns4__MapEdgeInfo::SecondControlX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SecondControlY", -1, &(a->ns4__MapEdgeInfo::SecondControlY), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__MapEdgeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__MapEdgeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__MapEdgeInfo * SOAP_FMAC4 soap_in_ns4__MapEdgeInfo(struct soap *soap, const char *tag, ns4__MapEdgeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__MapEdgeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__MapEdgeInfo, sizeof(ns4__MapEdgeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__MapEdgeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__MapEdgeInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EdgeId1 = 1;
	size_t soap_flag_StartNodeId1 = 1;
	size_t soap_flag_EndNodeId1 = 1;
	size_t soap_flag_StartNodeX1 = 1;
	size_t soap_flag_StartNodeY1 = 1;
	size_t soap_flag_EndNodeX1 = 1;
	size_t soap_flag_EndNodeY1 = 1;
	size_t soap_flag_FirstControlX1 = 1;
	size_t soap_flag_FirstControlY1 = 1;
	size_t soap_flag_SecondControlX1 = 1;
	size_t soap_flag_SecondControlY1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EdgeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EdgeId", &(a->ns4__MapEdgeInfo::EdgeId), "xsd:string"))
				{	soap_flag_EdgeId1--;
					continue;
				}
			if (soap_flag_StartNodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeId", &(a->ns4__MapEdgeInfo::StartNodeId), "xsd:string"))
				{	soap_flag_StartNodeId1--;
					continue;
				}
			if (soap_flag_EndNodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeId", &(a->ns4__MapEdgeInfo::EndNodeId), "xsd:string"))
				{	soap_flag_EndNodeId1--;
					continue;
				}
			if (soap_flag_StartNodeX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeX", &(a->ns4__MapEdgeInfo::StartNodeX), "xsd:string"))
				{	soap_flag_StartNodeX1--;
					continue;
				}
			if (soap_flag_StartNodeY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeY", &(a->ns4__MapEdgeInfo::StartNodeY), "xsd:string"))
				{	soap_flag_StartNodeY1--;
					continue;
				}
			if (soap_flag_EndNodeX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeX", &(a->ns4__MapEdgeInfo::EndNodeX), "xsd:string"))
				{	soap_flag_EndNodeX1--;
					continue;
				}
			if (soap_flag_EndNodeY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeY", &(a->ns4__MapEdgeInfo::EndNodeY), "xsd:string"))
				{	soap_flag_EndNodeY1--;
					continue;
				}
			if (soap_flag_FirstControlX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FirstControlX", &(a->ns4__MapEdgeInfo::FirstControlX), "xsd:string"))
				{	soap_flag_FirstControlX1--;
					continue;
				}
			if (soap_flag_FirstControlY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FirstControlY", &(a->ns4__MapEdgeInfo::FirstControlY), "xsd:string"))
				{	soap_flag_FirstControlY1--;
					continue;
				}
			if (soap_flag_SecondControlX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SecondControlX", &(a->ns4__MapEdgeInfo::SecondControlX), "xsd:string"))
				{	soap_flag_SecondControlX1--;
					continue;
				}
			if (soap_flag_SecondControlY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SecondControlY", &(a->ns4__MapEdgeInfo::SecondControlY), "xsd:string"))
				{	soap_flag_SecondControlY1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__MapEdgeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__MapEdgeInfo, 0, sizeof(ns4__MapEdgeInfo), 0, soap_copy_ns4__MapEdgeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EdgeId1 > 0 || soap_flag_StartNodeId1 > 0 || soap_flag_EndNodeId1 > 0 || soap_flag_StartNodeX1 > 0 || soap_flag_StartNodeY1 > 0 || soap_flag_EndNodeX1 > 0 || soap_flag_EndNodeY1 > 0 || soap_flag_FirstControlX1 > 0 || soap_flag_FirstControlY1 > 0 || soap_flag_SecondControlX1 > 0 || soap_flag_SecondControlY1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__MapEdgeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__MapEdgeInfo);
	if (this->soap_out(soap, tag?tag:"ns4:MapEdgeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__MapEdgeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__MapEdgeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__MapEdgeInfo * SOAP_FMAC4 soap_get_ns4__MapEdgeInfo(struct soap *soap, ns4__MapEdgeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__MapEdgeInfo * SOAP_FMAC2 soap_instantiate_ns4__MapEdgeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__MapEdgeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__MapEdgeInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__MapEdgeInfo);
		if (size)
			*size = sizeof(ns4__MapEdgeInfo);
		((ns4__MapEdgeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__MapEdgeInfo, n);
		if (size)
			*size = n * sizeof(ns4__MapEdgeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__MapEdgeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__MapEdgeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__MapEdgeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__MapEdgeInfo %p -> %p\n", q, p));
	*(ns4__MapEdgeInfo*)p = *(ns4__MapEdgeInfo*)q;
}

void ns4__PatrolAreaInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(soap, &this->ns4__PatrolAreaInfos::Infos);
	/* transient soap skipped */
}

void ns4__PatrolAreaInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(soap, &this->ns4__PatrolAreaInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__PatrolAreaInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__PatrolAreaInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PatrolAreaInfos(struct soap *soap, const char *tag, int id, const ns4__PatrolAreaInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__PatrolAreaInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(soap, "Infos", -1, &(a->ns4__PatrolAreaInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__PatrolAreaInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__PatrolAreaInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__PatrolAreaInfos * SOAP_FMAC4 soap_in_ns4__PatrolAreaInfos(struct soap *soap, const char *tag, ns4__PatrolAreaInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__PatrolAreaInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__PatrolAreaInfos, sizeof(ns4__PatrolAreaInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__PatrolAreaInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__PatrolAreaInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(soap, "Infos", &(a->ns4__PatrolAreaInfos::Infos), "ns4:PatrolAreaInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__PatrolAreaInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__PatrolAreaInfos, 0, sizeof(ns4__PatrolAreaInfos), 0, soap_copy_ns4__PatrolAreaInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__PatrolAreaInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__PatrolAreaInfos);
	if (this->soap_out(soap, tag?tag:"ns4:PatrolAreaInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__PatrolAreaInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__PatrolAreaInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__PatrolAreaInfos * SOAP_FMAC4 soap_get_ns4__PatrolAreaInfos(struct soap *soap, ns4__PatrolAreaInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PatrolAreaInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__PatrolAreaInfos * SOAP_FMAC2 soap_instantiate_ns4__PatrolAreaInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__PatrolAreaInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__PatrolAreaInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__PatrolAreaInfos);
		if (size)
			*size = sizeof(ns4__PatrolAreaInfos);
		((ns4__PatrolAreaInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__PatrolAreaInfos, n);
		if (size)
			*size = n * sizeof(ns4__PatrolAreaInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__PatrolAreaInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__PatrolAreaInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__PatrolAreaInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__PatrolAreaInfos %p -> %p\n", q, p));
	*(ns4__PatrolAreaInfos*)p = *(ns4__PatrolAreaInfos*)q;
}

void ns4__PatrolAreaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__PatrolAreaInfo::AreaId);
	soap_default_std__string(soap, &this->ns4__PatrolAreaInfo::AreaName);
	soap_default_std__string(soap, &this->ns4__PatrolAreaInfo::ParentId);
	soap_default_std__string(soap, &this->ns4__PatrolAreaInfo::RobotIp);
	/* transient soap skipped */
}

void ns4__PatrolAreaInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__PatrolAreaInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns4__PatrolAreaInfo::AreaName);
	soap_serialize_std__string(soap, &this->ns4__PatrolAreaInfo::ParentId);
	soap_serialize_std__string(soap, &this->ns4__PatrolAreaInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns4__PatrolAreaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__PatrolAreaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PatrolAreaInfo(struct soap *soap, const char *tag, int id, const ns4__PatrolAreaInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__PatrolAreaInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns4__PatrolAreaInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaName", -1, &(a->ns4__PatrolAreaInfo::AreaName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ParentId", -1, &(a->ns4__PatrolAreaInfo::ParentId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__PatrolAreaInfo::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__PatrolAreaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__PatrolAreaInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__PatrolAreaInfo * SOAP_FMAC4 soap_in_ns4__PatrolAreaInfo(struct soap *soap, const char *tag, ns4__PatrolAreaInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__PatrolAreaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__PatrolAreaInfo, sizeof(ns4__PatrolAreaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__PatrolAreaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__PatrolAreaInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_AreaName1 = 1;
	size_t soap_flag_ParentId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns4__PatrolAreaInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_AreaName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaName", &(a->ns4__PatrolAreaInfo::AreaName), "xsd:string"))
				{	soap_flag_AreaName1--;
					continue;
				}
			if (soap_flag_ParentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ParentId", &(a->ns4__PatrolAreaInfo::ParentId), "xsd:string"))
				{	soap_flag_ParentId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__PatrolAreaInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__PatrolAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__PatrolAreaInfo, 0, sizeof(ns4__PatrolAreaInfo), 0, soap_copy_ns4__PatrolAreaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AreaId1 > 0 || soap_flag_AreaName1 > 0 || soap_flag_ParentId1 > 0 || soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__PatrolAreaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__PatrolAreaInfo);
	if (this->soap_out(soap, tag?tag:"ns4:PatrolAreaInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__PatrolAreaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__PatrolAreaInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__PatrolAreaInfo * SOAP_FMAC4 soap_get_ns4__PatrolAreaInfo(struct soap *soap, ns4__PatrolAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__PatrolAreaInfo * SOAP_FMAC2 soap_instantiate_ns4__PatrolAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__PatrolAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__PatrolAreaInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__PatrolAreaInfo);
		if (size)
			*size = sizeof(ns4__PatrolAreaInfo);
		((ns4__PatrolAreaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__PatrolAreaInfo, n);
		if (size)
			*size = n * sizeof(ns4__PatrolAreaInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__PatrolAreaInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__PatrolAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__PatrolAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__PatrolAreaInfo %p -> %p\n", q, p));
	*(ns4__PatrolAreaInfo*)p = *(ns4__PatrolAreaInfo*)q;
}

void ns4__MapAreaInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__MapAreaInfo(soap, &this->ns4__MapAreaInfos::Infos);
	/* transient soap skipped */
}

void ns4__MapAreaInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__MapAreaInfo(soap, &this->ns4__MapAreaInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__MapAreaInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__MapAreaInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MapAreaInfos(struct soap *soap, const char *tag, int id, const ns4__MapAreaInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__MapAreaInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__MapAreaInfo(soap, "Infos", -1, &(a->ns4__MapAreaInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__MapAreaInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__MapAreaInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__MapAreaInfos * SOAP_FMAC4 soap_in_ns4__MapAreaInfos(struct soap *soap, const char *tag, ns4__MapAreaInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__MapAreaInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__MapAreaInfos, sizeof(ns4__MapAreaInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__MapAreaInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__MapAreaInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__MapAreaInfo(soap, "Infos", &(a->ns4__MapAreaInfos::Infos), "ns4:MapAreaInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__MapAreaInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__MapAreaInfos, 0, sizeof(ns4__MapAreaInfos), 0, soap_copy_ns4__MapAreaInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__MapAreaInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__MapAreaInfos);
	if (this->soap_out(soap, tag?tag:"ns4:MapAreaInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__MapAreaInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__MapAreaInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__MapAreaInfos * SOAP_FMAC4 soap_get_ns4__MapAreaInfos(struct soap *soap, ns4__MapAreaInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MapAreaInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__MapAreaInfos * SOAP_FMAC2 soap_instantiate_ns4__MapAreaInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__MapAreaInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__MapAreaInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__MapAreaInfos);
		if (size)
			*size = sizeof(ns4__MapAreaInfos);
		((ns4__MapAreaInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__MapAreaInfos, n);
		if (size)
			*size = n * sizeof(ns4__MapAreaInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__MapAreaInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__MapAreaInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__MapAreaInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__MapAreaInfos %p -> %p\n", q, p));
	*(ns4__MapAreaInfos*)p = *(ns4__MapAreaInfos*)q;
}

void ns4__MapAreaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::RobotIp);
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::AreaId);
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::AreaName);
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::AreaMap);
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::MaxX);
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::MaxY);
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::MinX);
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::MinY);
	soap_default_std__string(soap, &this->ns4__MapAreaInfo::ParentId);
	/* transient soap skipped */
}

void ns4__MapAreaInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::AreaName);
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::AreaMap);
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::MaxX);
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::MaxY);
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::MinX);
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::MinY);
	soap_serialize_std__string(soap, &this->ns4__MapAreaInfo::ParentId);
	/* transient soap skipped */
#endif
}

int ns4__MapAreaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__MapAreaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MapAreaInfo(struct soap *soap, const char *tag, int id, const ns4__MapAreaInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__MapAreaInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__MapAreaInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns4__MapAreaInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaName", -1, &(a->ns4__MapAreaInfo::AreaName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaMap", -1, &(a->ns4__MapAreaInfo::AreaMap), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MaxX", -1, &(a->ns4__MapAreaInfo::MaxX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MaxY", -1, &(a->ns4__MapAreaInfo::MaxY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MinX", -1, &(a->ns4__MapAreaInfo::MinX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MinY", -1, &(a->ns4__MapAreaInfo::MinY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ParentId", -1, &(a->ns4__MapAreaInfo::ParentId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__MapAreaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__MapAreaInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__MapAreaInfo * SOAP_FMAC4 soap_in_ns4__MapAreaInfo(struct soap *soap, const char *tag, ns4__MapAreaInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__MapAreaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__MapAreaInfo, sizeof(ns4__MapAreaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__MapAreaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__MapAreaInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_AreaName1 = 1;
	size_t soap_flag_AreaMap1 = 1;
	size_t soap_flag_MaxX1 = 1;
	size_t soap_flag_MaxY1 = 1;
	size_t soap_flag_MinX1 = 1;
	size_t soap_flag_MinY1 = 1;
	size_t soap_flag_ParentId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__MapAreaInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns4__MapAreaInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_AreaName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaName", &(a->ns4__MapAreaInfo::AreaName), "xsd:string"))
				{	soap_flag_AreaName1--;
					continue;
				}
			if (soap_flag_AreaMap1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaMap", &(a->ns4__MapAreaInfo::AreaMap), "xsd:string"))
				{	soap_flag_AreaMap1--;
					continue;
				}
			if (soap_flag_MaxX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MaxX", &(a->ns4__MapAreaInfo::MaxX), "xsd:string"))
				{	soap_flag_MaxX1--;
					continue;
				}
			if (soap_flag_MaxY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MaxY", &(a->ns4__MapAreaInfo::MaxY), "xsd:string"))
				{	soap_flag_MaxY1--;
					continue;
				}
			if (soap_flag_MinX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MinX", &(a->ns4__MapAreaInfo::MinX), "xsd:string"))
				{	soap_flag_MinX1--;
					continue;
				}
			if (soap_flag_MinY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MinY", &(a->ns4__MapAreaInfo::MinY), "xsd:string"))
				{	soap_flag_MinY1--;
					continue;
				}
			if (soap_flag_ParentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ParentId", &(a->ns4__MapAreaInfo::ParentId), "xsd:string"))
				{	soap_flag_ParentId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__MapAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__MapAreaInfo, 0, sizeof(ns4__MapAreaInfo), 0, soap_copy_ns4__MapAreaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_AreaId1 > 0 || soap_flag_AreaName1 > 0 || soap_flag_AreaMap1 > 0 || soap_flag_MaxX1 > 0 || soap_flag_MaxY1 > 0 || soap_flag_MinX1 > 0 || soap_flag_MinY1 > 0 || soap_flag_ParentId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__MapAreaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__MapAreaInfo);
	if (this->soap_out(soap, tag?tag:"ns4:MapAreaInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__MapAreaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__MapAreaInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__MapAreaInfo * SOAP_FMAC4 soap_get_ns4__MapAreaInfo(struct soap *soap, ns4__MapAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__MapAreaInfo * SOAP_FMAC2 soap_instantiate_ns4__MapAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__MapAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__MapAreaInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__MapAreaInfo);
		if (size)
			*size = sizeof(ns4__MapAreaInfo);
		((ns4__MapAreaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__MapAreaInfo, n);
		if (size)
			*size = n * sizeof(ns4__MapAreaInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__MapAreaInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__MapAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__MapAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__MapAreaInfo %p -> %p\n", q, p));
	*(ns4__MapAreaInfo*)p = *(ns4__MapAreaInfo*)q;
}

void ns4__RobotAlarmInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(soap, &this->ns4__RobotAlarmInfos::Infos);
	/* transient soap skipped */
}

void ns4__RobotAlarmInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(soap, &this->ns4__RobotAlarmInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__RobotAlarmInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotAlarmInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotAlarmInfos(struct soap *soap, const char *tag, int id, const ns4__RobotAlarmInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotAlarmInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(soap, "Infos", -1, &(a->ns4__RobotAlarmInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotAlarmInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotAlarmInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotAlarmInfos * SOAP_FMAC4 soap_in_ns4__RobotAlarmInfos(struct soap *soap, const char *tag, ns4__RobotAlarmInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotAlarmInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotAlarmInfos, sizeof(ns4__RobotAlarmInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotAlarmInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotAlarmInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(soap, "Infos", &(a->ns4__RobotAlarmInfos::Infos), "ns4:RobotAlarmInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotAlarmInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotAlarmInfos, 0, sizeof(ns4__RobotAlarmInfos), 0, soap_copy_ns4__RobotAlarmInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__RobotAlarmInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotAlarmInfos);
	if (this->soap_out(soap, tag?tag:"ns4:RobotAlarmInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotAlarmInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotAlarmInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotAlarmInfos * SOAP_FMAC4 soap_get_ns4__RobotAlarmInfos(struct soap *soap, ns4__RobotAlarmInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotAlarmInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotAlarmInfos * SOAP_FMAC2 soap_instantiate_ns4__RobotAlarmInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotAlarmInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotAlarmInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotAlarmInfos);
		if (size)
			*size = sizeof(ns4__RobotAlarmInfos);
		((ns4__RobotAlarmInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotAlarmInfos, n);
		if (size)
			*size = n * sizeof(ns4__RobotAlarmInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotAlarmInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotAlarmInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotAlarmInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotAlarmInfos %p -> %p\n", q, p));
	*(ns4__RobotAlarmInfos*)p = *(ns4__RobotAlarmInfos*)q;
}

void ns4__RobotAlarmInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__RobotAlarmInfo::AlarmId);
	soap_default_std__string(soap, &this->ns4__RobotAlarmInfo::RobotIp);
	soap_default_std__string(soap, &this->ns4__RobotAlarmInfo::AlarmType);
	soap_default_std__string(soap, &this->ns4__RobotAlarmInfo::AlarmDesc);
	soap_default_std__string(soap, &this->ns4__RobotAlarmInfo::AlarmTime);
	/* transient soap skipped */
}

void ns4__RobotAlarmInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__RobotAlarmInfo::AlarmId);
	soap_serialize_std__string(soap, &this->ns4__RobotAlarmInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns4__RobotAlarmInfo::AlarmType);
	soap_serialize_std__string(soap, &this->ns4__RobotAlarmInfo::AlarmDesc);
	soap_serialize_std__string(soap, &this->ns4__RobotAlarmInfo::AlarmTime);
	/* transient soap skipped */
#endif
}

int ns4__RobotAlarmInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotAlarmInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotAlarmInfo(struct soap *soap, const char *tag, int id, const ns4__RobotAlarmInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotAlarmInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmId", -1, &(a->ns4__RobotAlarmInfo::AlarmId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__RobotAlarmInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmType", -1, &(a->ns4__RobotAlarmInfo::AlarmType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmDesc", -1, &(a->ns4__RobotAlarmInfo::AlarmDesc), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmTime", -1, &(a->ns4__RobotAlarmInfo::AlarmTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotAlarmInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotAlarmInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotAlarmInfo * SOAP_FMAC4 soap_in_ns4__RobotAlarmInfo(struct soap *soap, const char *tag, ns4__RobotAlarmInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotAlarmInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotAlarmInfo, sizeof(ns4__RobotAlarmInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotAlarmInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotAlarmInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AlarmId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_AlarmType1 = 1;
	size_t soap_flag_AlarmDesc1 = 1;
	size_t soap_flag_AlarmTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AlarmId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmId", &(a->ns4__RobotAlarmInfo::AlarmId), "xsd:string"))
				{	soap_flag_AlarmId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__RobotAlarmInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_AlarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmType", &(a->ns4__RobotAlarmInfo::AlarmType), "xsd:string"))
				{	soap_flag_AlarmType1--;
					continue;
				}
			if (soap_flag_AlarmDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmDesc", &(a->ns4__RobotAlarmInfo::AlarmDesc), "xsd:string"))
				{	soap_flag_AlarmDesc1--;
					continue;
				}
			if (soap_flag_AlarmTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmTime", &(a->ns4__RobotAlarmInfo::AlarmTime), "xsd:string"))
				{	soap_flag_AlarmTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotAlarmInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotAlarmInfo, 0, sizeof(ns4__RobotAlarmInfo), 0, soap_copy_ns4__RobotAlarmInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AlarmId1 > 0 || soap_flag_RobotIp1 > 0 || soap_flag_AlarmType1 > 0 || soap_flag_AlarmDesc1 > 0 || soap_flag_AlarmTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__RobotAlarmInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotAlarmInfo);
	if (this->soap_out(soap, tag?tag:"ns4:RobotAlarmInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotAlarmInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotAlarmInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotAlarmInfo * SOAP_FMAC4 soap_get_ns4__RobotAlarmInfo(struct soap *soap, ns4__RobotAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotAlarmInfo * SOAP_FMAC2 soap_instantiate_ns4__RobotAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotAlarmInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotAlarmInfo);
		if (size)
			*size = sizeof(ns4__RobotAlarmInfo);
		((ns4__RobotAlarmInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotAlarmInfo, n);
		if (size)
			*size = n * sizeof(ns4__RobotAlarmInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotAlarmInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotAlarmInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotAlarmInfo %p -> %p\n", q, p));
	*(ns4__RobotAlarmInfo*)p = *(ns4__RobotAlarmInfo*)q;
}

void ns4__RobotGasInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__RobotGasInfo(soap, &this->ns4__RobotGasInfos::GasContents);
	/* transient soap skipped */
}

void ns4__RobotGasInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__RobotGasInfo(soap, &this->ns4__RobotGasInfos::GasContents);
	/* transient soap skipped */
#endif
}

int ns4__RobotGasInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotGasInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotGasInfos(struct soap *soap, const char *tag, int id, const ns4__RobotGasInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotGasInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__RobotGasInfo(soap, "GasContents", -1, &(a->ns4__RobotGasInfos::GasContents), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotGasInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotGasInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotGasInfos * SOAP_FMAC4 soap_in_ns4__RobotGasInfos(struct soap *soap, const char *tag, ns4__RobotGasInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotGasInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotGasInfos, sizeof(ns4__RobotGasInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotGasInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotGasInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__RobotGasInfo(soap, "GasContents", &(a->ns4__RobotGasInfos::GasContents), "ns4:RobotGasInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotGasInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotGasInfos, 0, sizeof(ns4__RobotGasInfos), 0, soap_copy_ns4__RobotGasInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__RobotGasInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotGasInfos);
	if (this->soap_out(soap, tag?tag:"ns4:RobotGasInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotGasInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotGasInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotGasInfos * SOAP_FMAC4 soap_get_ns4__RobotGasInfos(struct soap *soap, ns4__RobotGasInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotGasInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotGasInfos * SOAP_FMAC2 soap_instantiate_ns4__RobotGasInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotGasInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotGasInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotGasInfos);
		if (size)
			*size = sizeof(ns4__RobotGasInfos);
		((ns4__RobotGasInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotGasInfos, n);
		if (size)
			*size = n * sizeof(ns4__RobotGasInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotGasInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotGasInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotGasInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotGasInfos %p -> %p\n", q, p));
	*(ns4__RobotGasInfos*)p = *(ns4__RobotGasInfos*)q;
}

void ns4__RobotGasInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::robot_ip);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::H2S);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::CO);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::O2);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::CH4);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::TEMP);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::HUM);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::PM25);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::PM10);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::O3);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::SF6);
	soap_default_std__string(soap, &this->ns4__RobotGasInfo::Desc);
	/* transient soap skipped */
}

void ns4__RobotGasInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::robot_ip);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::H2S);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::CO);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::O2);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::CH4);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::TEMP);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::HUM);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::PM25);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::PM10);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::O3);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::SF6);
	soap_serialize_std__string(soap, &this->ns4__RobotGasInfo::Desc);
	/* transient soap skipped */
#endif
}

int ns4__RobotGasInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotGasInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotGasInfo(struct soap *soap, const char *tag, int id, const ns4__RobotGasInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotGasInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "robot-ip", -1, &(a->ns4__RobotGasInfo::robot_ip), ""))
		return soap->error;
	if (soap_out_std__string(soap, "H2S", -1, &(a->ns4__RobotGasInfo::H2S), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CO", -1, &(a->ns4__RobotGasInfo::CO), ""))
		return soap->error;
	if (soap_out_std__string(soap, "O2", -1, &(a->ns4__RobotGasInfo::O2), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CH4", -1, &(a->ns4__RobotGasInfo::CH4), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TEMP", -1, &(a->ns4__RobotGasInfo::TEMP), ""))
		return soap->error;
	if (soap_out_std__string(soap, "HUM", -1, &(a->ns4__RobotGasInfo::HUM), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PM25", -1, &(a->ns4__RobotGasInfo::PM25), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PM10", -1, &(a->ns4__RobotGasInfo::PM10), ""))
		return soap->error;
	if (soap_out_std__string(soap, "O3", -1, &(a->ns4__RobotGasInfo::O3), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SF6", -1, &(a->ns4__RobotGasInfo::SF6), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Desc", -1, &(a->ns4__RobotGasInfo::Desc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotGasInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotGasInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotGasInfo * SOAP_FMAC4 soap_in_ns4__RobotGasInfo(struct soap *soap, const char *tag, ns4__RobotGasInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotGasInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotGasInfo, sizeof(ns4__RobotGasInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotGasInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotGasInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot_ip1 = 1;
	size_t soap_flag_H2S1 = 1;
	size_t soap_flag_CO1 = 1;
	size_t soap_flag_O21 = 1;
	size_t soap_flag_CH41 = 1;
	size_t soap_flag_TEMP1 = 1;
	size_t soap_flag_HUM1 = 1;
	size_t soap_flag_PM251 = 1;
	size_t soap_flag_PM101 = 1;
	size_t soap_flag_O31 = 1;
	size_t soap_flag_SF61 = 1;
	size_t soap_flag_Desc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot_ip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "robot-ip", &(a->ns4__RobotGasInfo::robot_ip), "xsd:string"))
				{	soap_flag_robot_ip1--;
					continue;
				}
			if (soap_flag_H2S1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "H2S", &(a->ns4__RobotGasInfo::H2S), "xsd:string"))
				{	soap_flag_H2S1--;
					continue;
				}
			if (soap_flag_CO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CO", &(a->ns4__RobotGasInfo::CO), "xsd:string"))
				{	soap_flag_CO1--;
					continue;
				}
			if (soap_flag_O21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "O2", &(a->ns4__RobotGasInfo::O2), "xsd:string"))
				{	soap_flag_O21--;
					continue;
				}
			if (soap_flag_CH41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CH4", &(a->ns4__RobotGasInfo::CH4), "xsd:string"))
				{	soap_flag_CH41--;
					continue;
				}
			if (soap_flag_TEMP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TEMP", &(a->ns4__RobotGasInfo::TEMP), "xsd:string"))
				{	soap_flag_TEMP1--;
					continue;
				}
			if (soap_flag_HUM1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HUM", &(a->ns4__RobotGasInfo::HUM), "xsd:string"))
				{	soap_flag_HUM1--;
					continue;
				}
			if (soap_flag_PM251 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PM25", &(a->ns4__RobotGasInfo::PM25), "xsd:string"))
				{	soap_flag_PM251--;
					continue;
				}
			if (soap_flag_PM101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PM10", &(a->ns4__RobotGasInfo::PM10), "xsd:string"))
				{	soap_flag_PM101--;
					continue;
				}
			if (soap_flag_O31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "O3", &(a->ns4__RobotGasInfo::O3), "xsd:string"))
				{	soap_flag_O31--;
					continue;
				}
			if (soap_flag_SF61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SF6", &(a->ns4__RobotGasInfo::SF6), "xsd:string"))
				{	soap_flag_SF61--;
					continue;
				}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Desc", &(a->ns4__RobotGasInfo::Desc), "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotGasInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotGasInfo, 0, sizeof(ns4__RobotGasInfo), 0, soap_copy_ns4__RobotGasInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot_ip1 > 0 || soap_flag_H2S1 > 0 || soap_flag_CO1 > 0 || soap_flag_O21 > 0 || soap_flag_CH41 > 0 || soap_flag_TEMP1 > 0 || soap_flag_HUM1 > 0 || soap_flag_PM251 > 0 || soap_flag_PM101 > 0 || soap_flag_O31 > 0 || soap_flag_SF61 > 0 || soap_flag_Desc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__RobotGasInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotGasInfo);
	if (this->soap_out(soap, tag?tag:"ns4:RobotGasInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotGasInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotGasInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotGasInfo * SOAP_FMAC4 soap_get_ns4__RobotGasInfo(struct soap *soap, ns4__RobotGasInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotGasInfo * SOAP_FMAC2 soap_instantiate_ns4__RobotGasInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotGasInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotGasInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotGasInfo);
		if (size)
			*size = sizeof(ns4__RobotGasInfo);
		((ns4__RobotGasInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotGasInfo, n);
		if (size)
			*size = n * sizeof(ns4__RobotGasInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotGasInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotGasInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotGasInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotGasInfo %p -> %p\n", q, p));
	*(ns4__RobotGasInfo*)p = *(ns4__RobotGasInfo*)q;
}

void ns4__RobotMileageInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__RobotMileageInfo(soap, &this->ns4__RobotMileageInfos::Infos);
	/* transient soap skipped */
}

void ns4__RobotMileageInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__RobotMileageInfo(soap, &this->ns4__RobotMileageInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__RobotMileageInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotMileageInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotMileageInfos(struct soap *soap, const char *tag, int id, const ns4__RobotMileageInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotMileageInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__RobotMileageInfo(soap, "Infos", -1, &(a->ns4__RobotMileageInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotMileageInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotMileageInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotMileageInfos * SOAP_FMAC4 soap_in_ns4__RobotMileageInfos(struct soap *soap, const char *tag, ns4__RobotMileageInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotMileageInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotMileageInfos, sizeof(ns4__RobotMileageInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotMileageInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotMileageInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__RobotMileageInfo(soap, "Infos", &(a->ns4__RobotMileageInfos::Infos), "ns4:RobotMileageInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotMileageInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotMileageInfos, 0, sizeof(ns4__RobotMileageInfos), 0, soap_copy_ns4__RobotMileageInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__RobotMileageInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotMileageInfos);
	if (this->soap_out(soap, tag?tag:"ns4:RobotMileageInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotMileageInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotMileageInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotMileageInfos * SOAP_FMAC4 soap_get_ns4__RobotMileageInfos(struct soap *soap, ns4__RobotMileageInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotMileageInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotMileageInfos * SOAP_FMAC2 soap_instantiate_ns4__RobotMileageInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotMileageInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotMileageInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotMileageInfos);
		if (size)
			*size = sizeof(ns4__RobotMileageInfos);
		((ns4__RobotMileageInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotMileageInfos, n);
		if (size)
			*size = n * sizeof(ns4__RobotMileageInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotMileageInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotMileageInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotMileageInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotMileageInfos %p -> %p\n", q, p));
	*(ns4__RobotMileageInfos*)p = *(ns4__RobotMileageInfos*)q;
}

void ns4__RobotMileageInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__RobotMileageInfo::RobotIp);
	soap_default_double(soap, &this->ns4__RobotMileageInfo::Mileage);
	/* transient soap skipped */
}

void ns4__RobotMileageInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__RobotMileageInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns4__RobotMileageInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotMileageInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotMileageInfo(struct soap *soap, const char *tag, int id, const ns4__RobotMileageInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotMileageInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__RobotMileageInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "Mileage", -1, &(a->ns4__RobotMileageInfo::Mileage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotMileageInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotMileageInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotMileageInfo * SOAP_FMAC4 soap_in_ns4__RobotMileageInfo(struct soap *soap, const char *tag, ns4__RobotMileageInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotMileageInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotMileageInfo, sizeof(ns4__RobotMileageInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotMileageInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotMileageInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_Mileage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__RobotMileageInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_Mileage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Mileage", &(a->ns4__RobotMileageInfo::Mileage), "xsd:double"))
				{	soap_flag_Mileage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotMileageInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotMileageInfo, 0, sizeof(ns4__RobotMileageInfo), 0, soap_copy_ns4__RobotMileageInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_Mileage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__RobotMileageInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotMileageInfo);
	if (this->soap_out(soap, tag?tag:"ns4:RobotMileageInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotMileageInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotMileageInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotMileageInfo * SOAP_FMAC4 soap_get_ns4__RobotMileageInfo(struct soap *soap, ns4__RobotMileageInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotMileageInfo * SOAP_FMAC2 soap_instantiate_ns4__RobotMileageInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotMileageInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotMileageInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotMileageInfo);
		if (size)
			*size = sizeof(ns4__RobotMileageInfo);
		((ns4__RobotMileageInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotMileageInfo, n);
		if (size)
			*size = n * sizeof(ns4__RobotMileageInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotMileageInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotMileageInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotMileageInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotMileageInfo %p -> %p\n", q, p));
	*(ns4__RobotMileageInfo*)p = *(ns4__RobotMileageInfo*)q;
}

void ns4__RobotYunTaiInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(soap, &this->ns4__RobotYunTaiInfos::Infos);
	/* transient soap skipped */
}

void ns4__RobotYunTaiInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(soap, &this->ns4__RobotYunTaiInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__RobotYunTaiInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotYunTaiInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotYunTaiInfos(struct soap *soap, const char *tag, int id, const ns4__RobotYunTaiInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(soap, "Infos", -1, &(a->ns4__RobotYunTaiInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotYunTaiInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotYunTaiInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotYunTaiInfos * SOAP_FMAC4 soap_in_ns4__RobotYunTaiInfos(struct soap *soap, const char *tag, ns4__RobotYunTaiInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotYunTaiInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos, sizeof(ns4__RobotYunTaiInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotYunTaiInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(soap, "Infos", &(a->ns4__RobotYunTaiInfos::Infos), "ns4:RobotYunTaiInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotYunTaiInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos, 0, sizeof(ns4__RobotYunTaiInfos), 0, soap_copy_ns4__RobotYunTaiInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__RobotYunTaiInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos);
	if (this->soap_out(soap, tag?tag:"ns4:RobotYunTaiInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotYunTaiInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotYunTaiInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotYunTaiInfos * SOAP_FMAC4 soap_get_ns4__RobotYunTaiInfos(struct soap *soap, ns4__RobotYunTaiInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotYunTaiInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotYunTaiInfos * SOAP_FMAC2 soap_instantiate_ns4__RobotYunTaiInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotYunTaiInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotYunTaiInfos);
		if (size)
			*size = sizeof(ns4__RobotYunTaiInfos);
		((ns4__RobotYunTaiInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotYunTaiInfos, n);
		if (size)
			*size = n * sizeof(ns4__RobotYunTaiInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotYunTaiInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotYunTaiInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotYunTaiInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotYunTaiInfos %p -> %p\n", q, p));
	*(ns4__RobotYunTaiInfos*)p = *(ns4__RobotYunTaiInfos*)q;
}

void ns4__RobotYunTaiInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__RobotYunTaiInfo::RobotIp);
	soap_default_std__string(soap, &this->ns4__RobotYunTaiInfo::PosPan);
	soap_default_std__string(soap, &this->ns4__RobotYunTaiInfo::PosTile);
	/* transient soap skipped */
}

void ns4__RobotYunTaiInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__RobotYunTaiInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns4__RobotYunTaiInfo::PosPan);
	soap_serialize_std__string(soap, &this->ns4__RobotYunTaiInfo::PosTile);
	/* transient soap skipped */
#endif
}

int ns4__RobotYunTaiInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotYunTaiInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, const ns4__RobotYunTaiInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__RobotYunTaiInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosPan", -1, &(a->ns4__RobotYunTaiInfo::PosPan), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosTile", -1, &(a->ns4__RobotYunTaiInfo::PosTile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotYunTaiInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotYunTaiInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotYunTaiInfo * SOAP_FMAC4 soap_in_ns4__RobotYunTaiInfo(struct soap *soap, const char *tag, ns4__RobotYunTaiInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotYunTaiInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo, sizeof(ns4__RobotYunTaiInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotYunTaiInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_PosPan1 = 1;
	size_t soap_flag_PosTile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__RobotYunTaiInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_PosPan1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosPan", &(a->ns4__RobotYunTaiInfo::PosPan), "xsd:string"))
				{	soap_flag_PosPan1--;
					continue;
				}
			if (soap_flag_PosTile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosTile", &(a->ns4__RobotYunTaiInfo::PosTile), "xsd:string"))
				{	soap_flag_PosTile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotYunTaiInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo, 0, sizeof(ns4__RobotYunTaiInfo), 0, soap_copy_ns4__RobotYunTaiInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_PosPan1 > 0 || soap_flag_PosTile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__RobotYunTaiInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo);
	if (this->soap_out(soap, tag?tag:"ns4:RobotYunTaiInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotYunTaiInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotYunTaiInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotYunTaiInfo * SOAP_FMAC4 soap_get_ns4__RobotYunTaiInfo(struct soap *soap, ns4__RobotYunTaiInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotYunTaiInfo * SOAP_FMAC2 soap_instantiate_ns4__RobotYunTaiInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotYunTaiInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotYunTaiInfo);
		if (size)
			*size = sizeof(ns4__RobotYunTaiInfo);
		((ns4__RobotYunTaiInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotYunTaiInfo, n);
		if (size)
			*size = n * sizeof(ns4__RobotYunTaiInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotYunTaiInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotYunTaiInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotYunTaiInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotYunTaiInfo %p -> %p\n", q, p));
	*(ns4__RobotYunTaiInfo*)p = *(ns4__RobotYunTaiInfo*)q;
}

void ns4__RobotPosInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__RobotPosInfo(soap, &this->ns4__RobotPosInfos::Infos);
	/* transient soap skipped */
}

void ns4__RobotPosInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__RobotPosInfo(soap, &this->ns4__RobotPosInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__RobotPosInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotPosInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotPosInfos(struct soap *soap, const char *tag, int id, const ns4__RobotPosInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotPosInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__RobotPosInfo(soap, "Infos", -1, &(a->ns4__RobotPosInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotPosInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotPosInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotPosInfos * SOAP_FMAC4 soap_in_ns4__RobotPosInfos(struct soap *soap, const char *tag, ns4__RobotPosInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotPosInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotPosInfos, sizeof(ns4__RobotPosInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotPosInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotPosInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__RobotPosInfo(soap, "Infos", &(a->ns4__RobotPosInfos::Infos), "ns4:RobotPosInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotPosInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotPosInfos, 0, sizeof(ns4__RobotPosInfos), 0, soap_copy_ns4__RobotPosInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__RobotPosInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotPosInfos);
	if (this->soap_out(soap, tag?tag:"ns4:RobotPosInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotPosInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotPosInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotPosInfos * SOAP_FMAC4 soap_get_ns4__RobotPosInfos(struct soap *soap, ns4__RobotPosInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotPosInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotPosInfos * SOAP_FMAC2 soap_instantiate_ns4__RobotPosInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotPosInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotPosInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotPosInfos);
		if (size)
			*size = sizeof(ns4__RobotPosInfos);
		((ns4__RobotPosInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotPosInfos, n);
		if (size)
			*size = n * sizeof(ns4__RobotPosInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotPosInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotPosInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotPosInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotPosInfos %p -> %p\n", q, p));
	*(ns4__RobotPosInfos*)p = *(ns4__RobotPosInfos*)q;
}

void ns4__RobotPosInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__RobotPosInfo::RobotIp);
	soap_default_std__string(soap, &this->ns4__RobotPosInfo::PosX);
	soap_default_std__string(soap, &this->ns4__RobotPosInfo::PosY);
	soap_default_std__string(soap, &this->ns4__RobotPosInfo::Angle);
	soap_default_std__string(soap, &this->ns4__RobotPosInfo::EdgeID);
	soap_default_std__string(soap, &this->ns4__RobotPosInfo::Precent);
	/* transient soap skipped */
}

void ns4__RobotPosInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__RobotPosInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns4__RobotPosInfo::PosX);
	soap_serialize_std__string(soap, &this->ns4__RobotPosInfo::PosY);
	soap_serialize_std__string(soap, &this->ns4__RobotPosInfo::Angle);
	soap_serialize_std__string(soap, &this->ns4__RobotPosInfo::EdgeID);
	soap_serialize_std__string(soap, &this->ns4__RobotPosInfo::Precent);
	/* transient soap skipped */
#endif
}

int ns4__RobotPosInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotPosInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotPosInfo(struct soap *soap, const char *tag, int id, const ns4__RobotPosInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotPosInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__RobotPosInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosX", -1, &(a->ns4__RobotPosInfo::PosX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosY", -1, &(a->ns4__RobotPosInfo::PosY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Angle", -1, &(a->ns4__RobotPosInfo::Angle), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EdgeID", -1, &(a->ns4__RobotPosInfo::EdgeID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Precent", -1, &(a->ns4__RobotPosInfo::Precent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotPosInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotPosInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotPosInfo * SOAP_FMAC4 soap_in_ns4__RobotPosInfo(struct soap *soap, const char *tag, ns4__RobotPosInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotPosInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotPosInfo, sizeof(ns4__RobotPosInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotPosInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotPosInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_PosX1 = 1;
	size_t soap_flag_PosY1 = 1;
	size_t soap_flag_Angle1 = 1;
	size_t soap_flag_EdgeID1 = 1;
	size_t soap_flag_Precent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__RobotPosInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_PosX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosX", &(a->ns4__RobotPosInfo::PosX), "xsd:string"))
				{	soap_flag_PosX1--;
					continue;
				}
			if (soap_flag_PosY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosY", &(a->ns4__RobotPosInfo::PosY), "xsd:string"))
				{	soap_flag_PosY1--;
					continue;
				}
			if (soap_flag_Angle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Angle", &(a->ns4__RobotPosInfo::Angle), "xsd:string"))
				{	soap_flag_Angle1--;
					continue;
				}
			if (soap_flag_EdgeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EdgeID", &(a->ns4__RobotPosInfo::EdgeID), "xsd:string"))
				{	soap_flag_EdgeID1--;
					continue;
				}
			if (soap_flag_Precent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Precent", &(a->ns4__RobotPosInfo::Precent), "xsd:string"))
				{	soap_flag_Precent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotPosInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotPosInfo, 0, sizeof(ns4__RobotPosInfo), 0, soap_copy_ns4__RobotPosInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_PosX1 > 0 || soap_flag_PosY1 > 0 || soap_flag_Angle1 > 0 || soap_flag_EdgeID1 > 0 || soap_flag_Precent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__RobotPosInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotPosInfo);
	if (this->soap_out(soap, tag?tag:"ns4:RobotPosInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotPosInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotPosInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotPosInfo * SOAP_FMAC4 soap_get_ns4__RobotPosInfo(struct soap *soap, ns4__RobotPosInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotPosInfo * SOAP_FMAC2 soap_instantiate_ns4__RobotPosInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotPosInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotPosInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotPosInfo);
		if (size)
			*size = sizeof(ns4__RobotPosInfo);
		((ns4__RobotPosInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotPosInfo, n);
		if (size)
			*size = n * sizeof(ns4__RobotPosInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotPosInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotPosInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotPosInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotPosInfo %p -> %p\n", q, p));
	*(ns4__RobotPosInfo*)p = *(ns4__RobotPosInfo*)q;
}

void ns4__RobotTaskStates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__RobotTaskState(soap, &this->ns4__RobotTaskStates::States);
	/* transient soap skipped */
}

void ns4__RobotTaskStates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__RobotTaskState(soap, &this->ns4__RobotTaskStates::States);
	/* transient soap skipped */
#endif
}

int ns4__RobotTaskStates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotTaskStates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotTaskStates(struct soap *soap, const char *tag, int id, const ns4__RobotTaskStates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotTaskStates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__RobotTaskState(soap, "States", -1, &(a->ns4__RobotTaskStates::States), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotTaskStates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotTaskStates(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotTaskStates * SOAP_FMAC4 soap_in_ns4__RobotTaskStates(struct soap *soap, const char *tag, ns4__RobotTaskStates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotTaskStates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotTaskStates, sizeof(ns4__RobotTaskStates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotTaskStates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotTaskStates *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__RobotTaskState(soap, "States", &(a->ns4__RobotTaskStates::States), "ns4:RobotTaskState"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotTaskStates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotTaskStates, 0, sizeof(ns4__RobotTaskStates), 0, soap_copy_ns4__RobotTaskStates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__RobotTaskStates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotTaskStates);
	if (this->soap_out(soap, tag?tag:"ns4:RobotTaskStates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotTaskStates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotTaskStates(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotTaskStates * SOAP_FMAC4 soap_get_ns4__RobotTaskStates(struct soap *soap, ns4__RobotTaskStates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotTaskStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotTaskStates * SOAP_FMAC2 soap_instantiate_ns4__RobotTaskStates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotTaskStates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotTaskStates, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotTaskStates);
		if (size)
			*size = sizeof(ns4__RobotTaskStates);
		((ns4__RobotTaskStates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotTaskStates, n);
		if (size)
			*size = n * sizeof(ns4__RobotTaskStates);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotTaskStates*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotTaskStates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotTaskStates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotTaskStates %p -> %p\n", q, p));
	*(ns4__RobotTaskStates*)p = *(ns4__RobotTaskStates*)q;
}

void ns4__RobotTaskState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__RobotTaskState::RobotIp);
	soap_default_std__string(soap, &this->ns4__RobotTaskState::TaskId);
	soap_default_std__string(soap, &this->ns4__RobotTaskState::TaskType);
	soap_default_std__string(soap, &this->ns4__RobotTaskState::TaskDesc);
	/* transient soap skipped */
}

void ns4__RobotTaskState::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__RobotTaskState::RobotIp);
	soap_serialize_std__string(soap, &this->ns4__RobotTaskState::TaskId);
	soap_serialize_std__string(soap, &this->ns4__RobotTaskState::TaskType);
	soap_serialize_std__string(soap, &this->ns4__RobotTaskState::TaskDesc);
	/* transient soap skipped */
#endif
}

int ns4__RobotTaskState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotTaskState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotTaskState(struct soap *soap, const char *tag, int id, const ns4__RobotTaskState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotTaskState), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__RobotTaskState::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns4__RobotTaskState::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns4__RobotTaskState::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskDesc", -1, &(a->ns4__RobotTaskState::TaskDesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotTaskState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotTaskState(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotTaskState * SOAP_FMAC4 soap_in_ns4__RobotTaskState(struct soap *soap, const char *tag, ns4__RobotTaskState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotTaskState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotTaskState, sizeof(ns4__RobotTaskState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotTaskState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotTaskState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskDesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__RobotTaskState::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns4__RobotTaskState::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns4__RobotTaskState::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskDesc", &(a->ns4__RobotTaskState::TaskDesc), "xsd:string"))
				{	soap_flag_TaskDesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotTaskState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotTaskState, 0, sizeof(ns4__RobotTaskState), 0, soap_copy_ns4__RobotTaskState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_TaskId1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskDesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__RobotTaskState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotTaskState);
	if (this->soap_out(soap, tag?tag:"ns4:RobotTaskState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotTaskState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotTaskState(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotTaskState * SOAP_FMAC4 soap_get_ns4__RobotTaskState(struct soap *soap, ns4__RobotTaskState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotTaskState * SOAP_FMAC2 soap_instantiate_ns4__RobotTaskState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotTaskState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotTaskState, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotTaskState);
		if (size)
			*size = sizeof(ns4__RobotTaskState);
		((ns4__RobotTaskState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotTaskState, n);
		if (size)
			*size = n * sizeof(ns4__RobotTaskState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotTaskState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotTaskState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotTaskState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotTaskState %p -> %p\n", q, p));
	*(ns4__RobotTaskState*)p = *(ns4__RobotTaskState*)q;
}

void ns4__SpeedInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__SpeedInfo(soap, &this->ns4__SpeedInfos::Infos);
	/* transient soap skipped */
}

void ns4__SpeedInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__SpeedInfo(soap, &this->ns4__SpeedInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__SpeedInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__SpeedInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SpeedInfos(struct soap *soap, const char *tag, int id, const ns4__SpeedInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__SpeedInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__SpeedInfo(soap, "Infos", -1, &(a->ns4__SpeedInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__SpeedInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__SpeedInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__SpeedInfos * SOAP_FMAC4 soap_in_ns4__SpeedInfos(struct soap *soap, const char *tag, ns4__SpeedInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__SpeedInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__SpeedInfos, sizeof(ns4__SpeedInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__SpeedInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__SpeedInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__SpeedInfo(soap, "Infos", &(a->ns4__SpeedInfos::Infos), "ns4:SpeedInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__SpeedInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__SpeedInfos, 0, sizeof(ns4__SpeedInfos), 0, soap_copy_ns4__SpeedInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__SpeedInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__SpeedInfos);
	if (this->soap_out(soap, tag?tag:"ns4:SpeedInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__SpeedInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__SpeedInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__SpeedInfos * SOAP_FMAC4 soap_get_ns4__SpeedInfos(struct soap *soap, ns4__SpeedInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SpeedInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__SpeedInfos * SOAP_FMAC2 soap_instantiate_ns4__SpeedInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SpeedInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__SpeedInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__SpeedInfos);
		if (size)
			*size = sizeof(ns4__SpeedInfos);
		((ns4__SpeedInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__SpeedInfos, n);
		if (size)
			*size = n * sizeof(ns4__SpeedInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__SpeedInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__SpeedInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__SpeedInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__SpeedInfos %p -> %p\n", q, p));
	*(ns4__SpeedInfos*)p = *(ns4__SpeedInfos*)q;
}

void ns4__SpeedInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__SpeedInfo::RobotIp);
	soap_default_double(soap, &this->ns4__SpeedInfo::Speed);
	/* transient soap skipped */
}

void ns4__SpeedInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__SpeedInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns4__SpeedInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__SpeedInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SpeedInfo(struct soap *soap, const char *tag, int id, const ns4__SpeedInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__SpeedInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__SpeedInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "Speed", -1, &(a->ns4__SpeedInfo::Speed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__SpeedInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__SpeedInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__SpeedInfo * SOAP_FMAC4 soap_in_ns4__SpeedInfo(struct soap *soap, const char *tag, ns4__SpeedInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__SpeedInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__SpeedInfo, sizeof(ns4__SpeedInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__SpeedInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__SpeedInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__SpeedInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Speed", &(a->ns4__SpeedInfo::Speed), "xsd:double"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__SpeedInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__SpeedInfo, 0, sizeof(ns4__SpeedInfo), 0, soap_copy_ns4__SpeedInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_Speed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__SpeedInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__SpeedInfo);
	if (this->soap_out(soap, tag?tag:"ns4:SpeedInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__SpeedInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__SpeedInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__SpeedInfo * SOAP_FMAC4 soap_get_ns4__SpeedInfo(struct soap *soap, ns4__SpeedInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__SpeedInfo * SOAP_FMAC2 soap_instantiate_ns4__SpeedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SpeedInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__SpeedInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__SpeedInfo);
		if (size)
			*size = sizeof(ns4__SpeedInfo);
		((ns4__SpeedInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__SpeedInfo, n);
		if (size)
			*size = n * sizeof(ns4__SpeedInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__SpeedInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__SpeedInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__SpeedInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__SpeedInfo %p -> %p\n", q, p));
	*(ns4__SpeedInfo*)p = *(ns4__SpeedInfo*)q;
}

void ns4__BatteryInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__BatteryInfo(soap, &this->ns4__BatteryInfos::Infos);
	/* transient soap skipped */
}

void ns4__BatteryInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__BatteryInfo(soap, &this->ns4__BatteryInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__BatteryInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__BatteryInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__BatteryInfos(struct soap *soap, const char *tag, int id, const ns4__BatteryInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__BatteryInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__BatteryInfo(soap, "Infos", -1, &(a->ns4__BatteryInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__BatteryInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__BatteryInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__BatteryInfos * SOAP_FMAC4 soap_in_ns4__BatteryInfos(struct soap *soap, const char *tag, ns4__BatteryInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__BatteryInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__BatteryInfos, sizeof(ns4__BatteryInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__BatteryInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__BatteryInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__BatteryInfo(soap, "Infos", &(a->ns4__BatteryInfos::Infos), "ns4:BatteryInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__BatteryInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__BatteryInfos, 0, sizeof(ns4__BatteryInfos), 0, soap_copy_ns4__BatteryInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__BatteryInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__BatteryInfos);
	if (this->soap_out(soap, tag?tag:"ns4:BatteryInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__BatteryInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__BatteryInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__BatteryInfos * SOAP_FMAC4 soap_get_ns4__BatteryInfos(struct soap *soap, ns4__BatteryInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__BatteryInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__BatteryInfos * SOAP_FMAC2 soap_instantiate_ns4__BatteryInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__BatteryInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__BatteryInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__BatteryInfos);
		if (size)
			*size = sizeof(ns4__BatteryInfos);
		((ns4__BatteryInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__BatteryInfos, n);
		if (size)
			*size = n * sizeof(ns4__BatteryInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__BatteryInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__BatteryInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__BatteryInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__BatteryInfos %p -> %p\n", q, p));
	*(ns4__BatteryInfos*)p = *(ns4__BatteryInfos*)q;
}

void ns4__BatteryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__BatteryInfo::RobotIp);
	soap_default_double(soap, &this->ns4__BatteryInfo::BatteryValue);
	soap_default_double(soap, &this->ns4__BatteryInfo::BatteryPercent);
	/* transient soap skipped */
}

void ns4__BatteryInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__BatteryInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns4__BatteryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__BatteryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__BatteryInfo(struct soap *soap, const char *tag, int id, const ns4__BatteryInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__BatteryInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__BatteryInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "BatteryValue", -1, &(a->ns4__BatteryInfo::BatteryValue), ""))
		return soap->error;
	if (soap_out_double(soap, "BatteryPercent", -1, &(a->ns4__BatteryInfo::BatteryPercent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__BatteryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__BatteryInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__BatteryInfo * SOAP_FMAC4 soap_in_ns4__BatteryInfo(struct soap *soap, const char *tag, ns4__BatteryInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__BatteryInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__BatteryInfo, sizeof(ns4__BatteryInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__BatteryInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__BatteryInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_BatteryValue1 = 1;
	size_t soap_flag_BatteryPercent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__BatteryInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_BatteryValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BatteryValue", &(a->ns4__BatteryInfo::BatteryValue), "xsd:double"))
				{	soap_flag_BatteryValue1--;
					continue;
				}
			if (soap_flag_BatteryPercent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BatteryPercent", &(a->ns4__BatteryInfo::BatteryPercent), "xsd:double"))
				{	soap_flag_BatteryPercent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__BatteryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__BatteryInfo, 0, sizeof(ns4__BatteryInfo), 0, soap_copy_ns4__BatteryInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_BatteryValue1 > 0 || soap_flag_BatteryPercent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__BatteryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__BatteryInfo);
	if (this->soap_out(soap, tag?tag:"ns4:BatteryInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__BatteryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__BatteryInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__BatteryInfo * SOAP_FMAC4 soap_get_ns4__BatteryInfo(struct soap *soap, ns4__BatteryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__BatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__BatteryInfo * SOAP_FMAC2 soap_instantiate_ns4__BatteryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__BatteryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__BatteryInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__BatteryInfo);
		if (size)
			*size = sizeof(ns4__BatteryInfo);
		((ns4__BatteryInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__BatteryInfo, n);
		if (size)
			*size = n * sizeof(ns4__BatteryInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__BatteryInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__BatteryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__BatteryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__BatteryInfo %p -> %p\n", q, p));
	*(ns4__BatteryInfo*)p = *(ns4__BatteryInfo*)q;
}

void ns4__RobotInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__RobotInfo(soap, &this->ns4__RobotInfos::Infos);
	/* transient soap skipped */
}

void ns4__RobotInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__RobotInfo(soap, &this->ns4__RobotInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__RobotInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotInfos(struct soap *soap, const char *tag, int id, const ns4__RobotInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__RobotInfo(soap, "Infos", -1, &(a->ns4__RobotInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotInfos * SOAP_FMAC4 soap_in_ns4__RobotInfos(struct soap *soap, const char *tag, ns4__RobotInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotInfos, sizeof(ns4__RobotInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__RobotInfo(soap, "Infos", &(a->ns4__RobotInfos::Infos), "ns4:RobotInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotInfos, 0, sizeof(ns4__RobotInfos), 0, soap_copy_ns4__RobotInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__RobotInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotInfos);
	if (this->soap_out(soap, tag?tag:"ns4:RobotInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotInfos * SOAP_FMAC4 soap_get_ns4__RobotInfos(struct soap *soap, ns4__RobotInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotInfos * SOAP_FMAC2 soap_instantiate_ns4__RobotInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotInfos);
		if (size)
			*size = sizeof(ns4__RobotInfos);
		((ns4__RobotInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotInfos, n);
		if (size)
			*size = n * sizeof(ns4__RobotInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotInfos %p -> %p\n", q, p));
	*(ns4__RobotInfos*)p = *(ns4__RobotInfos*)q;
}

void ns4__RobotInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__RobotInfo::RobotName);
	soap_default_std__string(soap, &this->ns4__RobotInfo::RobotIp);
	soap_default_std__string(soap, &this->ns4__RobotInfo::CameraIp);
	soap_default_int(soap, &this->ns4__RobotInfo::CameraPort);
	soap_default_std__string(soap, &this->ns4__RobotInfo::FlirIp);
	soap_default_int(soap, &this->ns4__RobotInfo::FlirPort);
	soap_default_std__string(soap, &this->ns4__RobotInfo::CameraUser);
	soap_default_std__string(soap, &this->ns4__RobotInfo::CameraPassword);
	soap_default_std__string(soap, &this->ns4__RobotInfo::FlirUser);
	soap_default_std__string(soap, &this->ns4__RobotInfo::FlirPassword);
	/* transient soap skipped */
}

void ns4__RobotInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__RobotInfo::RobotName);
	soap_serialize_std__string(soap, &this->ns4__RobotInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns4__RobotInfo::CameraIp);
	soap_serialize_std__string(soap, &this->ns4__RobotInfo::FlirIp);
	soap_serialize_std__string(soap, &this->ns4__RobotInfo::CameraUser);
	soap_serialize_std__string(soap, &this->ns4__RobotInfo::CameraPassword);
	soap_serialize_std__string(soap, &this->ns4__RobotInfo::FlirUser);
	soap_serialize_std__string(soap, &this->ns4__RobotInfo::FlirPassword);
	/* transient soap skipped */
#endif
}

int ns4__RobotInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RobotInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RobotInfo(struct soap *soap, const char *tag, int id, const ns4__RobotInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__RobotInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotName", -1, &(a->ns4__RobotInfo::RobotName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__RobotInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraIp", -1, &(a->ns4__RobotInfo::CameraIp), ""))
		return soap->error;
	if (soap_out_int(soap, "CameraPort", -1, &(a->ns4__RobotInfo::CameraPort), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirIp", -1, &(a->ns4__RobotInfo::FlirIp), ""))
		return soap->error;
	if (soap_out_int(soap, "FlirPort", -1, &(a->ns4__RobotInfo::FlirPort), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraUser", -1, &(a->ns4__RobotInfo::CameraUser), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraPassword", -1, &(a->ns4__RobotInfo::CameraPassword), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirUser", -1, &(a->ns4__RobotInfo::FlirUser), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirPassword", -1, &(a->ns4__RobotInfo::FlirPassword), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__RobotInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RobotInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RobotInfo * SOAP_FMAC4 soap_in_ns4__RobotInfo(struct soap *soap, const char *tag, ns4__RobotInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RobotInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__RobotInfo, sizeof(ns4__RobotInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__RobotInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RobotInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotName1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_CameraIp1 = 1;
	size_t soap_flag_CameraPort1 = 1;
	size_t soap_flag_FlirIp1 = 1;
	size_t soap_flag_FlirPort1 = 1;
	size_t soap_flag_CameraUser1 = 1;
	size_t soap_flag_CameraPassword1 = 1;
	size_t soap_flag_FlirUser1 = 1;
	size_t soap_flag_FlirPassword1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotName", &(a->ns4__RobotInfo::RobotName), "xsd:string"))
				{	soap_flag_RobotName1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__RobotInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_CameraIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraIp", &(a->ns4__RobotInfo::CameraIp), "xsd:string"))
				{	soap_flag_CameraIp1--;
					continue;
				}
			if (soap_flag_CameraPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CameraPort", &(a->ns4__RobotInfo::CameraPort), "xsd:int"))
				{	soap_flag_CameraPort1--;
					continue;
				}
			if (soap_flag_FlirIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirIp", &(a->ns4__RobotInfo::FlirIp), "xsd:string"))
				{	soap_flag_FlirIp1--;
					continue;
				}
			if (soap_flag_FlirPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FlirPort", &(a->ns4__RobotInfo::FlirPort), "xsd:int"))
				{	soap_flag_FlirPort1--;
					continue;
				}
			if (soap_flag_CameraUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraUser", &(a->ns4__RobotInfo::CameraUser), "xsd:string"))
				{	soap_flag_CameraUser1--;
					continue;
				}
			if (soap_flag_CameraPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraPassword", &(a->ns4__RobotInfo::CameraPassword), "xsd:string"))
				{	soap_flag_CameraPassword1--;
					continue;
				}
			if (soap_flag_FlirUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirUser", &(a->ns4__RobotInfo::FlirUser), "xsd:string"))
				{	soap_flag_FlirUser1--;
					continue;
				}
			if (soap_flag_FlirPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirPassword", &(a->ns4__RobotInfo::FlirPassword), "xsd:string"))
				{	soap_flag_FlirPassword1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RobotInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__RobotInfo, 0, sizeof(ns4__RobotInfo), 0, soap_copy_ns4__RobotInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotName1 > 0 || soap_flag_RobotIp1 > 0 || soap_flag_CameraIp1 > 0 || soap_flag_CameraPort1 > 0 || soap_flag_FlirIp1 > 0 || soap_flag_FlirPort1 > 0 || soap_flag_CameraUser1 > 0 || soap_flag_CameraPassword1 > 0 || soap_flag_FlirUser1 > 0 || soap_flag_FlirPassword1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__RobotInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__RobotInfo);
	if (this->soap_out(soap, tag?tag:"ns4:RobotInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__RobotInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RobotInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RobotInfo * SOAP_FMAC4 soap_get_ns4__RobotInfo(struct soap *soap, ns4__RobotInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__RobotInfo * SOAP_FMAC2 soap_instantiate_ns4__RobotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RobotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__RobotInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__RobotInfo);
		if (size)
			*size = sizeof(ns4__RobotInfo);
		((ns4__RobotInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__RobotInfo, n);
		if (size)
			*size = n * sizeof(ns4__RobotInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__RobotInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__RobotInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RobotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RobotInfo %p -> %p\n", q, p));
	*(ns4__RobotInfo*)p = *(ns4__RobotInfo*)q;
}

void ns4__ConnectInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__ConnectInfo(soap, &this->ns4__ConnectInfos::Infos);
	/* transient soap skipped */
}

void ns4__ConnectInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__ConnectInfo(soap, &this->ns4__ConnectInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns4__ConnectInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ConnectInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ConnectInfos(struct soap *soap, const char *tag, int id, const ns4__ConnectInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__ConnectInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__ConnectInfo(soap, "Infos", -1, &(a->ns4__ConnectInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__ConnectInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ConnectInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ConnectInfos * SOAP_FMAC4 soap_in_ns4__ConnectInfos(struct soap *soap, const char *tag, ns4__ConnectInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ConnectInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__ConnectInfos, sizeof(ns4__ConnectInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__ConnectInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ConnectInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__ConnectInfo(soap, "Infos", &(a->ns4__ConnectInfos::Infos), "ns4:ConnectInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ConnectInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__ConnectInfos, 0, sizeof(ns4__ConnectInfos), 0, soap_copy_ns4__ConnectInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__ConnectInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__ConnectInfos);
	if (this->soap_out(soap, tag?tag:"ns4:ConnectInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ConnectInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ConnectInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ConnectInfos * SOAP_FMAC4 soap_get_ns4__ConnectInfos(struct soap *soap, ns4__ConnectInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ConnectInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__ConnectInfos * SOAP_FMAC2 soap_instantiate_ns4__ConnectInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ConnectInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__ConnectInfos, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__ConnectInfos);
		if (size)
			*size = sizeof(ns4__ConnectInfos);
		((ns4__ConnectInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__ConnectInfos, n);
		if (size)
			*size = n * sizeof(ns4__ConnectInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__ConnectInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__ConnectInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ConnectInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ConnectInfos %p -> %p\n", q, p));
	*(ns4__ConnectInfos*)p = *(ns4__ConnectInfos*)q;
}

void ns4__ConnectInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns4__ConnectInfo::RobotIp);
	soap_default_bool(soap, &this->ns4__ConnectInfo::State);
	soap_default_std__string(soap, &this->ns4__ConnectInfo::ConnectDesc);
	/* transient soap skipped */
}

void ns4__ConnectInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns4__ConnectInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns4__ConnectInfo::ConnectDesc);
	/* transient soap skipped */
#endif
}

int ns4__ConnectInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ConnectInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ConnectInfo(struct soap *soap, const char *tag, int id, const ns4__ConnectInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_ns4__ConnectInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns4__ConnectInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_bool(soap, "State", -1, &(a->ns4__ConnectInfo::State), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ConnectDesc", -1, &(a->ns4__ConnectInfo::ConnectDesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__ConnectInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ConnectInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ConnectInfo * SOAP_FMAC4 soap_in_ns4__ConnectInfo(struct soap *soap, const char *tag, ns4__ConnectInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ConnectInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_ns4__ConnectInfo, sizeof(ns4__ConnectInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskData_ns4__ConnectInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ConnectInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_State1 = 1;
	size_t soap_flag_ConnectDesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns4__ConnectInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "State", &(a->ns4__ConnectInfo::State), "xsd:boolean"))
				{	soap_flag_State1--;
					continue;
				}
			if (soap_flag_ConnectDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ConnectDesc", &(a->ns4__ConnectInfo::ConnectDesc), "xsd:string"))
				{	soap_flag_ConnectDesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ConnectInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_ns4__ConnectInfo, 0, sizeof(ns4__ConnectInfo), 0, soap_copy_ns4__ConnectInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_State1 > 0 || soap_flag_ConnectDesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__ConnectInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskData_ns4__ConnectInfo);
	if (this->soap_out(soap, tag?tag:"ns4:ConnectInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ConnectInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ConnectInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ConnectInfo * SOAP_FMAC4 soap_get_ns4__ConnectInfo(struct soap *soap, ns4__ConnectInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ConnectInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__ConnectInfo * SOAP_FMAC2 soap_instantiate_ns4__ConnectInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ConnectInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_ns4__ConnectInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__ConnectInfo);
		if (size)
			*size = sizeof(ns4__ConnectInfo);
		((ns4__ConnectInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__ConnectInfo, n);
		if (size)
			*size = n * sizeof(ns4__ConnectInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__ConnectInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__ConnectInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ConnectInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ConnectInfo %p -> %p\n", q, p));
	*(ns4__ConnectInfo*)p = *(ns4__ConnectInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_SOAP_ENV__Fault, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_SOAP_ENV__Reason, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_SOAP_ENV__Detail, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_SOAP_ENV__Code, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskData_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskData_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskData_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_SOAP_ENV__Header, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTaskExcuteData(struct soap *soap, struct __ns1__GetTaskExcuteData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__GetTaskExcuteData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTaskExcuteData(struct soap *soap, const struct __ns1__GetTaskExcuteData *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__GetTaskExcuteData(soap, &a->ns4__GetTaskExcuteData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTaskExcuteData(struct soap *soap, const char *tag, int id, const struct __ns1__GetTaskExcuteData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__GetTaskExcuteData(soap, "ns4:GetTaskExcuteData", -1, &a->ns4__GetTaskExcuteData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskExcuteData * SOAP_FMAC4 soap_in___ns1__GetTaskExcuteData(struct soap *soap, const char *tag, struct __ns1__GetTaskExcuteData *a, const char *type)
{
	size_t soap_flag_ns4__GetTaskExcuteData = 1;
	short soap_flag;
	a = (struct __ns1__GetTaskExcuteData *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__GetTaskExcuteData, sizeof(struct __ns1__GetTaskExcuteData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTaskExcuteData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__GetTaskExcuteData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__GetTaskExcuteData(soap, "ns4:GetTaskExcuteData", &a->ns4__GetTaskExcuteData, ""))
				{	soap_flag_ns4__GetTaskExcuteData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTaskExcuteData(struct soap *soap, const struct __ns1__GetTaskExcuteData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTaskExcuteData(soap, tag?tag:"-ns1:GetTaskExcuteData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskExcuteData * SOAP_FMAC4 soap_get___ns1__GetTaskExcuteData(struct soap *soap, struct __ns1__GetTaskExcuteData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTaskExcuteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetTaskExcuteData * SOAP_FMAC2 soap_instantiate___ns1__GetTaskExcuteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTaskExcuteData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__GetTaskExcuteData, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetTaskExcuteData);
		if (size)
			*size = sizeof(struct __ns1__GetTaskExcuteData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetTaskExcuteData, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetTaskExcuteData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetTaskExcuteData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTaskExcuteData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTaskExcuteData %p -> %p\n", q, p));
	*(struct __ns1__GetTaskExcuteData*)p = *(struct __ns1__GetTaskExcuteData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RobotControlTask(struct soap *soap, struct __ns1__RobotControlTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__RobotControlTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RobotControlTask(struct soap *soap, const struct __ns1__RobotControlTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__RobotControlTask(soap, &a->ns4__RobotControlTask);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RobotControlTask(struct soap *soap, const char *tag, int id, const struct __ns1__RobotControlTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__RobotControlTask(soap, "ns4:RobotControlTask", -1, &a->ns4__RobotControlTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotControlTask * SOAP_FMAC4 soap_in___ns1__RobotControlTask(struct soap *soap, const char *tag, struct __ns1__RobotControlTask *a, const char *type)
{
	size_t soap_flag_ns4__RobotControlTask = 1;
	short soap_flag;
	a = (struct __ns1__RobotControlTask *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__RobotControlTask, sizeof(struct __ns1__RobotControlTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RobotControlTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__RobotControlTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__RobotControlTask(soap, "ns4:RobotControlTask", &a->ns4__RobotControlTask, ""))
				{	soap_flag_ns4__RobotControlTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RobotControlTask(struct soap *soap, const struct __ns1__RobotControlTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RobotControlTask(soap, tag?tag:"-ns1:RobotControlTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RobotControlTask * SOAP_FMAC4 soap_get___ns1__RobotControlTask(struct soap *soap, struct __ns1__RobotControlTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RobotControlTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RobotControlTask * SOAP_FMAC2 soap_instantiate___ns1__RobotControlTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RobotControlTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__RobotControlTask, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RobotControlTask);
		if (size)
			*size = sizeof(struct __ns1__RobotControlTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RobotControlTask, n);
		if (size)
			*size = n * sizeof(struct __ns1__RobotControlTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RobotControlTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RobotControlTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RobotControlTask %p -> %p\n", q, p));
	*(struct __ns1__RobotControlTask*)p = *(struct __ns1__RobotControlTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetTaskPathInfo(struct soap *soap, struct __ns1__SetTaskPathInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__SetTaskPathInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetTaskPathInfo(struct soap *soap, const struct __ns1__SetTaskPathInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__SetTaskPathInfo(soap, &a->ns4__SetTaskPathInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetTaskPathInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SetTaskPathInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__SetTaskPathInfo(soap, "ns4:SetTaskPathInfo", -1, &a->ns4__SetTaskPathInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetTaskPathInfo * SOAP_FMAC4 soap_in___ns1__SetTaskPathInfo(struct soap *soap, const char *tag, struct __ns1__SetTaskPathInfo *a, const char *type)
{
	size_t soap_flag_ns4__SetTaskPathInfo = 1;
	short soap_flag;
	a = (struct __ns1__SetTaskPathInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__SetTaskPathInfo, sizeof(struct __ns1__SetTaskPathInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetTaskPathInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__SetTaskPathInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__SetTaskPathInfo(soap, "ns4:SetTaskPathInfo", &a->ns4__SetTaskPathInfo, ""))
				{	soap_flag_ns4__SetTaskPathInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetTaskPathInfo(struct soap *soap, const struct __ns1__SetTaskPathInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetTaskPathInfo(soap, tag?tag:"-ns1:SetTaskPathInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetTaskPathInfo * SOAP_FMAC4 soap_get___ns1__SetTaskPathInfo(struct soap *soap, struct __ns1__SetTaskPathInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetTaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetTaskPathInfo * SOAP_FMAC2 soap_instantiate___ns1__SetTaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetTaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__SetTaskPathInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetTaskPathInfo);
		if (size)
			*size = sizeof(struct __ns1__SetTaskPathInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetTaskPathInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetTaskPathInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetTaskPathInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetTaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetTaskPathInfo %p -> %p\n", q, p));
	*(struct __ns1__SetTaskPathInfo*)p = *(struct __ns1__SetTaskPathInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__StartTaskByPointList(struct soap *soap, struct __ns1__StartTaskByPointList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__StartTaskByPointList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__StartTaskByPointList(struct soap *soap, const struct __ns1__StartTaskByPointList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__StartTaskByPointList(soap, &a->ns4__StartTaskByPointList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__StartTaskByPointList(struct soap *soap, const char *tag, int id, const struct __ns1__StartTaskByPointList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__StartTaskByPointList(soap, "ns4:StartTaskByPointList", -1, &a->ns4__StartTaskByPointList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StartTaskByPointList * SOAP_FMAC4 soap_in___ns1__StartTaskByPointList(struct soap *soap, const char *tag, struct __ns1__StartTaskByPointList *a, const char *type)
{
	size_t soap_flag_ns4__StartTaskByPointList = 1;
	short soap_flag;
	a = (struct __ns1__StartTaskByPointList *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__StartTaskByPointList, sizeof(struct __ns1__StartTaskByPointList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__StartTaskByPointList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__StartTaskByPointList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__StartTaskByPointList(soap, "ns4:StartTaskByPointList", &a->ns4__StartTaskByPointList, ""))
				{	soap_flag_ns4__StartTaskByPointList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__StartTaskByPointList(struct soap *soap, const struct __ns1__StartTaskByPointList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__StartTaskByPointList(soap, tag?tag:"-ns1:StartTaskByPointList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StartTaskByPointList * SOAP_FMAC4 soap_get___ns1__StartTaskByPointList(struct soap *soap, struct __ns1__StartTaskByPointList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__StartTaskByPointList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__StartTaskByPointList * SOAP_FMAC2 soap_instantiate___ns1__StartTaskByPointList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__StartTaskByPointList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__StartTaskByPointList, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__StartTaskByPointList);
		if (size)
			*size = sizeof(struct __ns1__StartTaskByPointList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__StartTaskByPointList, n);
		if (size)
			*size = n * sizeof(struct __ns1__StartTaskByPointList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__StartTaskByPointList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__StartTaskByPointList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__StartTaskByPointList %p -> %p\n", q, p));
	*(struct __ns1__StartTaskByPointList*)p = *(struct __ns1__StartTaskByPointList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__StartTaskByPathId(struct soap *soap, struct __ns1__StartTaskByPathId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__StartTaskByPathId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__StartTaskByPathId(struct soap *soap, const struct __ns1__StartTaskByPathId *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__StartTaskByPathId(soap, &a->ns4__StartTaskByPathId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__StartTaskByPathId(struct soap *soap, const char *tag, int id, const struct __ns1__StartTaskByPathId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__StartTaskByPathId(soap, "ns4:StartTaskByPathId", -1, &a->ns4__StartTaskByPathId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StartTaskByPathId * SOAP_FMAC4 soap_in___ns1__StartTaskByPathId(struct soap *soap, const char *tag, struct __ns1__StartTaskByPathId *a, const char *type)
{
	size_t soap_flag_ns4__StartTaskByPathId = 1;
	short soap_flag;
	a = (struct __ns1__StartTaskByPathId *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__StartTaskByPathId, sizeof(struct __ns1__StartTaskByPathId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__StartTaskByPathId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__StartTaskByPathId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__StartTaskByPathId(soap, "ns4:StartTaskByPathId", &a->ns4__StartTaskByPathId, ""))
				{	soap_flag_ns4__StartTaskByPathId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__StartTaskByPathId(struct soap *soap, const struct __ns1__StartTaskByPathId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__StartTaskByPathId(soap, tag?tag:"-ns1:StartTaskByPathId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StartTaskByPathId * SOAP_FMAC4 soap_get___ns1__StartTaskByPathId(struct soap *soap, struct __ns1__StartTaskByPathId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__StartTaskByPathId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__StartTaskByPathId * SOAP_FMAC2 soap_instantiate___ns1__StartTaskByPathId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__StartTaskByPathId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__StartTaskByPathId, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__StartTaskByPathId);
		if (size)
			*size = sizeof(struct __ns1__StartTaskByPathId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__StartTaskByPathId, n);
		if (size)
			*size = n * sizeof(struct __ns1__StartTaskByPathId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__StartTaskByPathId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__StartTaskByPathId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__StartTaskByPathId %p -> %p\n", q, p));
	*(struct __ns1__StartTaskByPathId*)p = *(struct __ns1__StartTaskByPathId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTaskPathInfo(struct soap *soap, struct __ns1__GetTaskPathInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__GetTaskPathInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTaskPathInfo(struct soap *soap, const struct __ns1__GetTaskPathInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__GetTaskPathInfo(soap, &a->ns4__GetTaskPathInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTaskPathInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetTaskPathInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__GetTaskPathInfo(soap, "ns4:GetTaskPathInfo", -1, &a->ns4__GetTaskPathInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskPathInfo * SOAP_FMAC4 soap_in___ns1__GetTaskPathInfo(struct soap *soap, const char *tag, struct __ns1__GetTaskPathInfo *a, const char *type)
{
	size_t soap_flag_ns4__GetTaskPathInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetTaskPathInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__GetTaskPathInfo, sizeof(struct __ns1__GetTaskPathInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTaskPathInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__GetTaskPathInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__GetTaskPathInfo(soap, "ns4:GetTaskPathInfo", &a->ns4__GetTaskPathInfo, ""))
				{	soap_flag_ns4__GetTaskPathInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTaskPathInfo(struct soap *soap, const struct __ns1__GetTaskPathInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTaskPathInfo(soap, tag?tag:"-ns1:GetTaskPathInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskPathInfo * SOAP_FMAC4 soap_get___ns1__GetTaskPathInfo(struct soap *soap, struct __ns1__GetTaskPathInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetTaskPathInfo * SOAP_FMAC2 soap_instantiate___ns1__GetTaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__GetTaskPathInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetTaskPathInfo);
		if (size)
			*size = sizeof(struct __ns1__GetTaskPathInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetTaskPathInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetTaskPathInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetTaskPathInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTaskPathInfo %p -> %p\n", q, p));
	*(struct __ns1__GetTaskPathInfo*)p = *(struct __ns1__GetTaskPathInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPatrolPointInfo(struct soap *soap, struct __ns1__GetPatrolPointInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__GetPatrolPointInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPatrolPointInfo(struct soap *soap, const struct __ns1__GetPatrolPointInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__GetPatrolPointInfo(soap, &a->ns4__GetPatrolPointInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPatrolPointInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetPatrolPointInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__GetPatrolPointInfo(soap, "ns4:GetPatrolPointInfo", -1, &a->ns4__GetPatrolPointInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPatrolPointInfo * SOAP_FMAC4 soap_in___ns1__GetPatrolPointInfo(struct soap *soap, const char *tag, struct __ns1__GetPatrolPointInfo *a, const char *type)
{
	size_t soap_flag_ns4__GetPatrolPointInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetPatrolPointInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__GetPatrolPointInfo, sizeof(struct __ns1__GetPatrolPointInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPatrolPointInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__GetPatrolPointInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__GetPatrolPointInfo(soap, "ns4:GetPatrolPointInfo", &a->ns4__GetPatrolPointInfo, ""))
				{	soap_flag_ns4__GetPatrolPointInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPatrolPointInfo(struct soap *soap, const struct __ns1__GetPatrolPointInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPatrolPointInfo(soap, tag?tag:"-ns1:GetPatrolPointInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPatrolPointInfo * SOAP_FMAC4 soap_get___ns1__GetPatrolPointInfo(struct soap *soap, struct __ns1__GetPatrolPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPatrolPointInfo * SOAP_FMAC2 soap_instantiate___ns1__GetPatrolPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPatrolPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__GetPatrolPointInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPatrolPointInfo);
		if (size)
			*size = sizeof(struct __ns1__GetPatrolPointInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetPatrolPointInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetPatrolPointInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetPatrolPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPatrolPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPatrolPointInfo %p -> %p\n", q, p));
	*(struct __ns1__GetPatrolPointInfo*)p = *(struct __ns1__GetPatrolPointInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDockPointInfo(struct soap *soap, struct __ns1__GetDockPointInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__GetDockPointInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDockPointInfo(struct soap *soap, const struct __ns1__GetDockPointInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__GetDockPointInfo(soap, &a->ns4__GetDockPointInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDockPointInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetDockPointInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__GetDockPointInfo(soap, "ns4:GetDockPointInfo", -1, &a->ns4__GetDockPointInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDockPointInfo * SOAP_FMAC4 soap_in___ns1__GetDockPointInfo(struct soap *soap, const char *tag, struct __ns1__GetDockPointInfo *a, const char *type)
{
	size_t soap_flag_ns4__GetDockPointInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetDockPointInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__GetDockPointInfo, sizeof(struct __ns1__GetDockPointInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDockPointInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__GetDockPointInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__GetDockPointInfo(soap, "ns4:GetDockPointInfo", &a->ns4__GetDockPointInfo, ""))
				{	soap_flag_ns4__GetDockPointInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDockPointInfo(struct soap *soap, const struct __ns1__GetDockPointInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetDockPointInfo(soap, tag?tag:"-ns1:GetDockPointInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDockPointInfo * SOAP_FMAC4 soap_get___ns1__GetDockPointInfo(struct soap *soap, struct __ns1__GetDockPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetDockPointInfo * SOAP_FMAC2 soap_instantiate___ns1__GetDockPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDockPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__GetDockPointInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetDockPointInfo);
		if (size)
			*size = sizeof(struct __ns1__GetDockPointInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetDockPointInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetDockPointInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetDockPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetDockPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetDockPointInfo %p -> %p\n", q, p));
	*(struct __ns1__GetDockPointInfo*)p = *(struct __ns1__GetDockPointInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapEdgeInfo(struct soap *soap, struct __ns1__GetMapEdgeInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__GetMapEdgeInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapEdgeInfo(struct soap *soap, const struct __ns1__GetMapEdgeInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__GetMapEdgeInfo(soap, &a->ns4__GetMapEdgeInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapEdgeInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapEdgeInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__GetMapEdgeInfo(soap, "ns4:GetMapEdgeInfo", -1, &a->ns4__GetMapEdgeInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapEdgeInfo * SOAP_FMAC4 soap_in___ns1__GetMapEdgeInfo(struct soap *soap, const char *tag, struct __ns1__GetMapEdgeInfo *a, const char *type)
{
	size_t soap_flag_ns4__GetMapEdgeInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetMapEdgeInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__GetMapEdgeInfo, sizeof(struct __ns1__GetMapEdgeInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapEdgeInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__GetMapEdgeInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__GetMapEdgeInfo(soap, "ns4:GetMapEdgeInfo", &a->ns4__GetMapEdgeInfo, ""))
				{	soap_flag_ns4__GetMapEdgeInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapEdgeInfo(struct soap *soap, const struct __ns1__GetMapEdgeInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetMapEdgeInfo(soap, tag?tag:"-ns1:GetMapEdgeInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapEdgeInfo * SOAP_FMAC4 soap_get___ns1__GetMapEdgeInfo(struct soap *soap, struct __ns1__GetMapEdgeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetMapEdgeInfo * SOAP_FMAC2 soap_instantiate___ns1__GetMapEdgeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapEdgeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__GetMapEdgeInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetMapEdgeInfo);
		if (size)
			*size = sizeof(struct __ns1__GetMapEdgeInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetMapEdgeInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetMapEdgeInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetMapEdgeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetMapEdgeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetMapEdgeInfo %p -> %p\n", q, p));
	*(struct __ns1__GetMapEdgeInfo*)p = *(struct __ns1__GetMapEdgeInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPatrolAreaInfo(struct soap *soap, struct __ns1__GetPatrolAreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__GetPatrolAreaInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPatrolAreaInfo(struct soap *soap, const struct __ns1__GetPatrolAreaInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__GetPatrolAreaInfo(soap, &a->ns4__GetPatrolAreaInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPatrolAreaInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetPatrolAreaInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__GetPatrolAreaInfo(soap, "ns4:GetPatrolAreaInfo", -1, &a->ns4__GetPatrolAreaInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPatrolAreaInfo * SOAP_FMAC4 soap_in___ns1__GetPatrolAreaInfo(struct soap *soap, const char *tag, struct __ns1__GetPatrolAreaInfo *a, const char *type)
{
	size_t soap_flag_ns4__GetPatrolAreaInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetPatrolAreaInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__GetPatrolAreaInfo, sizeof(struct __ns1__GetPatrolAreaInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPatrolAreaInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__GetPatrolAreaInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__GetPatrolAreaInfo(soap, "ns4:GetPatrolAreaInfo", &a->ns4__GetPatrolAreaInfo, ""))
				{	soap_flag_ns4__GetPatrolAreaInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPatrolAreaInfo(struct soap *soap, const struct __ns1__GetPatrolAreaInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPatrolAreaInfo(soap, tag?tag:"-ns1:GetPatrolAreaInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPatrolAreaInfo * SOAP_FMAC4 soap_get___ns1__GetPatrolAreaInfo(struct soap *soap, struct __ns1__GetPatrolAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPatrolAreaInfo * SOAP_FMAC2 soap_instantiate___ns1__GetPatrolAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPatrolAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__GetPatrolAreaInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPatrolAreaInfo);
		if (size)
			*size = sizeof(struct __ns1__GetPatrolAreaInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetPatrolAreaInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetPatrolAreaInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetPatrolAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPatrolAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPatrolAreaInfo %p -> %p\n", q, p));
	*(struct __ns1__GetPatrolAreaInfo*)p = *(struct __ns1__GetPatrolAreaInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapAreaInfo(struct soap *soap, struct __ns1__GetMapAreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__GetMapAreaInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapAreaInfo(struct soap *soap, const struct __ns1__GetMapAreaInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__GetMapAreaInfo(soap, &a->ns4__GetMapAreaInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapAreaInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapAreaInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns4__GetMapAreaInfo(soap, "ns4:GetMapAreaInfo", -1, &a->ns4__GetMapAreaInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapAreaInfo * SOAP_FMAC4 soap_in___ns1__GetMapAreaInfo(struct soap *soap, const char *tag, struct __ns1__GetMapAreaInfo *a, const char *type)
{
	size_t soap_flag_ns4__GetMapAreaInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetMapAreaInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskData___ns1__GetMapAreaInfo, sizeof(struct __ns1__GetMapAreaInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapAreaInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__GetMapAreaInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__GetMapAreaInfo(soap, "ns4:GetMapAreaInfo", &a->ns4__GetMapAreaInfo, ""))
				{	soap_flag_ns4__GetMapAreaInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapAreaInfo(struct soap *soap, const struct __ns1__GetMapAreaInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetMapAreaInfo(soap, tag?tag:"-ns1:GetMapAreaInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapAreaInfo * SOAP_FMAC4 soap_get___ns1__GetMapAreaInfo(struct soap *soap, struct __ns1__GetMapAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetMapAreaInfo * SOAP_FMAC2 soap_instantiate___ns1__GetMapAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData___ns1__GetMapAreaInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetMapAreaInfo);
		if (size)
			*size = sizeof(struct __ns1__GetMapAreaInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetMapAreaInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetMapAreaInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetMapAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetMapAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetMapAreaInfo %p -> %p\n", q, p));
	*(struct __ns1__GetMapAreaInfo*)p = *(struct __ns1__GetMapAreaInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetTaskExcuteDataResponse(struct soap *soap, _ns4__GetTaskExcuteDataResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetTaskExcuteDataResponse(struct soap *soap, const char *tag, int id, _ns4__GetTaskExcuteDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetTaskExcuteDataResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetTaskExcuteDataResponse(struct soap *soap, const char *tag, _ns4__GetTaskExcuteDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetTaskExcuteDataResponse **)soap_malloc(soap, sizeof(_ns4__GetTaskExcuteDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetTaskExcuteDataResponse *)soap_instantiate__ns4__GetTaskExcuteDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetTaskExcuteDataResponse ** p = (_ns4__GetTaskExcuteDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse, sizeof(_ns4__GetTaskExcuteDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetTaskExcuteDataResponse(struct soap *soap, _ns4__GetTaskExcuteDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskExcuteDataResponse);
	if (soap_out_PointerTo_ns4__GetTaskExcuteDataResponse(soap, tag?tag:"ns4:GetTaskExcuteDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetTaskExcuteDataResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetTaskExcuteDataResponse(struct soap *soap, _ns4__GetTaskExcuteDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetTaskExcuteDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetTaskExcuteData(struct soap *soap, _ns4__GetTaskExcuteData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetTaskExcuteData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetTaskExcuteData(struct soap *soap, const char *tag, int id, _ns4__GetTaskExcuteData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetTaskExcuteData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetTaskExcuteData ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetTaskExcuteData(struct soap *soap, const char *tag, _ns4__GetTaskExcuteData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetTaskExcuteData **)soap_malloc(soap, sizeof(_ns4__GetTaskExcuteData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetTaskExcuteData *)soap_instantiate__ns4__GetTaskExcuteData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetTaskExcuteData ** p = (_ns4__GetTaskExcuteData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetTaskExcuteData, sizeof(_ns4__GetTaskExcuteData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetTaskExcuteData(struct soap *soap, _ns4__GetTaskExcuteData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskExcuteData);
	if (soap_out_PointerTo_ns4__GetTaskExcuteData(soap, tag?tag:"ns4:GetTaskExcuteData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetTaskExcuteData ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetTaskExcuteData(struct soap *soap, _ns4__GetTaskExcuteData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetTaskExcuteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__RobotControlTaskResponse(struct soap *soap, _ns4__RobotControlTaskResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__RobotControlTaskResponse(struct soap *soap, const char *tag, int id, _ns4__RobotControlTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__RobotControlTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__RobotControlTaskResponse(struct soap *soap, const char *tag, _ns4__RobotControlTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__RobotControlTaskResponse **)soap_malloc(soap, sizeof(_ns4__RobotControlTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__RobotControlTaskResponse *)soap_instantiate__ns4__RobotControlTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__RobotControlTaskResponse ** p = (_ns4__RobotControlTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse, sizeof(_ns4__RobotControlTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__RobotControlTaskResponse(struct soap *soap, _ns4__RobotControlTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__RobotControlTaskResponse);
	if (soap_out_PointerTo_ns4__RobotControlTaskResponse(soap, tag?tag:"ns4:RobotControlTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__RobotControlTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__RobotControlTaskResponse(struct soap *soap, _ns4__RobotControlTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__RobotControlTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__RobotControlTask(struct soap *soap, _ns4__RobotControlTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__RobotControlTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__RobotControlTask(struct soap *soap, const char *tag, int id, _ns4__RobotControlTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__RobotControlTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__RobotControlTask ** SOAP_FMAC4 soap_in_PointerTo_ns4__RobotControlTask(struct soap *soap, const char *tag, _ns4__RobotControlTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__RobotControlTask **)soap_malloc(soap, sizeof(_ns4__RobotControlTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__RobotControlTask *)soap_instantiate__ns4__RobotControlTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__RobotControlTask ** p = (_ns4__RobotControlTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__RobotControlTask, sizeof(_ns4__RobotControlTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__RobotControlTask(struct soap *soap, _ns4__RobotControlTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__RobotControlTask);
	if (soap_out_PointerTo_ns4__RobotControlTask(soap, tag?tag:"ns4:RobotControlTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__RobotControlTask ** SOAP_FMAC4 soap_get_PointerTo_ns4__RobotControlTask(struct soap *soap, _ns4__RobotControlTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__RobotControlTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__SetTaskPathInfoResponse(struct soap *soap, _ns4__SetTaskPathInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__SetTaskPathInfoResponse(struct soap *soap, const char *tag, int id, _ns4__SetTaskPathInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__SetTaskPathInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__SetTaskPathInfoResponse(struct soap *soap, const char *tag, _ns4__SetTaskPathInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__SetTaskPathInfoResponse **)soap_malloc(soap, sizeof(_ns4__SetTaskPathInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__SetTaskPathInfoResponse *)soap_instantiate__ns4__SetTaskPathInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__SetTaskPathInfoResponse ** p = (_ns4__SetTaskPathInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse, sizeof(_ns4__SetTaskPathInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__SetTaskPathInfoResponse(struct soap *soap, _ns4__SetTaskPathInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__SetTaskPathInfoResponse);
	if (soap_out_PointerTo_ns4__SetTaskPathInfoResponse(soap, tag?tag:"ns4:SetTaskPathInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__SetTaskPathInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__SetTaskPathInfoResponse(struct soap *soap, _ns4__SetTaskPathInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__SetTaskPathInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__SetTaskPathInfo(struct soap *soap, _ns4__SetTaskPathInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__SetTaskPathInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__SetTaskPathInfo(struct soap *soap, const char *tag, int id, _ns4__SetTaskPathInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__SetTaskPathInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__SetTaskPathInfo ** SOAP_FMAC4 soap_in_PointerTo_ns4__SetTaskPathInfo(struct soap *soap, const char *tag, _ns4__SetTaskPathInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__SetTaskPathInfo **)soap_malloc(soap, sizeof(_ns4__SetTaskPathInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__SetTaskPathInfo *)soap_instantiate__ns4__SetTaskPathInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__SetTaskPathInfo ** p = (_ns4__SetTaskPathInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__SetTaskPathInfo, sizeof(_ns4__SetTaskPathInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__SetTaskPathInfo(struct soap *soap, _ns4__SetTaskPathInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__SetTaskPathInfo);
	if (soap_out_PointerTo_ns4__SetTaskPathInfo(soap, tag?tag:"ns4:SetTaskPathInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__SetTaskPathInfo ** SOAP_FMAC4 soap_get_PointerTo_ns4__SetTaskPathInfo(struct soap *soap, _ns4__SetTaskPathInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__SetTaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__StartTaskByPointListResponse(struct soap *soap, _ns4__StartTaskByPointListResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__StartTaskByPointListResponse(struct soap *soap, const char *tag, int id, _ns4__StartTaskByPointListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__StartTaskByPointListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__StartTaskByPointListResponse(struct soap *soap, const char *tag, _ns4__StartTaskByPointListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__StartTaskByPointListResponse **)soap_malloc(soap, sizeof(_ns4__StartTaskByPointListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__StartTaskByPointListResponse *)soap_instantiate__ns4__StartTaskByPointListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__StartTaskByPointListResponse ** p = (_ns4__StartTaskByPointListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse, sizeof(_ns4__StartTaskByPointListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__StartTaskByPointListResponse(struct soap *soap, _ns4__StartTaskByPointListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPointListResponse);
	if (soap_out_PointerTo_ns4__StartTaskByPointListResponse(soap, tag?tag:"ns4:StartTaskByPointListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__StartTaskByPointListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__StartTaskByPointListResponse(struct soap *soap, _ns4__StartTaskByPointListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__StartTaskByPointListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__StartTaskByPointList(struct soap *soap, _ns4__StartTaskByPointList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__StartTaskByPointList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__StartTaskByPointList(struct soap *soap, const char *tag, int id, _ns4__StartTaskByPointList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__StartTaskByPointList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__StartTaskByPointList ** SOAP_FMAC4 soap_in_PointerTo_ns4__StartTaskByPointList(struct soap *soap, const char *tag, _ns4__StartTaskByPointList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__StartTaskByPointList **)soap_malloc(soap, sizeof(_ns4__StartTaskByPointList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__StartTaskByPointList *)soap_instantiate__ns4__StartTaskByPointList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__StartTaskByPointList ** p = (_ns4__StartTaskByPointList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__StartTaskByPointList, sizeof(_ns4__StartTaskByPointList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__StartTaskByPointList(struct soap *soap, _ns4__StartTaskByPointList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPointList);
	if (soap_out_PointerTo_ns4__StartTaskByPointList(soap, tag?tag:"ns4:StartTaskByPointList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__StartTaskByPointList ** SOAP_FMAC4 soap_get_PointerTo_ns4__StartTaskByPointList(struct soap *soap, _ns4__StartTaskByPointList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__StartTaskByPointList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__StartTaskByPathIdResponse(struct soap *soap, _ns4__StartTaskByPathIdResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__StartTaskByPathIdResponse(struct soap *soap, const char *tag, int id, _ns4__StartTaskByPathIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__StartTaskByPathIdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__StartTaskByPathIdResponse(struct soap *soap, const char *tag, _ns4__StartTaskByPathIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__StartTaskByPathIdResponse **)soap_malloc(soap, sizeof(_ns4__StartTaskByPathIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__StartTaskByPathIdResponse *)soap_instantiate__ns4__StartTaskByPathIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__StartTaskByPathIdResponse ** p = (_ns4__StartTaskByPathIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse, sizeof(_ns4__StartTaskByPathIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__StartTaskByPathIdResponse(struct soap *soap, _ns4__StartTaskByPathIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPathIdResponse);
	if (soap_out_PointerTo_ns4__StartTaskByPathIdResponse(soap, tag?tag:"ns4:StartTaskByPathIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__StartTaskByPathIdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__StartTaskByPathIdResponse(struct soap *soap, _ns4__StartTaskByPathIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__StartTaskByPathIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__StartTaskByPathId(struct soap *soap, _ns4__StartTaskByPathId *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__StartTaskByPathId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__StartTaskByPathId(struct soap *soap, const char *tag, int id, _ns4__StartTaskByPathId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__StartTaskByPathId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__StartTaskByPathId ** SOAP_FMAC4 soap_in_PointerTo_ns4__StartTaskByPathId(struct soap *soap, const char *tag, _ns4__StartTaskByPathId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__StartTaskByPathId **)soap_malloc(soap, sizeof(_ns4__StartTaskByPathId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__StartTaskByPathId *)soap_instantiate__ns4__StartTaskByPathId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__StartTaskByPathId ** p = (_ns4__StartTaskByPathId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__StartTaskByPathId, sizeof(_ns4__StartTaskByPathId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__StartTaskByPathId(struct soap *soap, _ns4__StartTaskByPathId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__StartTaskByPathId);
	if (soap_out_PointerTo_ns4__StartTaskByPathId(soap, tag?tag:"ns4:StartTaskByPathId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__StartTaskByPathId ** SOAP_FMAC4 soap_get_PointerTo_ns4__StartTaskByPathId(struct soap *soap, _ns4__StartTaskByPathId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__StartTaskByPathId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetTaskPathInfoResponse(struct soap *soap, _ns4__GetTaskPathInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetTaskPathInfoResponse(struct soap *soap, const char *tag, int id, _ns4__GetTaskPathInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetTaskPathInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetTaskPathInfoResponse(struct soap *soap, const char *tag, _ns4__GetTaskPathInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetTaskPathInfoResponse **)soap_malloc(soap, sizeof(_ns4__GetTaskPathInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetTaskPathInfoResponse *)soap_instantiate__ns4__GetTaskPathInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetTaskPathInfoResponse ** p = (_ns4__GetTaskPathInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse, sizeof(_ns4__GetTaskPathInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetTaskPathInfoResponse(struct soap *soap, _ns4__GetTaskPathInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskPathInfoResponse);
	if (soap_out_PointerTo_ns4__GetTaskPathInfoResponse(soap, tag?tag:"ns4:GetTaskPathInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetTaskPathInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetTaskPathInfoResponse(struct soap *soap, _ns4__GetTaskPathInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetTaskPathInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetTaskPathInfo(struct soap *soap, _ns4__GetTaskPathInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetTaskPathInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetTaskPathInfo(struct soap *soap, const char *tag, int id, _ns4__GetTaskPathInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetTaskPathInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetTaskPathInfo ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetTaskPathInfo(struct soap *soap, const char *tag, _ns4__GetTaskPathInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetTaskPathInfo **)soap_malloc(soap, sizeof(_ns4__GetTaskPathInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetTaskPathInfo *)soap_instantiate__ns4__GetTaskPathInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetTaskPathInfo ** p = (_ns4__GetTaskPathInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetTaskPathInfo, sizeof(_ns4__GetTaskPathInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetTaskPathInfo(struct soap *soap, _ns4__GetTaskPathInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetTaskPathInfo);
	if (soap_out_PointerTo_ns4__GetTaskPathInfo(soap, tag?tag:"ns4:GetTaskPathInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetTaskPathInfo ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetTaskPathInfo(struct soap *soap, _ns4__GetTaskPathInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetTaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetPatrolPointInfoResponse(struct soap *soap, _ns4__GetPatrolPointInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetPatrolPointInfoResponse(struct soap *soap, const char *tag, int id, _ns4__GetPatrolPointInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetPatrolPointInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetPatrolPointInfoResponse(struct soap *soap, const char *tag, _ns4__GetPatrolPointInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetPatrolPointInfoResponse **)soap_malloc(soap, sizeof(_ns4__GetPatrolPointInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetPatrolPointInfoResponse *)soap_instantiate__ns4__GetPatrolPointInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetPatrolPointInfoResponse ** p = (_ns4__GetPatrolPointInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse, sizeof(_ns4__GetPatrolPointInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetPatrolPointInfoResponse(struct soap *soap, _ns4__GetPatrolPointInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolPointInfoResponse);
	if (soap_out_PointerTo_ns4__GetPatrolPointInfoResponse(soap, tag?tag:"ns4:GetPatrolPointInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetPatrolPointInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetPatrolPointInfoResponse(struct soap *soap, _ns4__GetPatrolPointInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetPatrolPointInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetPatrolPointInfo(struct soap *soap, _ns4__GetPatrolPointInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetPatrolPointInfo(struct soap *soap, const char *tag, int id, _ns4__GetPatrolPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetPatrolPointInfo ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetPatrolPointInfo(struct soap *soap, const char *tag, _ns4__GetPatrolPointInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetPatrolPointInfo **)soap_malloc(soap, sizeof(_ns4__GetPatrolPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetPatrolPointInfo *)soap_instantiate__ns4__GetPatrolPointInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetPatrolPointInfo ** p = (_ns4__GetPatrolPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo, sizeof(_ns4__GetPatrolPointInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetPatrolPointInfo(struct soap *soap, _ns4__GetPatrolPointInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolPointInfo);
	if (soap_out_PointerTo_ns4__GetPatrolPointInfo(soap, tag?tag:"ns4:GetPatrolPointInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetPatrolPointInfo ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetPatrolPointInfo(struct soap *soap, _ns4__GetPatrolPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetPatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetDockPointInfoResponse(struct soap *soap, _ns4__GetDockPointInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetDockPointInfoResponse(struct soap *soap, const char *tag, int id, _ns4__GetDockPointInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetDockPointInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetDockPointInfoResponse(struct soap *soap, const char *tag, _ns4__GetDockPointInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetDockPointInfoResponse **)soap_malloc(soap, sizeof(_ns4__GetDockPointInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetDockPointInfoResponse *)soap_instantiate__ns4__GetDockPointInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetDockPointInfoResponse ** p = (_ns4__GetDockPointInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse, sizeof(_ns4__GetDockPointInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetDockPointInfoResponse(struct soap *soap, _ns4__GetDockPointInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetDockPointInfoResponse);
	if (soap_out_PointerTo_ns4__GetDockPointInfoResponse(soap, tag?tag:"ns4:GetDockPointInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetDockPointInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetDockPointInfoResponse(struct soap *soap, _ns4__GetDockPointInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetDockPointInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetDockPointInfo(struct soap *soap, _ns4__GetDockPointInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetDockPointInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetDockPointInfo(struct soap *soap, const char *tag, int id, _ns4__GetDockPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetDockPointInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetDockPointInfo ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetDockPointInfo(struct soap *soap, const char *tag, _ns4__GetDockPointInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetDockPointInfo **)soap_malloc(soap, sizeof(_ns4__GetDockPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetDockPointInfo *)soap_instantiate__ns4__GetDockPointInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetDockPointInfo ** p = (_ns4__GetDockPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetDockPointInfo, sizeof(_ns4__GetDockPointInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetDockPointInfo(struct soap *soap, _ns4__GetDockPointInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetDockPointInfo);
	if (soap_out_PointerTo_ns4__GetDockPointInfo(soap, tag?tag:"ns4:GetDockPointInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetDockPointInfo ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetDockPointInfo(struct soap *soap, _ns4__GetDockPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetDockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetMapEdgeInfoResponse(struct soap *soap, _ns4__GetMapEdgeInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetMapEdgeInfoResponse(struct soap *soap, const char *tag, int id, _ns4__GetMapEdgeInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetMapEdgeInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetMapEdgeInfoResponse(struct soap *soap, const char *tag, _ns4__GetMapEdgeInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetMapEdgeInfoResponse **)soap_malloc(soap, sizeof(_ns4__GetMapEdgeInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetMapEdgeInfoResponse *)soap_instantiate__ns4__GetMapEdgeInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetMapEdgeInfoResponse ** p = (_ns4__GetMapEdgeInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse, sizeof(_ns4__GetMapEdgeInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetMapEdgeInfoResponse(struct soap *soap, _ns4__GetMapEdgeInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetMapEdgeInfoResponse);
	if (soap_out_PointerTo_ns4__GetMapEdgeInfoResponse(soap, tag?tag:"ns4:GetMapEdgeInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetMapEdgeInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetMapEdgeInfoResponse(struct soap *soap, _ns4__GetMapEdgeInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetMapEdgeInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetMapEdgeInfo(struct soap *soap, _ns4__GetMapEdgeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetMapEdgeInfo(struct soap *soap, const char *tag, int id, _ns4__GetMapEdgeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetMapEdgeInfo ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetMapEdgeInfo(struct soap *soap, const char *tag, _ns4__GetMapEdgeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetMapEdgeInfo **)soap_malloc(soap, sizeof(_ns4__GetMapEdgeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetMapEdgeInfo *)soap_instantiate__ns4__GetMapEdgeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetMapEdgeInfo ** p = (_ns4__GetMapEdgeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo, sizeof(_ns4__GetMapEdgeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetMapEdgeInfo(struct soap *soap, _ns4__GetMapEdgeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetMapEdgeInfo);
	if (soap_out_PointerTo_ns4__GetMapEdgeInfo(soap, tag?tag:"ns4:GetMapEdgeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetMapEdgeInfo ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetMapEdgeInfo(struct soap *soap, _ns4__GetMapEdgeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetMapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetPatrolAreaInfoResponse(struct soap *soap, _ns4__GetPatrolAreaInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetPatrolAreaInfoResponse(struct soap *soap, const char *tag, int id, _ns4__GetPatrolAreaInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetPatrolAreaInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetPatrolAreaInfoResponse(struct soap *soap, const char *tag, _ns4__GetPatrolAreaInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetPatrolAreaInfoResponse **)soap_malloc(soap, sizeof(_ns4__GetPatrolAreaInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetPatrolAreaInfoResponse *)soap_instantiate__ns4__GetPatrolAreaInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetPatrolAreaInfoResponse ** p = (_ns4__GetPatrolAreaInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse, sizeof(_ns4__GetPatrolAreaInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetPatrolAreaInfoResponse(struct soap *soap, _ns4__GetPatrolAreaInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolAreaInfoResponse);
	if (soap_out_PointerTo_ns4__GetPatrolAreaInfoResponse(soap, tag?tag:"ns4:GetPatrolAreaInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetPatrolAreaInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetPatrolAreaInfoResponse(struct soap *soap, _ns4__GetPatrolAreaInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetPatrolAreaInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetPatrolAreaInfo(struct soap *soap, _ns4__GetPatrolAreaInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetPatrolAreaInfo(struct soap *soap, const char *tag, int id, _ns4__GetPatrolAreaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetPatrolAreaInfo ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetPatrolAreaInfo(struct soap *soap, const char *tag, _ns4__GetPatrolAreaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetPatrolAreaInfo **)soap_malloc(soap, sizeof(_ns4__GetPatrolAreaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetPatrolAreaInfo *)soap_instantiate__ns4__GetPatrolAreaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetPatrolAreaInfo ** p = (_ns4__GetPatrolAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo, sizeof(_ns4__GetPatrolAreaInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetPatrolAreaInfo(struct soap *soap, _ns4__GetPatrolAreaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetPatrolAreaInfo);
	if (soap_out_PointerTo_ns4__GetPatrolAreaInfo(soap, tag?tag:"ns4:GetPatrolAreaInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetPatrolAreaInfo ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetPatrolAreaInfo(struct soap *soap, _ns4__GetPatrolAreaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetPatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetMapAreaInfoResponse(struct soap *soap, _ns4__GetMapAreaInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetMapAreaInfoResponse(struct soap *soap, const char *tag, int id, _ns4__GetMapAreaInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetMapAreaInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetMapAreaInfoResponse(struct soap *soap, const char *tag, _ns4__GetMapAreaInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetMapAreaInfoResponse **)soap_malloc(soap, sizeof(_ns4__GetMapAreaInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetMapAreaInfoResponse *)soap_instantiate__ns4__GetMapAreaInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetMapAreaInfoResponse ** p = (_ns4__GetMapAreaInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse, sizeof(_ns4__GetMapAreaInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetMapAreaInfoResponse(struct soap *soap, _ns4__GetMapAreaInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetMapAreaInfoResponse);
	if (soap_out_PointerTo_ns4__GetMapAreaInfoResponse(soap, tag?tag:"ns4:GetMapAreaInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetMapAreaInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetMapAreaInfoResponse(struct soap *soap, _ns4__GetMapAreaInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetMapAreaInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__GetMapAreaInfo(struct soap *soap, _ns4__GetMapAreaInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData__ns4__GetMapAreaInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__GetMapAreaInfo(struct soap *soap, const char *tag, int id, _ns4__GetMapAreaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData__ns4__GetMapAreaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__GetMapAreaInfo ** SOAP_FMAC4 soap_in_PointerTo_ns4__GetMapAreaInfo(struct soap *soap, const char *tag, _ns4__GetMapAreaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__GetMapAreaInfo **)soap_malloc(soap, sizeof(_ns4__GetMapAreaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__GetMapAreaInfo *)soap_instantiate__ns4__GetMapAreaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__GetMapAreaInfo ** p = (_ns4__GetMapAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData__ns4__GetMapAreaInfo, sizeof(_ns4__GetMapAreaInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__GetMapAreaInfo(struct soap *soap, _ns4__GetMapAreaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTo_ns4__GetMapAreaInfo);
	if (soap_out_PointerTo_ns4__GetMapAreaInfo(soap, tag?tag:"ns4:GetMapAreaInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__GetMapAreaInfo ** SOAP_FMAC4 soap_get_PointerTo_ns4__GetMapAreaInfo(struct soap *soap, _ns4__GetMapAreaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__GetMapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TaskExcuteData(struct soap *soap, ns4__TaskExcuteData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__TaskExcuteData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TaskExcuteData(struct soap *soap, const char *tag, int id, ns4__TaskExcuteData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__TaskExcuteData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__TaskExcuteData ** SOAP_FMAC4 soap_in_PointerTons4__TaskExcuteData(struct soap *soap, const char *tag, ns4__TaskExcuteData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TaskExcuteData **)soap_malloc(soap, sizeof(ns4__TaskExcuteData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__TaskExcuteData *)soap_instantiate_ns4__TaskExcuteData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__TaskExcuteData ** p = (ns4__TaskExcuteData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__TaskExcuteData, sizeof(ns4__TaskExcuteData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TaskExcuteData(struct soap *soap, ns4__TaskExcuteData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__TaskExcuteData);
	if (soap_out_PointerTons4__TaskExcuteData(soap, tag?tag:"ns4:TaskExcuteData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__TaskExcuteData ** SOAP_FMAC4 soap_get_PointerTons4__TaskExcuteData(struct soap *soap, ns4__TaskExcuteData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TaskExcuteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TaskPathInfos(struct soap *soap, ns4__TaskPathInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__TaskPathInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TaskPathInfos(struct soap *soap, const char *tag, int id, ns4__TaskPathInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__TaskPathInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__TaskPathInfos ** SOAP_FMAC4 soap_in_PointerTons4__TaskPathInfos(struct soap *soap, const char *tag, ns4__TaskPathInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TaskPathInfos **)soap_malloc(soap, sizeof(ns4__TaskPathInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__TaskPathInfos *)soap_instantiate_ns4__TaskPathInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__TaskPathInfos ** p = (ns4__TaskPathInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__TaskPathInfos, sizeof(ns4__TaskPathInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TaskPathInfos(struct soap *soap, ns4__TaskPathInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__TaskPathInfos);
	if (soap_out_PointerTons4__TaskPathInfos(soap, tag?tag:"ns4:TaskPathInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__TaskPathInfos ** SOAP_FMAC4 soap_get_PointerTons4__TaskPathInfos(struct soap *soap, ns4__TaskPathInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TaskPathInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__PatrolPointInfos(struct soap *soap, ns4__PatrolPointInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__PatrolPointInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__PatrolPointInfos(struct soap *soap, const char *tag, int id, ns4__PatrolPointInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__PatrolPointInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__PatrolPointInfos ** SOAP_FMAC4 soap_in_PointerTons4__PatrolPointInfos(struct soap *soap, const char *tag, ns4__PatrolPointInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__PatrolPointInfos **)soap_malloc(soap, sizeof(ns4__PatrolPointInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__PatrolPointInfos *)soap_instantiate_ns4__PatrolPointInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__PatrolPointInfos ** p = (ns4__PatrolPointInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__PatrolPointInfos, sizeof(ns4__PatrolPointInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__PatrolPointInfos(struct soap *soap, ns4__PatrolPointInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__PatrolPointInfos);
	if (soap_out_PointerTons4__PatrolPointInfos(soap, tag?tag:"ns4:PatrolPointInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__PatrolPointInfos ** SOAP_FMAC4 soap_get_PointerTons4__PatrolPointInfos(struct soap *soap, ns4__PatrolPointInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__PatrolPointInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DockPointInfos(struct soap *soap, ns4__DockPointInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__DockPointInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DockPointInfos(struct soap *soap, const char *tag, int id, ns4__DockPointInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__DockPointInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__DockPointInfos ** SOAP_FMAC4 soap_in_PointerTons4__DockPointInfos(struct soap *soap, const char *tag, ns4__DockPointInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__DockPointInfos **)soap_malloc(soap, sizeof(ns4__DockPointInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__DockPointInfos *)soap_instantiate_ns4__DockPointInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__DockPointInfos ** p = (ns4__DockPointInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__DockPointInfos, sizeof(ns4__DockPointInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DockPointInfos(struct soap *soap, ns4__DockPointInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__DockPointInfos);
	if (soap_out_PointerTons4__DockPointInfos(soap, tag?tag:"ns4:DockPointInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__DockPointInfos ** SOAP_FMAC4 soap_get_PointerTons4__DockPointInfos(struct soap *soap, ns4__DockPointInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DockPointInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__MapEdgeInfos(struct soap *soap, ns4__MapEdgeInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__MapEdgeInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__MapEdgeInfos(struct soap *soap, const char *tag, int id, ns4__MapEdgeInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__MapEdgeInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__MapEdgeInfos ** SOAP_FMAC4 soap_in_PointerTons4__MapEdgeInfos(struct soap *soap, const char *tag, ns4__MapEdgeInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__MapEdgeInfos **)soap_malloc(soap, sizeof(ns4__MapEdgeInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__MapEdgeInfos *)soap_instantiate_ns4__MapEdgeInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__MapEdgeInfos ** p = (ns4__MapEdgeInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__MapEdgeInfos, sizeof(ns4__MapEdgeInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__MapEdgeInfos(struct soap *soap, ns4__MapEdgeInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__MapEdgeInfos);
	if (soap_out_PointerTons4__MapEdgeInfos(soap, tag?tag:"ns4:MapEdgeInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__MapEdgeInfos ** SOAP_FMAC4 soap_get_PointerTons4__MapEdgeInfos(struct soap *soap, ns4__MapEdgeInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__MapEdgeInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__PatrolAreaInfos(struct soap *soap, ns4__PatrolAreaInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__PatrolAreaInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__PatrolAreaInfos(struct soap *soap, const char *tag, int id, ns4__PatrolAreaInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__PatrolAreaInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__PatrolAreaInfos ** SOAP_FMAC4 soap_in_PointerTons4__PatrolAreaInfos(struct soap *soap, const char *tag, ns4__PatrolAreaInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__PatrolAreaInfos **)soap_malloc(soap, sizeof(ns4__PatrolAreaInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__PatrolAreaInfos *)soap_instantiate_ns4__PatrolAreaInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__PatrolAreaInfos ** p = (ns4__PatrolAreaInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__PatrolAreaInfos, sizeof(ns4__PatrolAreaInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__PatrolAreaInfos(struct soap *soap, ns4__PatrolAreaInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__PatrolAreaInfos);
	if (soap_out_PointerTons4__PatrolAreaInfos(soap, tag?tag:"ns4:PatrolAreaInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__PatrolAreaInfos ** SOAP_FMAC4 soap_get_PointerTons4__PatrolAreaInfos(struct soap *soap, ns4__PatrolAreaInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__PatrolAreaInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__MapAreaInfos(struct soap *soap, ns4__MapAreaInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__MapAreaInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__MapAreaInfos(struct soap *soap, const char *tag, int id, ns4__MapAreaInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__MapAreaInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__MapAreaInfos ** SOAP_FMAC4 soap_in_PointerTons4__MapAreaInfos(struct soap *soap, const char *tag, ns4__MapAreaInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__MapAreaInfos **)soap_malloc(soap, sizeof(ns4__MapAreaInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__MapAreaInfos *)soap_instantiate_ns4__MapAreaInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__MapAreaInfos ** p = (ns4__MapAreaInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__MapAreaInfos, sizeof(ns4__MapAreaInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__MapAreaInfos(struct soap *soap, ns4__MapAreaInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__MapAreaInfos);
	if (soap_out_PointerTons4__MapAreaInfos(soap, tag?tag:"ns4:MapAreaInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__MapAreaInfos ** SOAP_FMAC4 soap_get_PointerTons4__MapAreaInfos(struct soap *soap, ns4__MapAreaInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__MapAreaInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TaskExcuteInfo(struct soap *soap, ns4__TaskExcuteInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__TaskExcuteInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TaskExcuteInfo(struct soap *soap, const char *tag, int id, ns4__TaskExcuteInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__TaskExcuteInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__TaskExcuteInfo ** SOAP_FMAC4 soap_in_PointerTons4__TaskExcuteInfo(struct soap *soap, const char *tag, ns4__TaskExcuteInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TaskExcuteInfo **)soap_malloc(soap, sizeof(ns4__TaskExcuteInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__TaskExcuteInfo *)soap_instantiate_ns4__TaskExcuteInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__TaskExcuteInfo ** p = (ns4__TaskExcuteInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__TaskExcuteInfo, sizeof(ns4__TaskExcuteInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TaskExcuteInfo(struct soap *soap, ns4__TaskExcuteInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__TaskExcuteInfo);
	if (soap_out_PointerTons4__TaskExcuteInfo(soap, tag?tag:"ns4:TaskExcuteInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__TaskExcuteInfo ** SOAP_FMAC4 soap_get_PointerTons4__TaskExcuteInfo(struct soap *soap, ns4__TaskExcuteInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TaskExcuteInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TaskFinishInfo(struct soap *soap, ns4__TaskFinishInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__TaskFinishInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TaskFinishInfo(struct soap *soap, const char *tag, int id, ns4__TaskFinishInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__TaskFinishInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__TaskFinishInfo ** SOAP_FMAC4 soap_in_PointerTons4__TaskFinishInfo(struct soap *soap, const char *tag, ns4__TaskFinishInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TaskFinishInfo **)soap_malloc(soap, sizeof(ns4__TaskFinishInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__TaskFinishInfo *)soap_instantiate_ns4__TaskFinishInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__TaskFinishInfo ** p = (ns4__TaskFinishInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__TaskFinishInfo, sizeof(ns4__TaskFinishInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TaskFinishInfo(struct soap *soap, ns4__TaskFinishInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__TaskFinishInfo);
	if (soap_out_PointerTons4__TaskFinishInfo(soap, tag?tag:"ns4:TaskFinishInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__TaskFinishInfo ** SOAP_FMAC4 soap_get_PointerTons4__TaskFinishInfo(struct soap *soap, ns4__TaskFinishInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TaskFinishInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TaskPathInfo(struct soap *soap, ns4__TaskPathInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__TaskPathInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TaskPathInfo(struct soap *soap, const char *tag, int id, ns4__TaskPathInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__TaskPathInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__TaskPathInfo ** SOAP_FMAC4 soap_in_PointerTons4__TaskPathInfo(struct soap *soap, const char *tag, ns4__TaskPathInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TaskPathInfo **)soap_malloc(soap, sizeof(ns4__TaskPathInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__TaskPathInfo *)soap_instantiate_ns4__TaskPathInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__TaskPathInfo ** p = (ns4__TaskPathInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__TaskPathInfo, sizeof(ns4__TaskPathInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TaskPathInfo(struct soap *soap, ns4__TaskPathInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__TaskPathInfo);
	if (soap_out_PointerTons4__TaskPathInfo(soap, tag?tag:"ns4:TaskPathInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__TaskPathInfo ** SOAP_FMAC4 soap_get_PointerTons4__TaskPathInfo(struct soap *soap, ns4__TaskPathInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__PatrolPointInfo(struct soap *soap, ns4__PatrolPointInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__PatrolPointInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__PatrolPointInfo(struct soap *soap, const char *tag, int id, ns4__PatrolPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__PatrolPointInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__PatrolPointInfo ** SOAP_FMAC4 soap_in_PointerTons4__PatrolPointInfo(struct soap *soap, const char *tag, ns4__PatrolPointInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__PatrolPointInfo **)soap_malloc(soap, sizeof(ns4__PatrolPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__PatrolPointInfo *)soap_instantiate_ns4__PatrolPointInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__PatrolPointInfo ** p = (ns4__PatrolPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__PatrolPointInfo, sizeof(ns4__PatrolPointInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__PatrolPointInfo(struct soap *soap, ns4__PatrolPointInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__PatrolPointInfo);
	if (soap_out_PointerTons4__PatrolPointInfo(soap, tag?tag:"ns4:PatrolPointInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__PatrolPointInfo ** SOAP_FMAC4 soap_get_PointerTons4__PatrolPointInfo(struct soap *soap, ns4__PatrolPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__PatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DockPointInfo(struct soap *soap, ns4__DockPointInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__DockPointInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DockPointInfo(struct soap *soap, const char *tag, int id, ns4__DockPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__DockPointInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__DockPointInfo ** SOAP_FMAC4 soap_in_PointerTons4__DockPointInfo(struct soap *soap, const char *tag, ns4__DockPointInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__DockPointInfo **)soap_malloc(soap, sizeof(ns4__DockPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__DockPointInfo *)soap_instantiate_ns4__DockPointInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__DockPointInfo ** p = (ns4__DockPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__DockPointInfo, sizeof(ns4__DockPointInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DockPointInfo(struct soap *soap, ns4__DockPointInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__DockPointInfo);
	if (soap_out_PointerTons4__DockPointInfo(soap, tag?tag:"ns4:DockPointInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__DockPointInfo ** SOAP_FMAC4 soap_get_PointerTons4__DockPointInfo(struct soap *soap, ns4__DockPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__MapEdgeInfo(struct soap *soap, ns4__MapEdgeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__MapEdgeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__MapEdgeInfo(struct soap *soap, const char *tag, int id, ns4__MapEdgeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__MapEdgeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__MapEdgeInfo ** SOAP_FMAC4 soap_in_PointerTons4__MapEdgeInfo(struct soap *soap, const char *tag, ns4__MapEdgeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__MapEdgeInfo **)soap_malloc(soap, sizeof(ns4__MapEdgeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__MapEdgeInfo *)soap_instantiate_ns4__MapEdgeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__MapEdgeInfo ** p = (ns4__MapEdgeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__MapEdgeInfo, sizeof(ns4__MapEdgeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__MapEdgeInfo(struct soap *soap, ns4__MapEdgeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__MapEdgeInfo);
	if (soap_out_PointerTons4__MapEdgeInfo(soap, tag?tag:"ns4:MapEdgeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__MapEdgeInfo ** SOAP_FMAC4 soap_get_PointerTons4__MapEdgeInfo(struct soap *soap, ns4__MapEdgeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__MapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__PatrolAreaInfo(struct soap *soap, ns4__PatrolAreaInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__PatrolAreaInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__PatrolAreaInfo(struct soap *soap, const char *tag, int id, ns4__PatrolAreaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__PatrolAreaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__PatrolAreaInfo ** SOAP_FMAC4 soap_in_PointerTons4__PatrolAreaInfo(struct soap *soap, const char *tag, ns4__PatrolAreaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__PatrolAreaInfo **)soap_malloc(soap, sizeof(ns4__PatrolAreaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__PatrolAreaInfo *)soap_instantiate_ns4__PatrolAreaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__PatrolAreaInfo ** p = (ns4__PatrolAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__PatrolAreaInfo, sizeof(ns4__PatrolAreaInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__PatrolAreaInfo(struct soap *soap, ns4__PatrolAreaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__PatrolAreaInfo);
	if (soap_out_PointerTons4__PatrolAreaInfo(soap, tag?tag:"ns4:PatrolAreaInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__PatrolAreaInfo ** SOAP_FMAC4 soap_get_PointerTons4__PatrolAreaInfo(struct soap *soap, ns4__PatrolAreaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__PatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__MapAreaInfo(struct soap *soap, ns4__MapAreaInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__MapAreaInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__MapAreaInfo(struct soap *soap, const char *tag, int id, ns4__MapAreaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__MapAreaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__MapAreaInfo ** SOAP_FMAC4 soap_in_PointerTons4__MapAreaInfo(struct soap *soap, const char *tag, ns4__MapAreaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__MapAreaInfo **)soap_malloc(soap, sizeof(ns4__MapAreaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__MapAreaInfo *)soap_instantiate_ns4__MapAreaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__MapAreaInfo ** p = (ns4__MapAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__MapAreaInfo, sizeof(ns4__MapAreaInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__MapAreaInfo(struct soap *soap, ns4__MapAreaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__MapAreaInfo);
	if (soap_out_PointerTons4__MapAreaInfo(soap, tag?tag:"ns4:MapAreaInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__MapAreaInfo ** SOAP_FMAC4 soap_get_PointerTons4__MapAreaInfo(struct soap *soap, ns4__MapAreaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__MapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RobotAlarmInfo(struct soap *soap, ns4__RobotAlarmInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__RobotAlarmInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RobotAlarmInfo(struct soap *soap, const char *tag, int id, ns4__RobotAlarmInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__RobotAlarmInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RobotAlarmInfo ** SOAP_FMAC4 soap_in_PointerTons4__RobotAlarmInfo(struct soap *soap, const char *tag, ns4__RobotAlarmInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RobotAlarmInfo **)soap_malloc(soap, sizeof(ns4__RobotAlarmInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RobotAlarmInfo *)soap_instantiate_ns4__RobotAlarmInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RobotAlarmInfo ** p = (ns4__RobotAlarmInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__RobotAlarmInfo, sizeof(ns4__RobotAlarmInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RobotAlarmInfo(struct soap *soap, ns4__RobotAlarmInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__RobotAlarmInfo);
	if (soap_out_PointerTons4__RobotAlarmInfo(soap, tag?tag:"ns4:RobotAlarmInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__RobotAlarmInfo ** SOAP_FMAC4 soap_get_PointerTons4__RobotAlarmInfo(struct soap *soap, ns4__RobotAlarmInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RobotGasInfo(struct soap *soap, ns4__RobotGasInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__RobotGasInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RobotGasInfo(struct soap *soap, const char *tag, int id, ns4__RobotGasInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__RobotGasInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RobotGasInfo ** SOAP_FMAC4 soap_in_PointerTons4__RobotGasInfo(struct soap *soap, const char *tag, ns4__RobotGasInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RobotGasInfo **)soap_malloc(soap, sizeof(ns4__RobotGasInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RobotGasInfo *)soap_instantiate_ns4__RobotGasInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RobotGasInfo ** p = (ns4__RobotGasInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__RobotGasInfo, sizeof(ns4__RobotGasInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RobotGasInfo(struct soap *soap, ns4__RobotGasInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__RobotGasInfo);
	if (soap_out_PointerTons4__RobotGasInfo(soap, tag?tag:"ns4:RobotGasInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__RobotGasInfo ** SOAP_FMAC4 soap_get_PointerTons4__RobotGasInfo(struct soap *soap, ns4__RobotGasInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RobotMileageInfo(struct soap *soap, ns4__RobotMileageInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__RobotMileageInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RobotMileageInfo(struct soap *soap, const char *tag, int id, ns4__RobotMileageInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__RobotMileageInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RobotMileageInfo ** SOAP_FMAC4 soap_in_PointerTons4__RobotMileageInfo(struct soap *soap, const char *tag, ns4__RobotMileageInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RobotMileageInfo **)soap_malloc(soap, sizeof(ns4__RobotMileageInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RobotMileageInfo *)soap_instantiate_ns4__RobotMileageInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RobotMileageInfo ** p = (ns4__RobotMileageInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__RobotMileageInfo, sizeof(ns4__RobotMileageInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RobotMileageInfo(struct soap *soap, ns4__RobotMileageInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__RobotMileageInfo);
	if (soap_out_PointerTons4__RobotMileageInfo(soap, tag?tag:"ns4:RobotMileageInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__RobotMileageInfo ** SOAP_FMAC4 soap_get_PointerTons4__RobotMileageInfo(struct soap *soap, ns4__RobotMileageInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RobotYunTaiInfo(struct soap *soap, ns4__RobotYunTaiInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, ns4__RobotYunTaiInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RobotYunTaiInfo ** SOAP_FMAC4 soap_in_PointerTons4__RobotYunTaiInfo(struct soap *soap, const char *tag, ns4__RobotYunTaiInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RobotYunTaiInfo **)soap_malloc(soap, sizeof(ns4__RobotYunTaiInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RobotYunTaiInfo *)soap_instantiate_ns4__RobotYunTaiInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RobotYunTaiInfo ** p = (ns4__RobotYunTaiInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo, sizeof(ns4__RobotYunTaiInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RobotYunTaiInfo(struct soap *soap, ns4__RobotYunTaiInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__RobotYunTaiInfo);
	if (soap_out_PointerTons4__RobotYunTaiInfo(soap, tag?tag:"ns4:RobotYunTaiInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__RobotYunTaiInfo ** SOAP_FMAC4 soap_get_PointerTons4__RobotYunTaiInfo(struct soap *soap, ns4__RobotYunTaiInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RobotPosInfo(struct soap *soap, ns4__RobotPosInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__RobotPosInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RobotPosInfo(struct soap *soap, const char *tag, int id, ns4__RobotPosInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__RobotPosInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RobotPosInfo ** SOAP_FMAC4 soap_in_PointerTons4__RobotPosInfo(struct soap *soap, const char *tag, ns4__RobotPosInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RobotPosInfo **)soap_malloc(soap, sizeof(ns4__RobotPosInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RobotPosInfo *)soap_instantiate_ns4__RobotPosInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RobotPosInfo ** p = (ns4__RobotPosInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__RobotPosInfo, sizeof(ns4__RobotPosInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RobotPosInfo(struct soap *soap, ns4__RobotPosInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__RobotPosInfo);
	if (soap_out_PointerTons4__RobotPosInfo(soap, tag?tag:"ns4:RobotPosInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__RobotPosInfo ** SOAP_FMAC4 soap_get_PointerTons4__RobotPosInfo(struct soap *soap, ns4__RobotPosInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RobotTaskState(struct soap *soap, ns4__RobotTaskState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__RobotTaskState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RobotTaskState(struct soap *soap, const char *tag, int id, ns4__RobotTaskState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__RobotTaskState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RobotTaskState ** SOAP_FMAC4 soap_in_PointerTons4__RobotTaskState(struct soap *soap, const char *tag, ns4__RobotTaskState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RobotTaskState **)soap_malloc(soap, sizeof(ns4__RobotTaskState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RobotTaskState *)soap_instantiate_ns4__RobotTaskState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RobotTaskState ** p = (ns4__RobotTaskState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__RobotTaskState, sizeof(ns4__RobotTaskState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RobotTaskState(struct soap *soap, ns4__RobotTaskState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__RobotTaskState);
	if (soap_out_PointerTons4__RobotTaskState(soap, tag?tag:"ns4:RobotTaskState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__RobotTaskState ** SOAP_FMAC4 soap_get_PointerTons4__RobotTaskState(struct soap *soap, ns4__RobotTaskState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SpeedInfo(struct soap *soap, ns4__SpeedInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__SpeedInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SpeedInfo(struct soap *soap, const char *tag, int id, ns4__SpeedInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__SpeedInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__SpeedInfo ** SOAP_FMAC4 soap_in_PointerTons4__SpeedInfo(struct soap *soap, const char *tag, ns4__SpeedInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__SpeedInfo **)soap_malloc(soap, sizeof(ns4__SpeedInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__SpeedInfo *)soap_instantiate_ns4__SpeedInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__SpeedInfo ** p = (ns4__SpeedInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__SpeedInfo, sizeof(ns4__SpeedInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SpeedInfo(struct soap *soap, ns4__SpeedInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__SpeedInfo);
	if (soap_out_PointerTons4__SpeedInfo(soap, tag?tag:"ns4:SpeedInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__SpeedInfo ** SOAP_FMAC4 soap_get_PointerTons4__SpeedInfo(struct soap *soap, ns4__SpeedInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__BatteryInfo(struct soap *soap, ns4__BatteryInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__BatteryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__BatteryInfo(struct soap *soap, const char *tag, int id, ns4__BatteryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__BatteryInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__BatteryInfo ** SOAP_FMAC4 soap_in_PointerTons4__BatteryInfo(struct soap *soap, const char *tag, ns4__BatteryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__BatteryInfo **)soap_malloc(soap, sizeof(ns4__BatteryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__BatteryInfo *)soap_instantiate_ns4__BatteryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__BatteryInfo ** p = (ns4__BatteryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__BatteryInfo, sizeof(ns4__BatteryInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__BatteryInfo(struct soap *soap, ns4__BatteryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__BatteryInfo);
	if (soap_out_PointerTons4__BatteryInfo(soap, tag?tag:"ns4:BatteryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__BatteryInfo ** SOAP_FMAC4 soap_get_PointerTons4__BatteryInfo(struct soap *soap, ns4__BatteryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__BatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RobotInfo(struct soap *soap, ns4__RobotInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__RobotInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RobotInfo(struct soap *soap, const char *tag, int id, ns4__RobotInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__RobotInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RobotInfo ** SOAP_FMAC4 soap_in_PointerTons4__RobotInfo(struct soap *soap, const char *tag, ns4__RobotInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RobotInfo **)soap_malloc(soap, sizeof(ns4__RobotInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RobotInfo *)soap_instantiate_ns4__RobotInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RobotInfo ** p = (ns4__RobotInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__RobotInfo, sizeof(ns4__RobotInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RobotInfo(struct soap *soap, ns4__RobotInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__RobotInfo);
	if (soap_out_PointerTons4__RobotInfo(soap, tag?tag:"ns4:RobotInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__RobotInfo ** SOAP_FMAC4 soap_get_PointerTons4__RobotInfo(struct soap *soap, ns4__RobotInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ConnectInfo(struct soap *soap, ns4__ConnectInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskData_ns4__ConnectInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ConnectInfo(struct soap *soap, const char *tag, int id, ns4__ConnectInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskData_ns4__ConnectInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ConnectInfo ** SOAP_FMAC4 soap_in_PointerTons4__ConnectInfo(struct soap *soap, const char *tag, ns4__ConnectInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ConnectInfo **)soap_malloc(soap, sizeof(ns4__ConnectInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ConnectInfo *)soap_instantiate_ns4__ConnectInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ConnectInfo ** p = (ns4__ConnectInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskData_ns4__ConnectInfo, sizeof(ns4__ConnectInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ConnectInfo(struct soap *soap, ns4__ConnectInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_PointerTons4__ConnectInfo);
	if (soap_out_PointerTons4__ConnectInfo(soap, tag?tag:"ns4:ConnectInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ConnectInfo ** SOAP_FMAC4 soap_get_PointerTons4__ConnectInfo(struct soap *soap, ns4__ConnectInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ConnectInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_TaskData__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_TaskData__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_TaskData__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_TaskData_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_TaskData_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_TaskData_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskData_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(struct soap *soap, std::vector<ns4__TaskExcuteInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(struct soap *soap, const std::vector<ns4__TaskExcuteInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__TaskExcuteInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__TaskExcuteInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__TaskExcuteInfo * >*a, const char *type)
{
	for (std::vector<ns4__TaskExcuteInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__TaskExcuteInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__TaskExcuteInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(struct soap *soap, const char *tag, std::vector<ns4__TaskExcuteInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__TaskExcuteInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__TaskExcuteInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskExcuteInfo, sizeof(ns4__TaskExcuteInfo), 1))
				break;
			if (!soap_in_PointerTons4__TaskExcuteInfo(soap, tag, NULL, "ns4:TaskExcuteInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__TaskExcuteInfo(soap, tag, &n, "ns4:TaskExcuteInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__TaskExcuteInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskExcuteInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__TaskExcuteInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__TaskExcuteInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__TaskExcuteInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__TaskExcuteInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__TaskExcuteInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__TaskExcuteInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__TaskExcuteInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__TaskExcuteInfo * >*)p = *(std::vector<ns4__TaskExcuteInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__TaskFinishInfo(struct soap *soap, std::vector<ns4__TaskFinishInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__TaskFinishInfo(struct soap *soap, const std::vector<ns4__TaskFinishInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__TaskFinishInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__TaskFinishInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__TaskFinishInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__TaskFinishInfo * >*a, const char *type)
{
	for (std::vector<ns4__TaskFinishInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__TaskFinishInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__TaskFinishInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__TaskFinishInfo(struct soap *soap, const char *tag, std::vector<ns4__TaskFinishInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__TaskFinishInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__TaskFinishInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskFinishInfo, sizeof(ns4__TaskFinishInfo), 1))
				break;
			if (!soap_in_PointerTons4__TaskFinishInfo(soap, tag, NULL, "ns4:TaskFinishInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__TaskFinishInfo(soap, tag, &n, "ns4:TaskFinishInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__TaskFinishInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__TaskFinishInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__TaskFinishInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__TaskFinishInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskFinishInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__TaskFinishInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__TaskFinishInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__TaskFinishInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__TaskFinishInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__TaskFinishInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__TaskFinishInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__TaskFinishInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__TaskFinishInfo * >*)p = *(std::vector<ns4__TaskFinishInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__TaskPathInfo(struct soap *soap, std::vector<ns4__TaskPathInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__TaskPathInfo(struct soap *soap, const std::vector<ns4__TaskPathInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__TaskPathInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__TaskPathInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__TaskPathInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__TaskPathInfo * >*a, const char *type)
{
	for (std::vector<ns4__TaskPathInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__TaskPathInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__TaskPathInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__TaskPathInfo(struct soap *soap, const char *tag, std::vector<ns4__TaskPathInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__TaskPathInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__TaskPathInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskPathInfo, sizeof(ns4__TaskPathInfo), 1))
				break;
			if (!soap_in_PointerTons4__TaskPathInfo(soap, tag, NULL, "ns4:TaskPathInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__TaskPathInfo(soap, tag, &n, "ns4:TaskPathInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__TaskPathInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__TaskPathInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__TaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__TaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__TaskPathInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__TaskPathInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__TaskPathInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__TaskPathInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__TaskPathInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__TaskPathInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__TaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__TaskPathInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__TaskPathInfo * >*)p = *(std::vector<ns4__TaskPathInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__PatrolPointInfo(struct soap *soap, std::vector<ns4__PatrolPointInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__PatrolPointInfo(struct soap *soap, const std::vector<ns4__PatrolPointInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__PatrolPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__PatrolPointInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__PatrolPointInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__PatrolPointInfo * >*a, const char *type)
{
	for (std::vector<ns4__PatrolPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__PatrolPointInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__PatrolPointInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__PatrolPointInfo(struct soap *soap, const char *tag, std::vector<ns4__PatrolPointInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__PatrolPointInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__PatrolPointInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolPointInfo, sizeof(ns4__PatrolPointInfo), 1))
				break;
			if (!soap_in_PointerTons4__PatrolPointInfo(soap, tag, NULL, "ns4:PatrolPointInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__PatrolPointInfo(soap, tag, &n, "ns4:PatrolPointInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__PatrolPointInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__PatrolPointInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__PatrolPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__PatrolPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolPointInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__PatrolPointInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__PatrolPointInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__PatrolPointInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__PatrolPointInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__PatrolPointInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__PatrolPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__PatrolPointInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__PatrolPointInfo * >*)p = *(std::vector<ns4__PatrolPointInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__DockPointInfo(struct soap *soap, std::vector<ns4__DockPointInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__DockPointInfo(struct soap *soap, const std::vector<ns4__DockPointInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__DockPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__DockPointInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__DockPointInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__DockPointInfo * >*a, const char *type)
{
	for (std::vector<ns4__DockPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__DockPointInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__DockPointInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__DockPointInfo(struct soap *soap, const char *tag, std::vector<ns4__DockPointInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__DockPointInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__DockPointInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__DockPointInfo, sizeof(ns4__DockPointInfo), 1))
				break;
			if (!soap_in_PointerTons4__DockPointInfo(soap, tag, NULL, "ns4:DockPointInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__DockPointInfo(soap, tag, &n, "ns4:DockPointInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__DockPointInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__DockPointInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__DockPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__DockPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__DockPointInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__DockPointInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__DockPointInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__DockPointInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__DockPointInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__DockPointInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__DockPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__DockPointInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__DockPointInfo * >*)p = *(std::vector<ns4__DockPointInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_std__string(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_std__string, SOAP_TYPE_TaskData_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfstd__string, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__MapEdgeInfo(struct soap *soap, std::vector<ns4__MapEdgeInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__MapEdgeInfo(struct soap *soap, const std::vector<ns4__MapEdgeInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__MapEdgeInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__MapEdgeInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__MapEdgeInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__MapEdgeInfo * >*a, const char *type)
{
	for (std::vector<ns4__MapEdgeInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__MapEdgeInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__MapEdgeInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__MapEdgeInfo(struct soap *soap, const char *tag, std::vector<ns4__MapEdgeInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__MapEdgeInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__MapEdgeInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapEdgeInfo, sizeof(ns4__MapEdgeInfo), 1))
				break;
			if (!soap_in_PointerTons4__MapEdgeInfo(soap, tag, NULL, "ns4:MapEdgeInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__MapEdgeInfo(soap, tag, &n, "ns4:MapEdgeInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__MapEdgeInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__MapEdgeInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__MapEdgeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__MapEdgeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapEdgeInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__MapEdgeInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__MapEdgeInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__MapEdgeInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__MapEdgeInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__MapEdgeInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__MapEdgeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__MapEdgeInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__MapEdgeInfo * >*)p = *(std::vector<ns4__MapEdgeInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(struct soap *soap, std::vector<ns4__PatrolAreaInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(struct soap *soap, const std::vector<ns4__PatrolAreaInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__PatrolAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__PatrolAreaInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__PatrolAreaInfo * >*a, const char *type)
{
	for (std::vector<ns4__PatrolAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__PatrolAreaInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__PatrolAreaInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(struct soap *soap, const char *tag, std::vector<ns4__PatrolAreaInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__PatrolAreaInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__PatrolAreaInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolAreaInfo, sizeof(ns4__PatrolAreaInfo), 1))
				break;
			if (!soap_in_PointerTons4__PatrolAreaInfo(soap, tag, NULL, "ns4:PatrolAreaInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__PatrolAreaInfo(soap, tag, &n, "ns4:PatrolAreaInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__PatrolAreaInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__PatrolAreaInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__PatrolAreaInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__PatrolAreaInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__PatrolAreaInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__PatrolAreaInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__PatrolAreaInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__PatrolAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__PatrolAreaInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__PatrolAreaInfo * >*)p = *(std::vector<ns4__PatrolAreaInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__MapAreaInfo(struct soap *soap, std::vector<ns4__MapAreaInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__MapAreaInfo(struct soap *soap, const std::vector<ns4__MapAreaInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__MapAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__MapAreaInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__MapAreaInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__MapAreaInfo * >*a, const char *type)
{
	for (std::vector<ns4__MapAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__MapAreaInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__MapAreaInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__MapAreaInfo(struct soap *soap, const char *tag, std::vector<ns4__MapAreaInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__MapAreaInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__MapAreaInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapAreaInfo, sizeof(ns4__MapAreaInfo), 1))
				break;
			if (!soap_in_PointerTons4__MapAreaInfo(soap, tag, NULL, "ns4:MapAreaInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__MapAreaInfo(soap, tag, &n, "ns4:MapAreaInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__MapAreaInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__MapAreaInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__MapAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__MapAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__MapAreaInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__MapAreaInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__MapAreaInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__MapAreaInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__MapAreaInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__MapAreaInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__MapAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__MapAreaInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__MapAreaInfo * >*)p = *(std::vector<ns4__MapAreaInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(struct soap *soap, std::vector<ns4__RobotAlarmInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(struct soap *soap, const std::vector<ns4__RobotAlarmInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__RobotAlarmInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__RobotAlarmInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__RobotAlarmInfo * >*a, const char *type)
{
	for (std::vector<ns4__RobotAlarmInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__RobotAlarmInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__RobotAlarmInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(struct soap *soap, const char *tag, std::vector<ns4__RobotAlarmInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__RobotAlarmInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__RobotAlarmInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotAlarmInfo, sizeof(ns4__RobotAlarmInfo), 1))
				break;
			if (!soap_in_PointerTons4__RobotAlarmInfo(soap, tag, NULL, "ns4:RobotAlarmInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__RobotAlarmInfo(soap, tag, &n, "ns4:RobotAlarmInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__RobotAlarmInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotAlarmInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__RobotAlarmInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__RobotAlarmInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__RobotAlarmInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__RobotAlarmInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__RobotAlarmInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__RobotAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__RobotAlarmInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__RobotAlarmInfo * >*)p = *(std::vector<ns4__RobotAlarmInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__RobotGasInfo(struct soap *soap, std::vector<ns4__RobotGasInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__RobotGasInfo(struct soap *soap, const std::vector<ns4__RobotGasInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__RobotGasInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__RobotGasInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__RobotGasInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__RobotGasInfo * >*a, const char *type)
{
	for (std::vector<ns4__RobotGasInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__RobotGasInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__RobotGasInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__RobotGasInfo(struct soap *soap, const char *tag, std::vector<ns4__RobotGasInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__RobotGasInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__RobotGasInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotGasInfo, sizeof(ns4__RobotGasInfo), 1))
				break;
			if (!soap_in_PointerTons4__RobotGasInfo(soap, tag, NULL, "ns4:RobotGasInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__RobotGasInfo(soap, tag, &n, "ns4:RobotGasInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__RobotGasInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__RobotGasInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__RobotGasInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__RobotGasInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotGasInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__RobotGasInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__RobotGasInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__RobotGasInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__RobotGasInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__RobotGasInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__RobotGasInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__RobotGasInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__RobotGasInfo * >*)p = *(std::vector<ns4__RobotGasInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__RobotMileageInfo(struct soap *soap, std::vector<ns4__RobotMileageInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__RobotMileageInfo(struct soap *soap, const std::vector<ns4__RobotMileageInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__RobotMileageInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__RobotMileageInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__RobotMileageInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__RobotMileageInfo * >*a, const char *type)
{
	for (std::vector<ns4__RobotMileageInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__RobotMileageInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__RobotMileageInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__RobotMileageInfo(struct soap *soap, const char *tag, std::vector<ns4__RobotMileageInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__RobotMileageInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__RobotMileageInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotMileageInfo, sizeof(ns4__RobotMileageInfo), 1))
				break;
			if (!soap_in_PointerTons4__RobotMileageInfo(soap, tag, NULL, "ns4:RobotMileageInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__RobotMileageInfo(soap, tag, &n, "ns4:RobotMileageInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__RobotMileageInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__RobotMileageInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__RobotMileageInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__RobotMileageInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotMileageInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__RobotMileageInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__RobotMileageInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__RobotMileageInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__RobotMileageInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__RobotMileageInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__RobotMileageInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__RobotMileageInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__RobotMileageInfo * >*)p = *(std::vector<ns4__RobotMileageInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(struct soap *soap, std::vector<ns4__RobotYunTaiInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(struct soap *soap, const std::vector<ns4__RobotYunTaiInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__RobotYunTaiInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__RobotYunTaiInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__RobotYunTaiInfo * >*a, const char *type)
{
	for (std::vector<ns4__RobotYunTaiInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__RobotYunTaiInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__RobotYunTaiInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(struct soap *soap, const char *tag, std::vector<ns4__RobotYunTaiInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__RobotYunTaiInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo, sizeof(ns4__RobotYunTaiInfo), 1))
				break;
			if (!soap_in_PointerTons4__RobotYunTaiInfo(soap, tag, NULL, "ns4:RobotYunTaiInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__RobotYunTaiInfo(soap, tag, &n, "ns4:RobotYunTaiInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__RobotYunTaiInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__RobotYunTaiInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__RobotYunTaiInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__RobotYunTaiInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__RobotYunTaiInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__RobotYunTaiInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__RobotYunTaiInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__RobotYunTaiInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__RobotYunTaiInfo * >*)p = *(std::vector<ns4__RobotYunTaiInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__RobotPosInfo(struct soap *soap, std::vector<ns4__RobotPosInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__RobotPosInfo(struct soap *soap, const std::vector<ns4__RobotPosInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__RobotPosInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__RobotPosInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__RobotPosInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__RobotPosInfo * >*a, const char *type)
{
	for (std::vector<ns4__RobotPosInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__RobotPosInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__RobotPosInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__RobotPosInfo(struct soap *soap, const char *tag, std::vector<ns4__RobotPosInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__RobotPosInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__RobotPosInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotPosInfo, sizeof(ns4__RobotPosInfo), 1))
				break;
			if (!soap_in_PointerTons4__RobotPosInfo(soap, tag, NULL, "ns4:RobotPosInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__RobotPosInfo(soap, tag, &n, "ns4:RobotPosInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__RobotPosInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__RobotPosInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__RobotPosInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__RobotPosInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotPosInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__RobotPosInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__RobotPosInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__RobotPosInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__RobotPosInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__RobotPosInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__RobotPosInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__RobotPosInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__RobotPosInfo * >*)p = *(std::vector<ns4__RobotPosInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__RobotTaskState(struct soap *soap, std::vector<ns4__RobotTaskState * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__RobotTaskState(struct soap *soap, const std::vector<ns4__RobotTaskState * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__RobotTaskState * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__RobotTaskState(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__RobotTaskState(struct soap *soap, const char *tag, int id, const std::vector<ns4__RobotTaskState * >*a, const char *type)
{
	for (std::vector<ns4__RobotTaskState * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__RobotTaskState(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__RobotTaskState * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__RobotTaskState(struct soap *soap, const char *tag, std::vector<ns4__RobotTaskState * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__RobotTaskState *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__RobotTaskState, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotTaskState, sizeof(ns4__RobotTaskState), 1))
				break;
			if (!soap_in_PointerTons4__RobotTaskState(soap, tag, NULL, "ns4:RobotTaskState"))
				break;
		}
		else if (!soap_in_PointerTons4__RobotTaskState(soap, tag, &n, "ns4:RobotTaskState"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__RobotTaskState(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__RobotTaskState * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__RobotTaskState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__RobotTaskState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotTaskState, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__RobotTaskState * >);
		if (size)
			*size = sizeof(std::vector<ns4__RobotTaskState * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__RobotTaskState * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__RobotTaskState * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__RobotTaskState * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__RobotTaskState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__RobotTaskState * > %p -> %p\n", q, p));
	*(std::vector<ns4__RobotTaskState * >*)p = *(std::vector<ns4__RobotTaskState * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__SpeedInfo(struct soap *soap, std::vector<ns4__SpeedInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__SpeedInfo(struct soap *soap, const std::vector<ns4__SpeedInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__SpeedInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__SpeedInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__SpeedInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__SpeedInfo * >*a, const char *type)
{
	for (std::vector<ns4__SpeedInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__SpeedInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__SpeedInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__SpeedInfo(struct soap *soap, const char *tag, std::vector<ns4__SpeedInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__SpeedInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__SpeedInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__SpeedInfo, sizeof(ns4__SpeedInfo), 1))
				break;
			if (!soap_in_PointerTons4__SpeedInfo(soap, tag, NULL, "ns4:SpeedInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__SpeedInfo(soap, tag, &n, "ns4:SpeedInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__SpeedInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__SpeedInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__SpeedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__SpeedInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__SpeedInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__SpeedInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__SpeedInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__SpeedInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__SpeedInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__SpeedInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__SpeedInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__SpeedInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__SpeedInfo * >*)p = *(std::vector<ns4__SpeedInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__BatteryInfo(struct soap *soap, std::vector<ns4__BatteryInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__BatteryInfo(struct soap *soap, const std::vector<ns4__BatteryInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__BatteryInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__BatteryInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__BatteryInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__BatteryInfo * >*a, const char *type)
{
	for (std::vector<ns4__BatteryInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__BatteryInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__BatteryInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__BatteryInfo(struct soap *soap, const char *tag, std::vector<ns4__BatteryInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__BatteryInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__BatteryInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__BatteryInfo, sizeof(ns4__BatteryInfo), 1))
				break;
			if (!soap_in_PointerTons4__BatteryInfo(soap, tag, NULL, "ns4:BatteryInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__BatteryInfo(soap, tag, &n, "ns4:BatteryInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__BatteryInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__BatteryInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__BatteryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__BatteryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__BatteryInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__BatteryInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__BatteryInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__BatteryInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__BatteryInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__BatteryInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__BatteryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__BatteryInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__BatteryInfo * >*)p = *(std::vector<ns4__BatteryInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__RobotInfo(struct soap *soap, std::vector<ns4__RobotInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__RobotInfo(struct soap *soap, const std::vector<ns4__RobotInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__RobotInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__RobotInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__RobotInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__RobotInfo * >*a, const char *type)
{
	for (std::vector<ns4__RobotInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__RobotInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__RobotInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__RobotInfo(struct soap *soap, const char *tag, std::vector<ns4__RobotInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__RobotInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__RobotInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotInfo, sizeof(ns4__RobotInfo), 1))
				break;
			if (!soap_in_PointerTons4__RobotInfo(soap, tag, NULL, "ns4:RobotInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__RobotInfo(soap, tag, &n, "ns4:RobotInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__RobotInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__RobotInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__RobotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__RobotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__RobotInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__RobotInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__RobotInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__RobotInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__RobotInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__RobotInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__RobotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__RobotInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__RobotInfo * >*)p = *(std::vector<ns4__RobotInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__ConnectInfo(struct soap *soap, std::vector<ns4__ConnectInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__ConnectInfo(struct soap *soap, const std::vector<ns4__ConnectInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns4__ConnectInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__ConnectInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__ConnectInfo(struct soap *soap, const char *tag, int id, const std::vector<ns4__ConnectInfo * >*a, const char *type)
{
	for (std::vector<ns4__ConnectInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__ConnectInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__ConnectInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__ConnectInfo(struct soap *soap, const char *tag, std::vector<ns4__ConnectInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns4__ConnectInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskData_ns4__ConnectInfo, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__ConnectInfo, sizeof(ns4__ConnectInfo), 1))
				break;
			if (!soap_in_PointerTons4__ConnectInfo(soap, tag, NULL, "ns4:ConnectInfo"))
				break;
		}
		else if (!soap_in_PointerTons4__ConnectInfo(soap, tag, &n, "ns4:ConnectInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__ConnectInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__ConnectInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__ConnectInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__ConnectInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskData_std__vectorTemplateOfPointerTons4__ConnectInfo, n, TaskData_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__ConnectInfo * >);
		if (size)
			*size = sizeof(std::vector<ns4__ConnectInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns4__ConnectInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns4__ConnectInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns4__ConnectInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__ConnectInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__ConnectInfo * > %p -> %p\n", q, p));
	*(std::vector<ns4__ConnectInfo * >*)p = *(std::vector<ns4__ConnectInfo * >*)q;
}

} // namespace TaskData


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of TaskDataC.cpp */
