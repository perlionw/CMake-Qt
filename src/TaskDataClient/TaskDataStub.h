/* TaskDataStub.h
   Generated by gSOAP 2.8.16 from .\taskdata.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef TaskDataStub_H
#define TaskDataStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"http://tempuri.org/station.xsd"
#define SOAP_NAMESPACE_OF_ns3	"http://tempuri.org/robotdata.xsd"
#define SOAP_NAMESPACE_OF_ns4	"http://tempuri.org/taskdata.xsd"
#define SOAP_NAMESPACE_OF_ns5	"http://tempuri.org/taskfinish.xsd"
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20816
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace TaskData {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_TaskData_ns4__YuntaiControlType
#define SOAP_TYPE_TaskData_ns4__YuntaiControlType (67)
/* ns4:YuntaiControlType */
enum ns4__YuntaiControlType { ns4__YuntaiControlType__TurnUp = 0, ns4__YuntaiControlType__TurnDown = 1, ns4__YuntaiControlType__TurnLeft = 2, ns4__YuntaiControlType__TurnRight = 3, ns4__YuntaiControlType__TurnStop = 4, ns4__YuntaiControlType__TurnReset = 5 };
#endif

#ifndef SOAP_TYPE_TaskData_ns4__CameraControlType
#define SOAP_TYPE_TaskData_ns4__CameraControlType (68)
/* ns4:CameraControlType */
enum ns4__CameraControlType { ns4__CameraControlType__ZoomUp = 0, ns4__CameraControlType__ZoomUpStop = 1, ns4__CameraControlType__ZoomDown = 2, ns4__CameraControlType__ZoomDownStop = 3, ns4__CameraControlType__FocusNear = 4, ns4__CameraControlType__FocusNearStop = 5, ns4__CameraControlType__FocusFar = 6, ns4__CameraControlType__FocusFarStop = 7, ns4__CameraControlType__CameraReset = 8 };
#endif

#ifndef SOAP_TYPE_TaskData_ns4__LightControlType
#define SOAP_TYPE_TaskData_ns4__LightControlType (69)
/* ns4:LightControlType */
enum ns4__LightControlType { ns4__LightControlType__LightOn = 0, ns4__LightControlType__LightOff = 1 };
#endif

#ifndef SOAP_TYPE_TaskData_ns4__WiperControlType
#define SOAP_TYPE_TaskData_ns4__WiperControlType (70)
/* ns4:WiperControlType */
enum ns4__WiperControlType { ns4__WiperControlType__WiperOn = 0, ns4__WiperControlType__WiperOff = 1 };
#endif

#ifndef SOAP_TYPE_TaskData_ns4__FilrControlType
#define SOAP_TYPE_TaskData_ns4__FilrControlType (71)
/* ns4:FilrControlType */
enum ns4__FilrControlType { ns4__FilrControlType__FocusUp = 0, ns4__FilrControlType__FocusDown = 1, ns4__FilrControlType__AutoFocus = 2 };
#endif

#ifndef SOAP_TYPE_TaskData_ns4__LifterControlType
#define SOAP_TYPE_TaskData_ns4__LifterControlType (72)
/* ns4:LifterControlType */
enum ns4__LifterControlType { ns4__LifterControlType__LifterUp = 0, ns4__LifterControlType__LifterDown = 1, ns4__LifterControlType__LifterStop = 2 };
#endif

#ifndef SOAP_TYPE_TaskData_ns4__PdControlType
#define SOAP_TYPE_TaskData_ns4__PdControlType (73)
/* ns4:PdControlType */
enum ns4__PdControlType { ns4__PdControlType__PdForWard = 0, ns4__PdControlType__PdBackWord = 1, ns4__PdControlType__PdStop = 2 };
#endif

#ifndef SOAP_TYPE_TaskData_ns4__ControlTaskType
#define SOAP_TYPE_TaskData_ns4__ControlTaskType (74)
/* ns4:ControlTaskType */
enum ns4__ControlTaskType { ns4__ControlTaskType__CancelTask = 0, ns4__ControlTaskType__PauseTask = 1, ns4__ControlTaskType__ResumeTask = 2, ns4__ControlTaskType__ChargeTask = 3 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_TaskData_ns4__ConnectInfo
#define SOAP_TYPE_TaskData_ns4__ConnectInfo (8)
/* ns4:ConnectInfo */
class SOAP_CMAC ns4__ConnectInfo
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	bool State;	/* required element of type xsd:boolean */
	std::string ConnectDesc;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_TaskData_ns4__ConnectInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ConnectInfo() { ns4__ConnectInfo::soap_default(NULL); }
	virtual ~ns4__ConnectInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__ConnectInfos
#define SOAP_TYPE_TaskData_ns4__ConnectInfos (9)
/* ns4:ConnectInfos */
class SOAP_CMAC ns4__ConnectInfos
{
public:
	std::vector<ns4__ConnectInfo * >Infos;	/* optional element of type ns4:ConnectInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_TaskData_ns4__ConnectInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ConnectInfos() { ns4__ConnectInfos::soap_default(NULL); }
	virtual ~ns4__ConnectInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotInfo
#define SOAP_TYPE_TaskData_ns4__RobotInfo (10)
/* ns4:RobotInfo */
class SOAP_CMAC ns4__RobotInfo
{
public:
	std::string RobotName;	/* required element of type xsd:string */
	std::string RobotIp;	/* required element of type xsd:string */
	std::string CameraIp;	/* required element of type xsd:string */
	int CameraPort;	/* required element of type xsd:int */
	std::string FlirIp;	/* required element of type xsd:string */
	int FlirPort;	/* required element of type xsd:int */
	std::string CameraUser;	/* required element of type xsd:string */
	std::string CameraPassword;	/* required element of type xsd:string */
	std::string FlirUser;	/* required element of type xsd:string */
	std::string FlirPassword;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotInfo() { ns4__RobotInfo::soap_default(NULL); }
	virtual ~ns4__RobotInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotInfos
#define SOAP_TYPE_TaskData_ns4__RobotInfos (11)
/* ns4:RobotInfos */
class SOAP_CMAC ns4__RobotInfos
{
public:
	std::vector<ns4__RobotInfo * >Infos;	/* optional element of type ns4:RobotInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotInfos() { ns4__RobotInfos::soap_default(NULL); }
	virtual ~ns4__RobotInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__BatteryInfo
#define SOAP_TYPE_TaskData_ns4__BatteryInfo (12)
/* ns4:BatteryInfo */
class SOAP_CMAC ns4__BatteryInfo
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	double BatteryValue;	/* required element of type xsd:double */
	double BatteryPercent;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_TaskData_ns4__BatteryInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__BatteryInfo() { ns4__BatteryInfo::soap_default(NULL); }
	virtual ~ns4__BatteryInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__BatteryInfos
#define SOAP_TYPE_TaskData_ns4__BatteryInfos (13)
/* ns4:BatteryInfos */
class SOAP_CMAC ns4__BatteryInfos
{
public:
	std::vector<ns4__BatteryInfo * >Infos;	/* optional element of type ns4:BatteryInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_TaskData_ns4__BatteryInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__BatteryInfos() { ns4__BatteryInfos::soap_default(NULL); }
	virtual ~ns4__BatteryInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__SpeedInfo
#define SOAP_TYPE_TaskData_ns4__SpeedInfo (14)
/* ns4:SpeedInfo */
class SOAP_CMAC ns4__SpeedInfo
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	double Speed;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_TaskData_ns4__SpeedInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__SpeedInfo() { ns4__SpeedInfo::soap_default(NULL); }
	virtual ~ns4__SpeedInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__SpeedInfos
#define SOAP_TYPE_TaskData_ns4__SpeedInfos (15)
/* ns4:SpeedInfos */
class SOAP_CMAC ns4__SpeedInfos
{
public:
	std::vector<ns4__SpeedInfo * >Infos;	/* optional element of type ns4:SpeedInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_TaskData_ns4__SpeedInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__SpeedInfos() { ns4__SpeedInfos::soap_default(NULL); }
	virtual ~ns4__SpeedInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotTaskState
#define SOAP_TYPE_TaskData_ns4__RobotTaskState (16)
/* ns4:RobotTaskState */
class SOAP_CMAC ns4__RobotTaskState
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	std::string TaskId;	/* required element of type xsd:string */
	std::string TaskType;	/* required element of type xsd:string */
	std::string TaskDesc;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotTaskState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotTaskState() { ns4__RobotTaskState::soap_default(NULL); }
	virtual ~ns4__RobotTaskState() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotTaskStates
#define SOAP_TYPE_TaskData_ns4__RobotTaskStates (17)
/* ns4:RobotTaskStates */
class SOAP_CMAC ns4__RobotTaskStates
{
public:
	std::vector<ns4__RobotTaskState * >States;	/* optional element of type ns4:RobotTaskState */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotTaskStates */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotTaskStates() { ns4__RobotTaskStates::soap_default(NULL); }
	virtual ~ns4__RobotTaskStates() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotPosInfo
#define SOAP_TYPE_TaskData_ns4__RobotPosInfo (18)
/* ns4:RobotPosInfo */
class SOAP_CMAC ns4__RobotPosInfo
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	std::string PosX;	/* required element of type xsd:string */
	std::string PosY;	/* required element of type xsd:string */
	std::string Angle;	/* required element of type xsd:string */
	std::string EdgeID;	/* required element of type xsd:string */
	std::string Precent;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotPosInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotPosInfo() { ns4__RobotPosInfo::soap_default(NULL); }
	virtual ~ns4__RobotPosInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotPosInfos
#define SOAP_TYPE_TaskData_ns4__RobotPosInfos (19)
/* ns4:RobotPosInfos */
class SOAP_CMAC ns4__RobotPosInfos
{
public:
	std::vector<ns4__RobotPosInfo * >Infos;	/* optional element of type ns4:RobotPosInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotPosInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotPosInfos() { ns4__RobotPosInfos::soap_default(NULL); }
	virtual ~ns4__RobotPosInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo
#define SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo (20)
/* ns4:RobotYunTaiInfo */
class SOAP_CMAC ns4__RobotYunTaiInfo
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	std::string PosPan;	/* required element of type xsd:string */
	std::string PosTile;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotYunTaiInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotYunTaiInfo() { ns4__RobotYunTaiInfo::soap_default(NULL); }
	virtual ~ns4__RobotYunTaiInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos
#define SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos (21)
/* ns4:RobotYunTaiInfos */
class SOAP_CMAC ns4__RobotYunTaiInfos
{
public:
	std::vector<ns4__RobotYunTaiInfo * >Infos;	/* optional element of type ns4:RobotYunTaiInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotYunTaiInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotYunTaiInfos() { ns4__RobotYunTaiInfos::soap_default(NULL); }
	virtual ~ns4__RobotYunTaiInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotMileageInfo
#define SOAP_TYPE_TaskData_ns4__RobotMileageInfo (22)
/* ns4:RobotMileageInfo */
class SOAP_CMAC ns4__RobotMileageInfo
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	double Mileage;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotMileageInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotMileageInfo() { ns4__RobotMileageInfo::soap_default(NULL); }
	virtual ~ns4__RobotMileageInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotMileageInfos
#define SOAP_TYPE_TaskData_ns4__RobotMileageInfos (23)
/* ns4:RobotMileageInfos */
class SOAP_CMAC ns4__RobotMileageInfos
{
public:
	std::vector<ns4__RobotMileageInfo * >Infos;	/* optional element of type ns4:RobotMileageInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotMileageInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotMileageInfos() { ns4__RobotMileageInfos::soap_default(NULL); }
	virtual ~ns4__RobotMileageInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotGasInfo
#define SOAP_TYPE_TaskData_ns4__RobotGasInfo (24)
/* ns4:RobotGasInfo */
class SOAP_CMAC ns4__RobotGasInfo
{
public:
	std::string robot_ip;	/* required element of type xsd:string */
	std::string H2S;	/* required element of type xsd:string */
	std::string CO;	/* required element of type xsd:string */
	std::string O2;	/* required element of type xsd:string */
	std::string CH4;	/* required element of type xsd:string */
	std::string TEMP;	/* required element of type xsd:string */
	std::string HUM;	/* required element of type xsd:string */
	std::string PM25;	/* required element of type xsd:string */
	std::string PM10;	/* required element of type xsd:string */
	std::string O3;	/* required element of type xsd:string */
	std::string SF6;	/* required element of type xsd:string */
	std::string Desc;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotGasInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotGasInfo() { ns4__RobotGasInfo::soap_default(NULL); }
	virtual ~ns4__RobotGasInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotGasInfos
#define SOAP_TYPE_TaskData_ns4__RobotGasInfos (25)
/* ns4:RobotGasInfos */
class SOAP_CMAC ns4__RobotGasInfos
{
public:
	std::vector<ns4__RobotGasInfo * >GasContents;	/* optional element of type ns4:RobotGasInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotGasInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotGasInfos() { ns4__RobotGasInfos::soap_default(NULL); }
	virtual ~ns4__RobotGasInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotAlarmInfo
#define SOAP_TYPE_TaskData_ns4__RobotAlarmInfo (26)
/* ns4:RobotAlarmInfo */
class SOAP_CMAC ns4__RobotAlarmInfo
{
public:
	std::string AlarmId;	/* required element of type xsd:string */
	std::string RobotIp;	/* required element of type xsd:string */
	std::string AlarmType;	/* required element of type xsd:string */
	std::string AlarmDesc;	/* required element of type xsd:string */
	std::string AlarmTime;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotAlarmInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotAlarmInfo() { ns4__RobotAlarmInfo::soap_default(NULL); }
	virtual ~ns4__RobotAlarmInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__RobotAlarmInfos
#define SOAP_TYPE_TaskData_ns4__RobotAlarmInfos (27)
/* ns4:RobotAlarmInfos */
class SOAP_CMAC ns4__RobotAlarmInfos
{
public:
	std::vector<ns4__RobotAlarmInfo * >Infos;	/* optional element of type ns4:RobotAlarmInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_TaskData_ns4__RobotAlarmInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RobotAlarmInfos() { ns4__RobotAlarmInfos::soap_default(NULL); }
	virtual ~ns4__RobotAlarmInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__MapAreaInfo
#define SOAP_TYPE_TaskData_ns4__MapAreaInfo (28)
/* ns4:MapAreaInfo */
class SOAP_CMAC ns4__MapAreaInfo
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	std::string AreaId;	/* required element of type xsd:string */
	std::string AreaName;	/* required element of type xsd:string */
	std::string AreaMap;	/* required element of type xsd:string */
	std::string MaxX;	/* required element of type xsd:string */
	std::string MaxY;	/* required element of type xsd:string */
	std::string MinX;	/* required element of type xsd:string */
	std::string MinY;	/* required element of type xsd:string */
	std::string ParentId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_TaskData_ns4__MapAreaInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__MapAreaInfo() { ns4__MapAreaInfo::soap_default(NULL); }
	virtual ~ns4__MapAreaInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__MapAreaInfos
#define SOAP_TYPE_TaskData_ns4__MapAreaInfos (29)
/* ns4:MapAreaInfos */
class SOAP_CMAC ns4__MapAreaInfos
{
public:
	std::vector<ns4__MapAreaInfo * >Infos;	/* optional element of type ns4:MapAreaInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_TaskData_ns4__MapAreaInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__MapAreaInfos() { ns4__MapAreaInfos::soap_default(NULL); }
	virtual ~ns4__MapAreaInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__PatrolAreaInfo
#define SOAP_TYPE_TaskData_ns4__PatrolAreaInfo (30)
/* ns4:PatrolAreaInfo */
class SOAP_CMAC ns4__PatrolAreaInfo
{
public:
	std::string AreaId;	/* required element of type xsd:string */
	std::string AreaName;	/* required element of type xsd:string */
	std::string ParentId;	/* required element of type xsd:string */
	std::string RobotIp;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_TaskData_ns4__PatrolAreaInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__PatrolAreaInfo() { ns4__PatrolAreaInfo::soap_default(NULL); }
	virtual ~ns4__PatrolAreaInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__PatrolAreaInfos
#define SOAP_TYPE_TaskData_ns4__PatrolAreaInfos (31)
/* ns4:PatrolAreaInfos */
class SOAP_CMAC ns4__PatrolAreaInfos
{
public:
	std::vector<ns4__PatrolAreaInfo * >Infos;	/* optional element of type ns4:PatrolAreaInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_TaskData_ns4__PatrolAreaInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__PatrolAreaInfos() { ns4__PatrolAreaInfos::soap_default(NULL); }
	virtual ~ns4__PatrolAreaInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__MapEdgeInfo
#define SOAP_TYPE_TaskData_ns4__MapEdgeInfo (32)
/* ns4:MapEdgeInfo */
class SOAP_CMAC ns4__MapEdgeInfo
{
public:
	std::string EdgeId;	/* required element of type xsd:string */
	std::string StartNodeId;	/* required element of type xsd:string */
	std::string EndNodeId;	/* required element of type xsd:string */
	std::string StartNodeX;	/* required element of type xsd:string */
	std::string StartNodeY;	/* required element of type xsd:string */
	std::string EndNodeX;	/* required element of type xsd:string */
	std::string EndNodeY;	/* required element of type xsd:string */
	std::string FirstControlX;	/* required element of type xsd:string */
	std::string FirstControlY;	/* required element of type xsd:string */
	std::string SecondControlX;	/* required element of type xsd:string */
	std::string SecondControlY;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_TaskData_ns4__MapEdgeInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__MapEdgeInfo() { ns4__MapEdgeInfo::soap_default(NULL); }
	virtual ~ns4__MapEdgeInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__MapEdgeInfos
#define SOAP_TYPE_TaskData_ns4__MapEdgeInfos (33)
/* ns4:MapEdgeInfos */
class SOAP_CMAC ns4__MapEdgeInfos
{
public:
	std::vector<ns4__MapEdgeInfo * >Infos;	/* optional element of type ns4:MapEdgeInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_TaskData_ns4__MapEdgeInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__MapEdgeInfos() { ns4__MapEdgeInfos::soap_default(NULL); }
	virtual ~ns4__MapEdgeInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__DockPointInfo
#define SOAP_TYPE_TaskData_ns4__DockPointInfo (34)
/* ns4:DockPointInfo */
class SOAP_CMAC ns4__DockPointInfo
{
public:
	std::string DockId;	/* required element of type xsd:string */
	std::string DockX;	/* required element of type xsd:string */
	std::string DockY;	/* required element of type xsd:string */
	std::vector<std::string >PointList;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_TaskData_ns4__DockPointInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__DockPointInfo() { ns4__DockPointInfo::soap_default(NULL); }
	virtual ~ns4__DockPointInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__DockPointInfos
#define SOAP_TYPE_TaskData_ns4__DockPointInfos (35)
/* ns4:DockPointInfos */
class SOAP_CMAC ns4__DockPointInfos
{
public:
	std::vector<ns4__DockPointInfo * >Infos;	/* optional element of type ns4:DockPointInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_TaskData_ns4__DockPointInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__DockPointInfos() { ns4__DockPointInfos::soap_default(NULL); }
	virtual ~ns4__DockPointInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__PatrolPointInfo
#define SOAP_TYPE_TaskData_ns4__PatrolPointInfo (36)
/* ns4:PatrolPointInfo */
class SOAP_CMAC ns4__PatrolPointInfo
{
public:
	std::string PointId;	/* required element of type xsd:string */
	std::string PointName;	/* required element of type xsd:string */
	std::string PointType;	/* required element of type xsd:string */
	std::string DeviceType;	/* required element of type xsd:string */
	std::string AreaId;	/* required element of type xsd:string */
	std::string DockId;	/* required element of type xsd:string */
	std::string RobotIp;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_TaskData_ns4__PatrolPointInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__PatrolPointInfo() { ns4__PatrolPointInfo::soap_default(NULL); }
	virtual ~ns4__PatrolPointInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__PatrolPointInfos
#define SOAP_TYPE_TaskData_ns4__PatrolPointInfos (37)
/* ns4:PatrolPointInfos */
class SOAP_CMAC ns4__PatrolPointInfos
{
public:
	std::vector<ns4__PatrolPointInfo * >Infos;	/* optional element of type ns4:PatrolPointInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_TaskData_ns4__PatrolPointInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__PatrolPointInfos() { ns4__PatrolPointInfos::soap_default(NULL); }
	virtual ~ns4__PatrolPointInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__TaskPathInfo
#define SOAP_TYPE_TaskData_ns4__TaskPathInfo (38)
/* ns4:TaskPathInfo */
class SOAP_CMAC ns4__TaskPathInfo
{
public:
	std::string TaskPathId;	/* required element of type xsd:string */
	std::string TaskPathName;	/* required element of type xsd:string */
	std::vector<std::string >PointList;	/* optional element of type xsd:string */
	std::string TaskPathType;	/* required element of type xsd:string */
	std::string CreateTime;	/* required element of type xsd:string */
	int FinishAction;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_TaskData_ns4__TaskPathInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__TaskPathInfo() { ns4__TaskPathInfo::soap_default(NULL); }
	virtual ~ns4__TaskPathInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__TaskPathInfos
#define SOAP_TYPE_TaskData_ns4__TaskPathInfos (39)
/* ns4:TaskPathInfos */
class SOAP_CMAC ns4__TaskPathInfos
{
public:
	std::vector<ns4__TaskPathInfo * >Infos;	/* optional element of type ns4:TaskPathInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_TaskData_ns4__TaskPathInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__TaskPathInfos() { ns4__TaskPathInfos::soap_default(NULL); }
	virtual ~ns4__TaskPathInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__TaskExcuteData
#define SOAP_TYPE_TaskData_ns4__TaskExcuteData (40)
/* ns4:TaskExcuteData */
class SOAP_CMAC ns4__TaskExcuteData
{
public:
	std::string RobotIp;	/* required element of type xsd:string */
	std::string TaskType;	/* required element of type xsd:string */
	std::string TaskId;	/* required element of type xsd:string */
	std::string TaskName;	/* required element of type xsd:string */
	std::string PatrolDeviceName;	/* required element of type xsd:string */
	std::string PatrolDeviceId;	/* required element of type xsd:string */
	int TotalDeviceSize;	/* required element of type xsd:int */
	int ErrorDeviceSize;	/* required element of type xsd:int */
	int FinishDeviceSize;	/* required element of type xsd:int */
	int TaskFinishPercentage;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_TaskData_ns4__TaskExcuteData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__TaskExcuteData() { ns4__TaskExcuteData::soap_default(NULL); }
	virtual ~ns4__TaskExcuteData() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__TaskFinishInfo
#define SOAP_TYPE_TaskData_ns4__TaskFinishInfo (41)
/* ns4:TaskFinishInfo */
class SOAP_CMAC ns4__TaskFinishInfo
{
public:
	std::string TaskId;	/* required element of type xsd:string */
	std::string TaskName;	/* required element of type xsd:string */
	std::string TaskType;	/* required element of type xsd:string */
	std::string TaskPathId;	/* required element of type xsd:string */
	std::vector<std::string >PointList;	/* optional element of type xsd:string */
	std::string StartTime;	/* required element of type xsd:string */
	std::string EndTime;	/* required element of type xsd:string */
	std::string FinishState;	/* required element of type xsd:string */
	std::string ExcuteRobot;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_TaskData_ns4__TaskFinishInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__TaskFinishInfo() { ns4__TaskFinishInfo::soap_default(NULL); }
	virtual ~ns4__TaskFinishInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__TaskFinishInfos
#define SOAP_TYPE_TaskData_ns4__TaskFinishInfos (42)
/* ns4:TaskFinishInfos */
class SOAP_CMAC ns4__TaskFinishInfos
{
public:
	std::vector<ns4__TaskFinishInfo * >Infos;	/* optional element of type ns4:TaskFinishInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_TaskData_ns4__TaskFinishInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__TaskFinishInfos() { ns4__TaskFinishInfos::soap_default(NULL); }
	virtual ~ns4__TaskFinishInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__TaskExcuteInfo
#define SOAP_TYPE_TaskData_ns4__TaskExcuteInfo (43)
/* ns4:TaskExcuteInfo */
class SOAP_CMAC ns4__TaskExcuteInfo
{
public:
	std::string TaskId;	/* required element of type xsd:string */
	std::string TaskName;	/* required element of type xsd:string */
	std::string TaskType;	/* required element of type xsd:string */
	std::string TaskPathId;	/* required element of type xsd:string */
	std::string TargetId;	/* required element of type xsd:string */
	std::string PointId;	/* required element of type xsd:string */
	std::string PointName;	/* required element of type xsd:string */
	std::string PointType;	/* required element of type xsd:string */
	std::string ExcuteTime;	/* required element of type xsd:string */
	std::string ExcuteValue;	/* required element of type xsd:string */
	std::string ExcuteUnit;	/* required element of type xsd:string */
	std::string ExcuteState;	/* required element of type xsd:string */
	std::string ExcuteDesc;	/* required element of type xsd:string */
	std::string HDPicture;	/* required element of type xsd:string */
	std::string InfraredPicture;	/* required element of type xsd:string */
	std::string OtherFile;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_TaskData_ns4__TaskExcuteInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__TaskExcuteInfo() { ns4__TaskExcuteInfo::soap_default(NULL); }
	virtual ~ns4__TaskExcuteInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData_ns4__TaskExcuteInfos
#define SOAP_TYPE_TaskData_ns4__TaskExcuteInfos (44)
/* ns4:TaskExcuteInfos */
class SOAP_CMAC ns4__TaskExcuteInfos
{
public:
	std::vector<ns4__TaskExcuteInfo * >Infos;	/* optional element of type ns4:TaskExcuteInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_TaskData_ns4__TaskExcuteInfos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__TaskExcuteInfos() { ns4__TaskExcuteInfos::soap_default(NULL); }
	virtual ~ns4__TaskExcuteInfos() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetMapAreaInfo
#define SOAP_TYPE_TaskData__ns4__GetMapAreaInfo (45)
/* ns4:GetMapAreaInfo */
class SOAP_CMAC _ns4__GetMapAreaInfo
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_TaskData__ns4__GetMapAreaInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetMapAreaInfo() { _ns4__GetMapAreaInfo::soap_default(NULL); }
	virtual ~_ns4__GetMapAreaInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse
#define SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse (46)
/* ns4:GetMapAreaInfoResponse */
class SOAP_CMAC _ns4__GetMapAreaInfoResponse
{
public:
	ns4__MapAreaInfos *Data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns4:MapAreaInfos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_TaskData__ns4__GetMapAreaInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetMapAreaInfoResponse() { _ns4__GetMapAreaInfoResponse::soap_default(NULL); }
	virtual ~_ns4__GetMapAreaInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo
#define SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo (47)
/* ns4:GetPatrolAreaInfo */
class SOAP_CMAC _ns4__GetPatrolAreaInfo
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetPatrolAreaInfo() { _ns4__GetPatrolAreaInfo::soap_default(NULL); }
	virtual ~_ns4__GetPatrolAreaInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse
#define SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse (48)
/* ns4:GetPatrolAreaInfoResponse */
class SOAP_CMAC _ns4__GetPatrolAreaInfoResponse
{
public:
	ns4__PatrolAreaInfos *Data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns4:PatrolAreaInfos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_TaskData__ns4__GetPatrolAreaInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetPatrolAreaInfoResponse() { _ns4__GetPatrolAreaInfoResponse::soap_default(NULL); }
	virtual ~_ns4__GetPatrolAreaInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo
#define SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo (49)
/* ns4:GetMapEdgeInfo */
class SOAP_CMAC _ns4__GetMapEdgeInfo
{
public:
	std::string AreaId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_TaskData__ns4__GetMapEdgeInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetMapEdgeInfo() { _ns4__GetMapEdgeInfo::soap_default(NULL); }
	virtual ~_ns4__GetMapEdgeInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse
#define SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse (50)
/* ns4:GetMapEdgeInfoResponse */
class SOAP_CMAC _ns4__GetMapEdgeInfoResponse
{
public:
	ns4__MapEdgeInfos *Data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns4:MapEdgeInfos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_TaskData__ns4__GetMapEdgeInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetMapEdgeInfoResponse() { _ns4__GetMapEdgeInfoResponse::soap_default(NULL); }
	virtual ~_ns4__GetMapEdgeInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetDockPointInfo
#define SOAP_TYPE_TaskData__ns4__GetDockPointInfo (51)
/* ns4:GetDockPointInfo */
class SOAP_CMAC _ns4__GetDockPointInfo
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_TaskData__ns4__GetDockPointInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetDockPointInfo() { _ns4__GetDockPointInfo::soap_default(NULL); }
	virtual ~_ns4__GetDockPointInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse
#define SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse (52)
/* ns4:GetDockPointInfoResponse */
class SOAP_CMAC _ns4__GetDockPointInfoResponse
{
public:
	ns4__DockPointInfos *Data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns4:DockPointInfos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_TaskData__ns4__GetDockPointInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetDockPointInfoResponse() { _ns4__GetDockPointInfoResponse::soap_default(NULL); }
	virtual ~_ns4__GetDockPointInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo
#define SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo (53)
/* ns4:GetPatrolPointInfo */
class SOAP_CMAC _ns4__GetPatrolPointInfo
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_TaskData__ns4__GetPatrolPointInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetPatrolPointInfo() { _ns4__GetPatrolPointInfo::soap_default(NULL); }
	virtual ~_ns4__GetPatrolPointInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse
#define SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse (54)
/* ns4:GetPatrolPointInfoResponse */
class SOAP_CMAC _ns4__GetPatrolPointInfoResponse
{
public:
	ns4__PatrolPointInfos *Data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns4:PatrolPointInfos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_TaskData__ns4__GetPatrolPointInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetPatrolPointInfoResponse() { _ns4__GetPatrolPointInfoResponse::soap_default(NULL); }
	virtual ~_ns4__GetPatrolPointInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetTaskPathInfo
#define SOAP_TYPE_TaskData__ns4__GetTaskPathInfo (55)
/* ns4:GetTaskPathInfo */
class SOAP_CMAC _ns4__GetTaskPathInfo
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_TaskData__ns4__GetTaskPathInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetTaskPathInfo() { _ns4__GetTaskPathInfo::soap_default(NULL); }
	virtual ~_ns4__GetTaskPathInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse
#define SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse (56)
/* ns4:GetTaskPathInfoResponse */
class SOAP_CMAC _ns4__GetTaskPathInfoResponse
{
public:
	ns4__TaskPathInfos *Data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns4:TaskPathInfos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_TaskData__ns4__GetTaskPathInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetTaskPathInfoResponse() { _ns4__GetTaskPathInfoResponse::soap_default(NULL); }
	virtual ~_ns4__GetTaskPathInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__StartTaskByPathId
#define SOAP_TYPE_TaskData__ns4__StartTaskByPathId (57)
/* ns4:StartTaskByPathId */
class SOAP_CMAC _ns4__StartTaskByPathId
{
public:
	std::string TaskId;	/* required element of type xsd:string */
	std::string TaskPathId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_TaskData__ns4__StartTaskByPathId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__StartTaskByPathId() { _ns4__StartTaskByPathId::soap_default(NULL); }
	virtual ~_ns4__StartTaskByPathId() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse
#define SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse (58)
/* ns4:StartTaskByPathIdResponse */
class SOAP_CMAC _ns4__StartTaskByPathIdResponse
{
public:
	int Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_TaskData__ns4__StartTaskByPathIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__StartTaskByPathIdResponse() { _ns4__StartTaskByPathIdResponse::soap_default(NULL); }
	virtual ~_ns4__StartTaskByPathIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__StartTaskByPointList
#define SOAP_TYPE_TaskData__ns4__StartTaskByPointList (59)
/* ns4:StartTaskByPointList */
class SOAP_CMAC _ns4__StartTaskByPointList
{
public:
	std::string TaskId;	/* required element of type xsd:string */
	std::vector<std::string >PointList;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_TaskData__ns4__StartTaskByPointList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__StartTaskByPointList() { _ns4__StartTaskByPointList::soap_default(NULL); }
	virtual ~_ns4__StartTaskByPointList() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse
#define SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse (60)
/* ns4:StartTaskByPointListResponse */
class SOAP_CMAC _ns4__StartTaskByPointListResponse
{
public:
	int Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_TaskData__ns4__StartTaskByPointListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__StartTaskByPointListResponse() { _ns4__StartTaskByPointListResponse::soap_default(NULL); }
	virtual ~_ns4__StartTaskByPointListResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__SetTaskPathInfo
#define SOAP_TYPE_TaskData__ns4__SetTaskPathInfo (61)
/* ns4:SetTaskPathInfo */
class SOAP_CMAC _ns4__SetTaskPathInfo
{
public:
	ns4__TaskPathInfo *info;	/* required element of type ns4:TaskPathInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_TaskData__ns4__SetTaskPathInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SetTaskPathInfo() { _ns4__SetTaskPathInfo::soap_default(NULL); }
	virtual ~_ns4__SetTaskPathInfo() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse
#define SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse (62)
/* ns4:SetTaskPathInfoResponse */
class SOAP_CMAC _ns4__SetTaskPathInfoResponse
{
public:
	int Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_TaskData__ns4__SetTaskPathInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SetTaskPathInfoResponse() { _ns4__SetTaskPathInfoResponse::soap_default(NULL); }
	virtual ~_ns4__SetTaskPathInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__RobotControlTask
#define SOAP_TYPE_TaskData__ns4__RobotControlTask (63)
/* ns4:RobotControlTask */
class SOAP_CMAC _ns4__RobotControlTask
{
public:
	enum ns4__ControlTaskType Type;	/* required element of type ns4:ControlTaskType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_TaskData__ns4__RobotControlTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__RobotControlTask() { _ns4__RobotControlTask::soap_default(NULL); }
	virtual ~_ns4__RobotControlTask() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse
#define SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse (64)
/* ns4:RobotControlTaskResponse */
class SOAP_CMAC _ns4__RobotControlTaskResponse
{
public:
	int Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_TaskData__ns4__RobotControlTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__RobotControlTaskResponse() { _ns4__RobotControlTaskResponse::soap_default(NULL); }
	virtual ~_ns4__RobotControlTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetTaskExcuteData
#define SOAP_TYPE_TaskData__ns4__GetTaskExcuteData (65)
/* ns4:GetTaskExcuteData */
class SOAP_CMAC _ns4__GetTaskExcuteData
{
public:
	std::string robotIp;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_TaskData__ns4__GetTaskExcuteData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetTaskExcuteData() { _ns4__GetTaskExcuteData::soap_default(NULL); }
	virtual ~_ns4__GetTaskExcuteData() { }
};
#endif

#ifndef SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse
#define SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse (66)
/* ns4:GetTaskExcuteDataResponse */
class SOAP_CMAC _ns4__GetTaskExcuteDataResponse
{
public:
	ns4__TaskExcuteData *Data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns4:TaskExcuteData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_TaskData__ns4__GetTaskExcuteDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetTaskExcuteDataResponse() { _ns4__GetTaskExcuteDataResponse::soap_default(NULL); }
	virtual ~_ns4__GetTaskExcuteDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__GetMapAreaInfo
#define SOAP_TYPE_TaskData___ns1__GetMapAreaInfo (126)
/* Operation wrapper: */
struct __ns1__GetMapAreaInfo
{
public:
	_ns4__GetMapAreaInfo *ns4__GetMapAreaInfo;	/* optional element of type ns4:GetMapAreaInfo */
public:
	int soap_type() const { return 126; } /* = unique id SOAP_TYPE_TaskData___ns1__GetMapAreaInfo */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__GetPatrolAreaInfo
#define SOAP_TYPE_TaskData___ns1__GetPatrolAreaInfo (130)
/* Operation wrapper: */
struct __ns1__GetPatrolAreaInfo
{
public:
	_ns4__GetPatrolAreaInfo *ns4__GetPatrolAreaInfo;	/* optional element of type ns4:GetPatrolAreaInfo */
public:
	int soap_type() const { return 130; } /* = unique id SOAP_TYPE_TaskData___ns1__GetPatrolAreaInfo */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__GetMapEdgeInfo
#define SOAP_TYPE_TaskData___ns1__GetMapEdgeInfo (134)
/* Operation wrapper: */
struct __ns1__GetMapEdgeInfo
{
public:
	_ns4__GetMapEdgeInfo *ns4__GetMapEdgeInfo;	/* optional element of type ns4:GetMapEdgeInfo */
public:
	int soap_type() const { return 134; } /* = unique id SOAP_TYPE_TaskData___ns1__GetMapEdgeInfo */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__GetDockPointInfo
#define SOAP_TYPE_TaskData___ns1__GetDockPointInfo (138)
/* Operation wrapper: */
struct __ns1__GetDockPointInfo
{
public:
	_ns4__GetDockPointInfo *ns4__GetDockPointInfo;	/* optional element of type ns4:GetDockPointInfo */
public:
	int soap_type() const { return 138; } /* = unique id SOAP_TYPE_TaskData___ns1__GetDockPointInfo */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__GetPatrolPointInfo
#define SOAP_TYPE_TaskData___ns1__GetPatrolPointInfo (142)
/* Operation wrapper: */
struct __ns1__GetPatrolPointInfo
{
public:
	_ns4__GetPatrolPointInfo *ns4__GetPatrolPointInfo;	/* optional element of type ns4:GetPatrolPointInfo */
public:
	int soap_type() const { return 142; } /* = unique id SOAP_TYPE_TaskData___ns1__GetPatrolPointInfo */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__GetTaskPathInfo
#define SOAP_TYPE_TaskData___ns1__GetTaskPathInfo (146)
/* Operation wrapper: */
struct __ns1__GetTaskPathInfo
{
public:
	_ns4__GetTaskPathInfo *ns4__GetTaskPathInfo;	/* optional element of type ns4:GetTaskPathInfo */
public:
	int soap_type() const { return 146; } /* = unique id SOAP_TYPE_TaskData___ns1__GetTaskPathInfo */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__StartTaskByPathId
#define SOAP_TYPE_TaskData___ns1__StartTaskByPathId (150)
/* Operation wrapper: */
struct __ns1__StartTaskByPathId
{
public:
	_ns4__StartTaskByPathId *ns4__StartTaskByPathId;	/* optional element of type ns4:StartTaskByPathId */
public:
	int soap_type() const { return 150; } /* = unique id SOAP_TYPE_TaskData___ns1__StartTaskByPathId */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__StartTaskByPointList
#define SOAP_TYPE_TaskData___ns1__StartTaskByPointList (154)
/* Operation wrapper: */
struct __ns1__StartTaskByPointList
{
public:
	_ns4__StartTaskByPointList *ns4__StartTaskByPointList;	/* optional element of type ns4:StartTaskByPointList */
public:
	int soap_type() const { return 154; } /* = unique id SOAP_TYPE_TaskData___ns1__StartTaskByPointList */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__SetTaskPathInfo
#define SOAP_TYPE_TaskData___ns1__SetTaskPathInfo (158)
/* Operation wrapper: */
struct __ns1__SetTaskPathInfo
{
public:
	_ns4__SetTaskPathInfo *ns4__SetTaskPathInfo;	/* optional element of type ns4:SetTaskPathInfo */
public:
	int soap_type() const { return 158; } /* = unique id SOAP_TYPE_TaskData___ns1__SetTaskPathInfo */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__RobotControlTask
#define SOAP_TYPE_TaskData___ns1__RobotControlTask (162)
/* Operation wrapper: */
struct __ns1__RobotControlTask
{
public:
	_ns4__RobotControlTask *ns4__RobotControlTask;	/* optional element of type ns4:RobotControlTask */
public:
	int soap_type() const { return 162; } /* = unique id SOAP_TYPE_TaskData___ns1__RobotControlTask */
};
#endif

#ifndef SOAP_TYPE_TaskData___ns1__GetTaskExcuteData
#define SOAP_TYPE_TaskData___ns1__GetTaskExcuteData (166)
/* Operation wrapper: */
struct __ns1__GetTaskExcuteData
{
public:
	_ns4__GetTaskExcuteData *ns4__GetTaskExcuteData;	/* optional element of type ns4:GetTaskExcuteData */
public:
	int soap_type() const { return 166; } /* = unique id SOAP_TYPE_TaskData___ns1__GetTaskExcuteData */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_TaskData_SOAP_ENV__Header
#define SOAP_TYPE_TaskData_SOAP_ENV__Header (167)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 167; } /* = unique id SOAP_TYPE_TaskData_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_TaskData_SOAP_ENV__Code
#define SOAP_TYPE_TaskData_SOAP_ENV__Code (168)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 168; } /* = unique id SOAP_TYPE_TaskData_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_TaskData_SOAP_ENV__Detail
#define SOAP_TYPE_TaskData_SOAP_ENV__Detail (170)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 170; } /* = unique id SOAP_TYPE_TaskData_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_TaskData_SOAP_ENV__Reason
#define SOAP_TYPE_TaskData_SOAP_ENV__Reason (173)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 173; } /* = unique id SOAP_TYPE_TaskData_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_TaskData_SOAP_ENV__Fault
#define SOAP_TYPE_TaskData_SOAP_ENV__Fault (174)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 174; } /* = unique id SOAP_TYPE_TaskData_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_TaskData__QName
#define SOAP_TYPE_TaskData__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_TaskData__XML
#define SOAP_TYPE_TaskData__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetMapAreaInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetMapAreaInfo *ns4__GetMapAreaInfo, _ns4__GetMapAreaInfoResponse *ns4__GetMapAreaInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPatrolAreaInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetPatrolAreaInfo *ns4__GetPatrolAreaInfo, _ns4__GetPatrolAreaInfoResponse *ns4__GetPatrolAreaInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetMapEdgeInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetMapEdgeInfo *ns4__GetMapEdgeInfo, _ns4__GetMapEdgeInfoResponse *ns4__GetMapEdgeInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetDockPointInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetDockPointInfo *ns4__GetDockPointInfo, _ns4__GetDockPointInfoResponse *ns4__GetDockPointInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetPatrolPointInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetPatrolPointInfo *ns4__GetPatrolPointInfo, _ns4__GetPatrolPointInfoResponse *ns4__GetPatrolPointInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTaskPathInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetTaskPathInfo *ns4__GetTaskPathInfo, _ns4__GetTaskPathInfoResponse *ns4__GetTaskPathInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__StartTaskByPathId(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__StartTaskByPathId *ns4__StartTaskByPathId, _ns4__StartTaskByPathIdResponse *ns4__StartTaskByPathIdResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__StartTaskByPointList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__StartTaskByPointList *ns4__StartTaskByPointList, _ns4__StartTaskByPointListResponse *ns4__StartTaskByPointListResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetTaskPathInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__SetTaskPathInfo *ns4__SetTaskPathInfo, _ns4__SetTaskPathInfoResponse *ns4__SetTaskPathInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__RobotControlTask(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__RobotControlTask *ns4__RobotControlTask, _ns4__RobotControlTaskResponse *ns4__RobotControlTaskResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTaskExcuteData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetTaskExcuteData *ns4__GetTaskExcuteData, _ns4__GetTaskExcuteDataResponse *ns4__GetTaskExcuteDataResponse);

} // namespace TaskData


#endif

/* End of TaskDataStub.h */
