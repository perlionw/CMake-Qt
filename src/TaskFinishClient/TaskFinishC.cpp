/* TaskFinishC.cpp
   Generated by gSOAP 2.8.16 from .\taskfinish.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "TaskFinishH.h"

namespace TaskFinish {

SOAP_SOURCE_STAMP("@(#) TaskFinishC.cpp ver 2.8.16 2020-03-04 06:28:46 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_TaskFinish_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_TaskFinish_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_TaskFinish_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_TaskFinish_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_TaskFinish_ns5__ControlTaskType:
		return soap_in_ns5__ControlTaskType(soap, NULL, NULL, "ns5:ControlTaskType");
	case SOAP_TYPE_TaskFinish_ns5__PdControlType:
		return soap_in_ns5__PdControlType(soap, NULL, NULL, "ns5:PdControlType");
	case SOAP_TYPE_TaskFinish_ns5__LifterControlType:
		return soap_in_ns5__LifterControlType(soap, NULL, NULL, "ns5:LifterControlType");
	case SOAP_TYPE_TaskFinish_ns5__FilrControlType:
		return soap_in_ns5__FilrControlType(soap, NULL, NULL, "ns5:FilrControlType");
	case SOAP_TYPE_TaskFinish_ns5__WiperControlType:
		return soap_in_ns5__WiperControlType(soap, NULL, NULL, "ns5:WiperControlType");
	case SOAP_TYPE_TaskFinish_ns5__LightControlType:
		return soap_in_ns5__LightControlType(soap, NULL, NULL, "ns5:LightControlType");
	case SOAP_TYPE_TaskFinish_ns5__CameraControlType:
		return soap_in_ns5__CameraControlType(soap, NULL, NULL, "ns5:CameraControlType");
	case SOAP_TYPE_TaskFinish_ns5__YuntaiControlType:
		return soap_in_ns5__YuntaiControlType(soap, NULL, NULL, "ns5:YuntaiControlType");
	case SOAP_TYPE_TaskFinish_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos:
		return soap_in_ns5__TaskExcuteInfos(soap, NULL, NULL, "ns5:TaskExcuteInfos");
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo:
		return soap_in_ns5__TaskExcuteInfo(soap, NULL, NULL, "ns5:TaskExcuteInfo");
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos:
		return soap_in_ns5__TaskFinishInfos(soap, NULL, NULL, "ns5:TaskFinishInfos");
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo:
		return soap_in_ns5__TaskFinishInfo(soap, NULL, NULL, "ns5:TaskFinishInfo");
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteData:
		return soap_in_ns5__TaskExcuteData(soap, NULL, NULL, "ns5:TaskExcuteData");
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfos:
		return soap_in_ns5__TaskPathInfos(soap, NULL, NULL, "ns5:TaskPathInfos");
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfo:
		return soap_in_ns5__TaskPathInfo(soap, NULL, NULL, "ns5:TaskPathInfo");
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos:
		return soap_in_ns5__PatrolPointInfos(soap, NULL, NULL, "ns5:PatrolPointInfos");
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo:
		return soap_in_ns5__PatrolPointInfo(soap, NULL, NULL, "ns5:PatrolPointInfo");
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfos:
		return soap_in_ns5__DockPointInfos(soap, NULL, NULL, "ns5:DockPointInfos");
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfo:
		return soap_in_ns5__DockPointInfo(soap, NULL, NULL, "ns5:DockPointInfo");
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos:
		return soap_in_ns5__MapEdgeInfos(soap, NULL, NULL, "ns5:MapEdgeInfos");
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo:
		return soap_in_ns5__MapEdgeInfo(soap, NULL, NULL, "ns5:MapEdgeInfo");
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos:
		return soap_in_ns5__PatrolAreaInfos(soap, NULL, NULL, "ns5:PatrolAreaInfos");
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo:
		return soap_in_ns5__PatrolAreaInfo(soap, NULL, NULL, "ns5:PatrolAreaInfo");
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfos:
		return soap_in_ns5__MapAreaInfos(soap, NULL, NULL, "ns5:MapAreaInfos");
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfo:
		return soap_in_ns5__MapAreaInfo(soap, NULL, NULL, "ns5:MapAreaInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos:
		return soap_in_ns5__RobotAlarmInfos(soap, NULL, NULL, "ns5:RobotAlarmInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo:
		return soap_in_ns5__RobotAlarmInfo(soap, NULL, NULL, "ns5:RobotAlarmInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfos:
		return soap_in_ns5__RobotGasInfos(soap, NULL, NULL, "ns5:RobotGasInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfo:
		return soap_in_ns5__RobotGasInfo(soap, NULL, NULL, "ns5:RobotGasInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos:
		return soap_in_ns5__RobotMileageInfos(soap, NULL, NULL, "ns5:RobotMileageInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo:
		return soap_in_ns5__RobotMileageInfo(soap, NULL, NULL, "ns5:RobotMileageInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos:
		return soap_in_ns5__RobotYunTaiInfos(soap, NULL, NULL, "ns5:RobotYunTaiInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo:
		return soap_in_ns5__RobotYunTaiInfo(soap, NULL, NULL, "ns5:RobotYunTaiInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfos:
		return soap_in_ns5__RobotPosInfos(soap, NULL, NULL, "ns5:RobotPosInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfo:
		return soap_in_ns5__RobotPosInfo(soap, NULL, NULL, "ns5:RobotPosInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskStates:
		return soap_in_ns5__RobotTaskStates(soap, NULL, NULL, "ns5:RobotTaskStates");
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskState:
		return soap_in_ns5__RobotTaskState(soap, NULL, NULL, "ns5:RobotTaskState");
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfos:
		return soap_in_ns5__SpeedInfos(soap, NULL, NULL, "ns5:SpeedInfos");
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfo:
		return soap_in_ns5__SpeedInfo(soap, NULL, NULL, "ns5:SpeedInfo");
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfos:
		return soap_in_ns5__BatteryInfos(soap, NULL, NULL, "ns5:BatteryInfos");
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfo:
		return soap_in_ns5__BatteryInfo(soap, NULL, NULL, "ns5:BatteryInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotInfos:
		return soap_in_ns5__RobotInfos(soap, NULL, NULL, "ns5:RobotInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotInfo:
		return soap_in_ns5__RobotInfo(soap, NULL, NULL, "ns5:RobotInfo");
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfos:
		return soap_in_ns5__ConnectInfos(soap, NULL, NULL, "ns5:ConnectInfos");
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfo:
		return soap_in_ns5__ConnectInfo(soap, NULL, NULL, "ns5:ConnectInfo");
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse:
		return soap_in_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(soap, NULL, NULL, "ns5:GetTaskExcuteInfoByTaskIdResponse");
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskExcuteInfoByTaskId:
		return soap_in_PointerTo_ns5__GetTaskExcuteInfoByTaskId(soap, NULL, NULL, "ns5:GetTaskExcuteInfoByTaskId");
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskFinishInfoByTimeResponse:
		return soap_in_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(soap, NULL, NULL, "ns5:GetTaskFinishInfoByTimeResponse");
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskFinishInfoByTime:
		return soap_in_PointerTo_ns5__GetTaskFinishInfoByTime(soap, NULL, NULL, "ns5:GetTaskFinishInfoByTime");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskExcuteInfos:
		return soap_in_PointerTons5__TaskExcuteInfos(soap, NULL, NULL, "ns5:TaskExcuteInfos");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskFinishInfos:
		return soap_in_PointerTons5__TaskFinishInfos(soap, NULL, NULL, "ns5:TaskFinishInfos");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskExcuteInfo:
		return soap_in_PointerTons5__TaskExcuteInfo(soap, NULL, NULL, "ns5:TaskExcuteInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskFinishInfo:
		return soap_in_PointerTons5__TaskFinishInfo(soap, NULL, NULL, "ns5:TaskFinishInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskPathInfo:
		return soap_in_PointerTons5__TaskPathInfo(soap, NULL, NULL, "ns5:TaskPathInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__PatrolPointInfo:
		return soap_in_PointerTons5__PatrolPointInfo(soap, NULL, NULL, "ns5:PatrolPointInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__DockPointInfo:
		return soap_in_PointerTons5__DockPointInfo(soap, NULL, NULL, "ns5:DockPointInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__MapEdgeInfo:
		return soap_in_PointerTons5__MapEdgeInfo(soap, NULL, NULL, "ns5:MapEdgeInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__PatrolAreaInfo:
		return soap_in_PointerTons5__PatrolAreaInfo(soap, NULL, NULL, "ns5:PatrolAreaInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__MapAreaInfo:
		return soap_in_PointerTons5__MapAreaInfo(soap, NULL, NULL, "ns5:MapAreaInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotAlarmInfo:
		return soap_in_PointerTons5__RobotAlarmInfo(soap, NULL, NULL, "ns5:RobotAlarmInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotGasInfo:
		return soap_in_PointerTons5__RobotGasInfo(soap, NULL, NULL, "ns5:RobotGasInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotMileageInfo:
		return soap_in_PointerTons5__RobotMileageInfo(soap, NULL, NULL, "ns5:RobotMileageInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotYunTaiInfo:
		return soap_in_PointerTons5__RobotYunTaiInfo(soap, NULL, NULL, "ns5:RobotYunTaiInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotPosInfo:
		return soap_in_PointerTons5__RobotPosInfo(soap, NULL, NULL, "ns5:RobotPosInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotTaskState:
		return soap_in_PointerTons5__RobotTaskState(soap, NULL, NULL, "ns5:RobotTaskState");
	case SOAP_TYPE_TaskFinish_PointerTons5__SpeedInfo:
		return soap_in_PointerTons5__SpeedInfo(soap, NULL, NULL, "ns5:SpeedInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__BatteryInfo:
		return soap_in_PointerTons5__BatteryInfo(soap, NULL, NULL, "ns5:BatteryInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotInfo:
		return soap_in_PointerTons5__RobotInfo(soap, NULL, NULL, "ns5:RobotInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__ConnectInfo:
		return soap_in_PointerTons5__ConnectInfo(soap, NULL, NULL, "ns5:ConnectInfo");
	case SOAP_TYPE_TaskFinish__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_TaskFinish_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_TaskFinish_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TaskExcuteInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos;
			return soap_in_ns5__TaskExcuteInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TaskExcuteInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo;
			return soap_in_ns5__TaskExcuteInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TaskFinishInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos;
			return soap_in_ns5__TaskFinishInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TaskFinishInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo;
			return soap_in_ns5__TaskFinishInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TaskExcuteData"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__TaskExcuteData;
			return soap_in_ns5__TaskExcuteData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TaskPathInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__TaskPathInfos;
			return soap_in_ns5__TaskPathInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TaskPathInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__TaskPathInfo;
			return soap_in_ns5__TaskPathInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:PatrolPointInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos;
			return soap_in_ns5__PatrolPointInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:PatrolPointInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo;
			return soap_in_ns5__PatrolPointInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:DockPointInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__DockPointInfos;
			return soap_in_ns5__DockPointInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:DockPointInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__DockPointInfo;
			return soap_in_ns5__DockPointInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:MapEdgeInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos;
			return soap_in_ns5__MapEdgeInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:MapEdgeInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo;
			return soap_in_ns5__MapEdgeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:PatrolAreaInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos;
			return soap_in_ns5__PatrolAreaInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:PatrolAreaInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo;
			return soap_in_ns5__PatrolAreaInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:MapAreaInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__MapAreaInfos;
			return soap_in_ns5__MapAreaInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:MapAreaInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__MapAreaInfo;
			return soap_in_ns5__MapAreaInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotAlarmInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos;
			return soap_in_ns5__RobotAlarmInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotAlarmInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo;
			return soap_in_ns5__RobotAlarmInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotGasInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotGasInfos;
			return soap_in_ns5__RobotGasInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotGasInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotGasInfo;
			return soap_in_ns5__RobotGasInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotMileageInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos;
			return soap_in_ns5__RobotMileageInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotMileageInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo;
			return soap_in_ns5__RobotMileageInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotYunTaiInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos;
			return soap_in_ns5__RobotYunTaiInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotYunTaiInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo;
			return soap_in_ns5__RobotYunTaiInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotPosInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotPosInfos;
			return soap_in_ns5__RobotPosInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotPosInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotPosInfo;
			return soap_in_ns5__RobotPosInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotTaskStates"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotTaskStates;
			return soap_in_ns5__RobotTaskStates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotTaskState"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotTaskState;
			return soap_in_ns5__RobotTaskState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SpeedInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__SpeedInfos;
			return soap_in_ns5__SpeedInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SpeedInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__SpeedInfo;
			return soap_in_ns5__SpeedInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:BatteryInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__BatteryInfos;
			return soap_in_ns5__BatteryInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:BatteryInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__BatteryInfo;
			return soap_in_ns5__BatteryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotInfos;
			return soap_in_ns5__RobotInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RobotInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__RobotInfo;
			return soap_in_ns5__RobotInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ConnectInfos"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__ConnectInfos;
			return soap_in_ns5__ConnectInfos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ConnectInfo"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__ConnectInfo;
			return soap_in_ns5__ConnectInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_TaskFinish_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_TaskFinish_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_TaskFinish_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_TaskFinish_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ControlTaskType"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__ControlTaskType;
			return soap_in_ns5__ControlTaskType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:PdControlType"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__PdControlType;
			return soap_in_ns5__PdControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:LifterControlType"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__LifterControlType;
			return soap_in_ns5__LifterControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:FilrControlType"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__FilrControlType;
			return soap_in_ns5__FilrControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:WiperControlType"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__WiperControlType;
			return soap_in_ns5__WiperControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:LightControlType"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__LightControlType;
			return soap_in_ns5__LightControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:CameraControlType"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__CameraControlType;
			return soap_in_ns5__CameraControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:YuntaiControlType"))
		{	*type = SOAP_TYPE_TaskFinish_ns5__YuntaiControlType;
			return soap_in_ns5__YuntaiControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_TaskFinish__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_TaskFinish_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns5:GetTaskExcuteInfoByTaskIdResponse"))
		{	*type = SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse;
			return soap_in__ns5__GetTaskExcuteInfoByTaskIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetTaskExcuteInfoByTaskId"))
		{	*type = SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId;
			return soap_in__ns5__GetTaskExcuteInfoByTaskId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetTaskFinishInfoByTimeResponse"))
		{	*type = SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse;
			return soap_in__ns5__GetTaskFinishInfoByTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetTaskFinishInfoByTime"))
		{	*type = SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime;
			return soap_in__ns5__GetTaskFinishInfoByTime(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_TaskFinish_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_TaskFinish_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_TaskFinish_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_TaskFinish_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_TaskFinish_ns5__ControlTaskType:
		return soap_out_ns5__ControlTaskType(soap, tag, id, (const enum ns5__ControlTaskType *)ptr, "ns5:ControlTaskType");
	case SOAP_TYPE_TaskFinish_ns5__PdControlType:
		return soap_out_ns5__PdControlType(soap, tag, id, (const enum ns5__PdControlType *)ptr, "ns5:PdControlType");
	case SOAP_TYPE_TaskFinish_ns5__LifterControlType:
		return soap_out_ns5__LifterControlType(soap, tag, id, (const enum ns5__LifterControlType *)ptr, "ns5:LifterControlType");
	case SOAP_TYPE_TaskFinish_ns5__FilrControlType:
		return soap_out_ns5__FilrControlType(soap, tag, id, (const enum ns5__FilrControlType *)ptr, "ns5:FilrControlType");
	case SOAP_TYPE_TaskFinish_ns5__WiperControlType:
		return soap_out_ns5__WiperControlType(soap, tag, id, (const enum ns5__WiperControlType *)ptr, "ns5:WiperControlType");
	case SOAP_TYPE_TaskFinish_ns5__LightControlType:
		return soap_out_ns5__LightControlType(soap, tag, id, (const enum ns5__LightControlType *)ptr, "ns5:LightControlType");
	case SOAP_TYPE_TaskFinish_ns5__CameraControlType:
		return soap_out_ns5__CameraControlType(soap, tag, id, (const enum ns5__CameraControlType *)ptr, "ns5:CameraControlType");
	case SOAP_TYPE_TaskFinish_ns5__YuntaiControlType:
		return soap_out_ns5__YuntaiControlType(soap, tag, id, (const enum ns5__YuntaiControlType *)ptr, "ns5:YuntaiControlType");
	case SOAP_TYPE_TaskFinish_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse:
		return ((_ns5__GetTaskExcuteInfoByTaskIdResponse *)ptr)->soap_out(soap, "ns5:GetTaskExcuteInfoByTaskIdResponse", id, NULL);
	case SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId:
		return ((_ns5__GetTaskExcuteInfoByTaskId *)ptr)->soap_out(soap, "ns5:GetTaskExcuteInfoByTaskId", id, NULL);
	case SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse:
		return ((_ns5__GetTaskFinishInfoByTimeResponse *)ptr)->soap_out(soap, "ns5:GetTaskFinishInfoByTimeResponse", id, NULL);
	case SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime:
		return ((_ns5__GetTaskFinishInfoByTime *)ptr)->soap_out(soap, "ns5:GetTaskFinishInfoByTime", id, NULL);
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos:
		return ((ns5__TaskExcuteInfos *)ptr)->soap_out(soap, tag, id, "ns5:TaskExcuteInfos");
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo:
		return ((ns5__TaskExcuteInfo *)ptr)->soap_out(soap, tag, id, "ns5:TaskExcuteInfo");
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos:
		return ((ns5__TaskFinishInfos *)ptr)->soap_out(soap, tag, id, "ns5:TaskFinishInfos");
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo:
		return ((ns5__TaskFinishInfo *)ptr)->soap_out(soap, tag, id, "ns5:TaskFinishInfo");
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteData:
		return ((ns5__TaskExcuteData *)ptr)->soap_out(soap, tag, id, "ns5:TaskExcuteData");
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfos:
		return ((ns5__TaskPathInfos *)ptr)->soap_out(soap, tag, id, "ns5:TaskPathInfos");
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfo:
		return ((ns5__TaskPathInfo *)ptr)->soap_out(soap, tag, id, "ns5:TaskPathInfo");
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos:
		return ((ns5__PatrolPointInfos *)ptr)->soap_out(soap, tag, id, "ns5:PatrolPointInfos");
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo:
		return ((ns5__PatrolPointInfo *)ptr)->soap_out(soap, tag, id, "ns5:PatrolPointInfo");
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfos:
		return ((ns5__DockPointInfos *)ptr)->soap_out(soap, tag, id, "ns5:DockPointInfos");
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfo:
		return ((ns5__DockPointInfo *)ptr)->soap_out(soap, tag, id, "ns5:DockPointInfo");
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos:
		return ((ns5__MapEdgeInfos *)ptr)->soap_out(soap, tag, id, "ns5:MapEdgeInfos");
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo:
		return ((ns5__MapEdgeInfo *)ptr)->soap_out(soap, tag, id, "ns5:MapEdgeInfo");
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos:
		return ((ns5__PatrolAreaInfos *)ptr)->soap_out(soap, tag, id, "ns5:PatrolAreaInfos");
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo:
		return ((ns5__PatrolAreaInfo *)ptr)->soap_out(soap, tag, id, "ns5:PatrolAreaInfo");
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfos:
		return ((ns5__MapAreaInfos *)ptr)->soap_out(soap, tag, id, "ns5:MapAreaInfos");
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfo:
		return ((ns5__MapAreaInfo *)ptr)->soap_out(soap, tag, id, "ns5:MapAreaInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos:
		return ((ns5__RobotAlarmInfos *)ptr)->soap_out(soap, tag, id, "ns5:RobotAlarmInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo:
		return ((ns5__RobotAlarmInfo *)ptr)->soap_out(soap, tag, id, "ns5:RobotAlarmInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfos:
		return ((ns5__RobotGasInfos *)ptr)->soap_out(soap, tag, id, "ns5:RobotGasInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfo:
		return ((ns5__RobotGasInfo *)ptr)->soap_out(soap, tag, id, "ns5:RobotGasInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos:
		return ((ns5__RobotMileageInfos *)ptr)->soap_out(soap, tag, id, "ns5:RobotMileageInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo:
		return ((ns5__RobotMileageInfo *)ptr)->soap_out(soap, tag, id, "ns5:RobotMileageInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos:
		return ((ns5__RobotYunTaiInfos *)ptr)->soap_out(soap, tag, id, "ns5:RobotYunTaiInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo:
		return ((ns5__RobotYunTaiInfo *)ptr)->soap_out(soap, tag, id, "ns5:RobotYunTaiInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfos:
		return ((ns5__RobotPosInfos *)ptr)->soap_out(soap, tag, id, "ns5:RobotPosInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfo:
		return ((ns5__RobotPosInfo *)ptr)->soap_out(soap, tag, id, "ns5:RobotPosInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskStates:
		return ((ns5__RobotTaskStates *)ptr)->soap_out(soap, tag, id, "ns5:RobotTaskStates");
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskState:
		return ((ns5__RobotTaskState *)ptr)->soap_out(soap, tag, id, "ns5:RobotTaskState");
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfos:
		return ((ns5__SpeedInfos *)ptr)->soap_out(soap, tag, id, "ns5:SpeedInfos");
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfo:
		return ((ns5__SpeedInfo *)ptr)->soap_out(soap, tag, id, "ns5:SpeedInfo");
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfos:
		return ((ns5__BatteryInfos *)ptr)->soap_out(soap, tag, id, "ns5:BatteryInfos");
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfo:
		return ((ns5__BatteryInfo *)ptr)->soap_out(soap, tag, id, "ns5:BatteryInfo");
	case SOAP_TYPE_TaskFinish_ns5__RobotInfos:
		return ((ns5__RobotInfos *)ptr)->soap_out(soap, tag, id, "ns5:RobotInfos");
	case SOAP_TYPE_TaskFinish_ns5__RobotInfo:
		return ((ns5__RobotInfo *)ptr)->soap_out(soap, tag, id, "ns5:RobotInfo");
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfos:
		return ((ns5__ConnectInfos *)ptr)->soap_out(soap, tag, id, "ns5:ConnectInfos");
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfo:
		return ((ns5__ConnectInfo *)ptr)->soap_out(soap, tag, id, "ns5:ConnectInfo");
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse:
		return soap_out_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(soap, tag, id, (_ns5__GetTaskExcuteInfoByTaskIdResponse *const*)ptr, "ns5:GetTaskExcuteInfoByTaskIdResponse");
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskExcuteInfoByTaskId:
		return soap_out_PointerTo_ns5__GetTaskExcuteInfoByTaskId(soap, tag, id, (_ns5__GetTaskExcuteInfoByTaskId *const*)ptr, "ns5:GetTaskExcuteInfoByTaskId");
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskFinishInfoByTimeResponse:
		return soap_out_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(soap, tag, id, (_ns5__GetTaskFinishInfoByTimeResponse *const*)ptr, "ns5:GetTaskFinishInfoByTimeResponse");
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskFinishInfoByTime:
		return soap_out_PointerTo_ns5__GetTaskFinishInfoByTime(soap, tag, id, (_ns5__GetTaskFinishInfoByTime *const*)ptr, "ns5:GetTaskFinishInfoByTime");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskExcuteInfos:
		return soap_out_PointerTons5__TaskExcuteInfos(soap, tag, id, (ns5__TaskExcuteInfos *const*)ptr, "ns5:TaskExcuteInfos");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskFinishInfos:
		return soap_out_PointerTons5__TaskFinishInfos(soap, tag, id, (ns5__TaskFinishInfos *const*)ptr, "ns5:TaskFinishInfos");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskExcuteInfo:
		return soap_out_PointerTons5__TaskExcuteInfo(soap, tag, id, (ns5__TaskExcuteInfo *const*)ptr, "ns5:TaskExcuteInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskFinishInfo:
		return soap_out_PointerTons5__TaskFinishInfo(soap, tag, id, (ns5__TaskFinishInfo *const*)ptr, "ns5:TaskFinishInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskPathInfo:
		return soap_out_PointerTons5__TaskPathInfo(soap, tag, id, (ns5__TaskPathInfo *const*)ptr, "ns5:TaskPathInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__PatrolPointInfo:
		return soap_out_PointerTons5__PatrolPointInfo(soap, tag, id, (ns5__PatrolPointInfo *const*)ptr, "ns5:PatrolPointInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__DockPointInfo:
		return soap_out_PointerTons5__DockPointInfo(soap, tag, id, (ns5__DockPointInfo *const*)ptr, "ns5:DockPointInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__MapEdgeInfo:
		return soap_out_PointerTons5__MapEdgeInfo(soap, tag, id, (ns5__MapEdgeInfo *const*)ptr, "ns5:MapEdgeInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__PatrolAreaInfo:
		return soap_out_PointerTons5__PatrolAreaInfo(soap, tag, id, (ns5__PatrolAreaInfo *const*)ptr, "ns5:PatrolAreaInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__MapAreaInfo:
		return soap_out_PointerTons5__MapAreaInfo(soap, tag, id, (ns5__MapAreaInfo *const*)ptr, "ns5:MapAreaInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotAlarmInfo:
		return soap_out_PointerTons5__RobotAlarmInfo(soap, tag, id, (ns5__RobotAlarmInfo *const*)ptr, "ns5:RobotAlarmInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotGasInfo:
		return soap_out_PointerTons5__RobotGasInfo(soap, tag, id, (ns5__RobotGasInfo *const*)ptr, "ns5:RobotGasInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotMileageInfo:
		return soap_out_PointerTons5__RobotMileageInfo(soap, tag, id, (ns5__RobotMileageInfo *const*)ptr, "ns5:RobotMileageInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotYunTaiInfo:
		return soap_out_PointerTons5__RobotYunTaiInfo(soap, tag, id, (ns5__RobotYunTaiInfo *const*)ptr, "ns5:RobotYunTaiInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotPosInfo:
		return soap_out_PointerTons5__RobotPosInfo(soap, tag, id, (ns5__RobotPosInfo *const*)ptr, "ns5:RobotPosInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotTaskState:
		return soap_out_PointerTons5__RobotTaskState(soap, tag, id, (ns5__RobotTaskState *const*)ptr, "ns5:RobotTaskState");
	case SOAP_TYPE_TaskFinish_PointerTons5__SpeedInfo:
		return soap_out_PointerTons5__SpeedInfo(soap, tag, id, (ns5__SpeedInfo *const*)ptr, "ns5:SpeedInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__BatteryInfo:
		return soap_out_PointerTons5__BatteryInfo(soap, tag, id, (ns5__BatteryInfo *const*)ptr, "ns5:BatteryInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotInfo:
		return soap_out_PointerTons5__RobotInfo(soap, tag, id, (ns5__RobotInfo *const*)ptr, "ns5:RobotInfo");
	case SOAP_TYPE_TaskFinish_PointerTons5__ConnectInfo:
		return soap_out_PointerTons5__ConnectInfo(soap, tag, id, (ns5__ConnectInfo *const*)ptr, "ns5:ConnectInfo");
	case SOAP_TYPE_TaskFinish__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_TaskFinish_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_TaskFinish_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse:
		((_ns5__GetTaskExcuteInfoByTaskIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId:
		((_ns5__GetTaskExcuteInfoByTaskId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse:
		((_ns5__GetTaskFinishInfoByTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime:
		((_ns5__GetTaskFinishInfoByTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos:
		((ns5__TaskExcuteInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo:
		((ns5__TaskExcuteInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos:
		((ns5__TaskFinishInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo:
		((ns5__TaskFinishInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteData:
		((ns5__TaskExcuteData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfos:
		((ns5__TaskPathInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfo:
		((ns5__TaskPathInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos:
		((ns5__PatrolPointInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo:
		((ns5__PatrolPointInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfos:
		((ns5__DockPointInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfo:
		((ns5__DockPointInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos:
		((ns5__MapEdgeInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo:
		((ns5__MapEdgeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos:
		((ns5__PatrolAreaInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo:
		((ns5__PatrolAreaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfos:
		((ns5__MapAreaInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfo:
		((ns5__MapAreaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos:
		((ns5__RobotAlarmInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo:
		((ns5__RobotAlarmInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfos:
		((ns5__RobotGasInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfo:
		((ns5__RobotGasInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos:
		((ns5__RobotMileageInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo:
		((ns5__RobotMileageInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos:
		((ns5__RobotYunTaiInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo:
		((ns5__RobotYunTaiInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfos:
		((ns5__RobotPosInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfo:
		((ns5__RobotPosInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskStates:
		((ns5__RobotTaskStates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskState:
		((ns5__RobotTaskState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfos:
		((ns5__SpeedInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfo:
		((ns5__SpeedInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfos:
		((ns5__BatteryInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfo:
		((ns5__BatteryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotInfos:
		((ns5__RobotInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotInfo:
		((ns5__RobotInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfos:
		((ns5__ConnectInfos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfo:
		((ns5__ConnectInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TaskFinish___ns1__GetTaskExcuteInfoByTaskId:
		soap_serialize___ns1__GetTaskExcuteInfoByTaskId(soap, (const struct __ns1__GetTaskExcuteInfoByTaskId *)ptr);
		break;
	case SOAP_TYPE_TaskFinish___ns1__GetTaskFinishInfoByTime:
		soap_serialize___ns1__GetTaskFinishInfoByTime(soap, (const struct __ns1__GetTaskFinishInfoByTime *)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse:
		soap_serialize_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(soap, (_ns5__GetTaskExcuteInfoByTaskIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskExcuteInfoByTaskId:
		soap_serialize_PointerTo_ns5__GetTaskExcuteInfoByTaskId(soap, (_ns5__GetTaskExcuteInfoByTaskId *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskFinishInfoByTimeResponse:
		soap_serialize_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(soap, (_ns5__GetTaskFinishInfoByTimeResponse *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskFinishInfoByTime:
		soap_serialize_PointerTo_ns5__GetTaskFinishInfoByTime(soap, (_ns5__GetTaskFinishInfoByTime *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskExcuteInfos:
		soap_serialize_PointerTons5__TaskExcuteInfos(soap, (ns5__TaskExcuteInfos *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskFinishInfos:
		soap_serialize_PointerTons5__TaskFinishInfos(soap, (ns5__TaskFinishInfos *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskExcuteInfo:
		soap_serialize_PointerTons5__TaskExcuteInfo(soap, (ns5__TaskExcuteInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskFinishInfo:
		soap_serialize_PointerTons5__TaskFinishInfo(soap, (ns5__TaskFinishInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__TaskPathInfo:
		soap_serialize_PointerTons5__TaskPathInfo(soap, (ns5__TaskPathInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__PatrolPointInfo:
		soap_serialize_PointerTons5__PatrolPointInfo(soap, (ns5__PatrolPointInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__DockPointInfo:
		soap_serialize_PointerTons5__DockPointInfo(soap, (ns5__DockPointInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__MapEdgeInfo:
		soap_serialize_PointerTons5__MapEdgeInfo(soap, (ns5__MapEdgeInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__PatrolAreaInfo:
		soap_serialize_PointerTons5__PatrolAreaInfo(soap, (ns5__PatrolAreaInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__MapAreaInfo:
		soap_serialize_PointerTons5__MapAreaInfo(soap, (ns5__MapAreaInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotAlarmInfo:
		soap_serialize_PointerTons5__RobotAlarmInfo(soap, (ns5__RobotAlarmInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotGasInfo:
		soap_serialize_PointerTons5__RobotGasInfo(soap, (ns5__RobotGasInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotMileageInfo:
		soap_serialize_PointerTons5__RobotMileageInfo(soap, (ns5__RobotMileageInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotYunTaiInfo:
		soap_serialize_PointerTons5__RobotYunTaiInfo(soap, (ns5__RobotYunTaiInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotPosInfo:
		soap_serialize_PointerTons5__RobotPosInfo(soap, (ns5__RobotPosInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotTaskState:
		soap_serialize_PointerTons5__RobotTaskState(soap, (ns5__RobotTaskState *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__SpeedInfo:
		soap_serialize_PointerTons5__SpeedInfo(soap, (ns5__SpeedInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__BatteryInfo:
		soap_serialize_PointerTons5__BatteryInfo(soap, (ns5__BatteryInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__RobotInfo:
		soap_serialize_PointerTons5__RobotInfo(soap, (ns5__RobotInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish_PointerTons5__ConnectInfo:
		soap_serialize_PointerTons5__ConnectInfo(soap, (ns5__ConnectInfo *const*)ptr);
		break;
	case SOAP_TYPE_TaskFinish__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_TaskFinish_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 TaskFinish_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_TaskFinish_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfo:
		return (void*)soap_instantiate_ns5__ConnectInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfos:
		return (void*)soap_instantiate_ns5__ConnectInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotInfo:
		return (void*)soap_instantiate_ns5__RobotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotInfos:
		return (void*)soap_instantiate_ns5__RobotInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfo:
		return (void*)soap_instantiate_ns5__BatteryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfos:
		return (void*)soap_instantiate_ns5__BatteryInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfo:
		return (void*)soap_instantiate_ns5__SpeedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfos:
		return (void*)soap_instantiate_ns5__SpeedInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskState:
		return (void*)soap_instantiate_ns5__RobotTaskState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskStates:
		return (void*)soap_instantiate_ns5__RobotTaskStates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfo:
		return (void*)soap_instantiate_ns5__RobotPosInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfos:
		return (void*)soap_instantiate_ns5__RobotPosInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo:
		return (void*)soap_instantiate_ns5__RobotYunTaiInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos:
		return (void*)soap_instantiate_ns5__RobotYunTaiInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo:
		return (void*)soap_instantiate_ns5__RobotMileageInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos:
		return (void*)soap_instantiate_ns5__RobotMileageInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfo:
		return (void*)soap_instantiate_ns5__RobotGasInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfos:
		return (void*)soap_instantiate_ns5__RobotGasInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo:
		return (void*)soap_instantiate_ns5__RobotAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos:
		return (void*)soap_instantiate_ns5__RobotAlarmInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfo:
		return (void*)soap_instantiate_ns5__MapAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfos:
		return (void*)soap_instantiate_ns5__MapAreaInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo:
		return (void*)soap_instantiate_ns5__PatrolAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos:
		return (void*)soap_instantiate_ns5__PatrolAreaInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo:
		return (void*)soap_instantiate_ns5__MapEdgeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos:
		return (void*)soap_instantiate_ns5__MapEdgeInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfo:
		return (void*)soap_instantiate_ns5__DockPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfos:
		return (void*)soap_instantiate_ns5__DockPointInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo:
		return (void*)soap_instantiate_ns5__PatrolPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos:
		return (void*)soap_instantiate_ns5__PatrolPointInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfo:
		return (void*)soap_instantiate_ns5__TaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfos:
		return (void*)soap_instantiate_ns5__TaskPathInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteData:
		return (void*)soap_instantiate_ns5__TaskExcuteData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo:
		return (void*)soap_instantiate_ns5__TaskFinishInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos:
		return (void*)soap_instantiate_ns5__TaskFinishInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo:
		return (void*)soap_instantiate_ns5__TaskExcuteInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos:
		return (void*)soap_instantiate_ns5__TaskExcuteInfos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime:
		return (void*)soap_instantiate__ns5__GetTaskFinishInfoByTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse:
		return (void*)soap_instantiate__ns5__GetTaskFinishInfoByTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId:
		return (void*)soap_instantiate__ns5__GetTaskExcuteInfoByTaskId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse:
		return (void*)soap_instantiate__ns5__GetTaskExcuteInfoByTaskIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish___ns1__GetTaskFinishInfoByTime:
		return (void*)soap_instantiate___ns1__GetTaskFinishInfoByTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish___ns1__GetTaskExcuteInfoByTaskId:
		return (void*)soap_instantiate___ns1__GetTaskExcuteInfoByTaskId(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskExcuteInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskFinishInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__TaskFinishInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskPathInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__TaskPathInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolPointInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__PatrolPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__DockPointInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__DockPointInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapEdgeInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__MapEdgeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolAreaInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapAreaInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__MapAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotAlarmInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotGasInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RobotGasInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotMileageInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RobotMileageInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotPosInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RobotPosInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotTaskState:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RobotTaskState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__SpeedInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__SpeedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__BatteryInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__BatteryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RobotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__ConnectInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__ConnectInfo(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 TaskFinish_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_TaskFinish_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__ConnectInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ConnectInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__ConnectInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__ConnectInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ConnectInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__BatteryInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__BatteryInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__BatteryInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__BatteryInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__BatteryInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__SpeedInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__SpeedInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__SpeedInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__SpeedInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__SpeedInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskState:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotTaskState*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotTaskState*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotTaskStates:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotTaskStates*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotTaskStates*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotPosInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotPosInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotPosInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotPosInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotPosInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotYunTaiInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotYunTaiInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotYunTaiInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotYunTaiInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotMileageInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotMileageInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotMileageInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotMileageInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotGasInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotGasInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotGasInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotGasInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotGasInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotAlarmInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotAlarmInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__RobotAlarmInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__RobotAlarmInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__MapAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__MapAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__MapAreaInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__MapAreaInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__MapAreaInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__PatrolAreaInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__PatrolAreaInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__PatrolAreaInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__PatrolAreaInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__MapEdgeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__MapEdgeInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__MapEdgeInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__MapEdgeInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__DockPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__DockPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__DockPointInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__DockPointInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__DockPointInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__PatrolPointInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__PatrolPointInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__PatrolPointInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__PatrolPointInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__TaskPathInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__TaskPathInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskPathInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__TaskPathInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__TaskPathInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteData:
		if (p->size < 0)
			SOAP_DELETE((ns5__TaskExcuteData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__TaskExcuteData*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__TaskFinishInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__TaskFinishInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__TaskFinishInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__TaskFinishInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo:
		if (p->size < 0)
			SOAP_DELETE((ns5__TaskExcuteInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__TaskExcuteInfo*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos:
		if (p->size < 0)
			SOAP_DELETE((ns5__TaskExcuteInfos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__TaskExcuteInfos*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime:
		if (p->size < 0)
			SOAP_DELETE((_ns5__GetTaskFinishInfoByTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__GetTaskFinishInfoByTime*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns5__GetTaskFinishInfoByTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__GetTaskFinishInfoByTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId:
		if (p->size < 0)
			SOAP_DELETE((_ns5__GetTaskExcuteInfoByTaskId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__GetTaskExcuteInfoByTaskId*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns5__GetTaskExcuteInfoByTaskIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__GetTaskExcuteInfoByTaskIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish___ns1__GetTaskFinishInfoByTime:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetTaskFinishInfoByTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetTaskFinishInfoByTime*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish___ns1__GetTaskExcuteInfoByTaskId:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetTaskExcuteInfoByTaskId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetTaskExcuteInfoByTaskId*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_TaskFinish_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskExcuteInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__TaskExcuteInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__TaskExcuteInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskFinishInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__TaskFinishInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__TaskFinishInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskPathInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__TaskPathInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__TaskPathInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolPointInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__PatrolPointInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__PatrolPointInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__DockPointInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__DockPointInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__DockPointInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapEdgeInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__MapEdgeInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__MapEdgeInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__PatrolAreaInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__PatrolAreaInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapAreaInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__MapAreaInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__MapAreaInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__RobotAlarmInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__RobotAlarmInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotGasInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__RobotGasInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__RobotGasInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotMileageInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__RobotMileageInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__RobotMileageInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__RobotYunTaiInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__RobotYunTaiInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotPosInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__RobotPosInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__RobotPosInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotTaskState:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__RobotTaskState * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__RobotTaskState * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__SpeedInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__SpeedInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__SpeedInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__BatteryInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__BatteryInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__BatteryInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__RobotInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__RobotInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__ConnectInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__ConnectInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__ConnectInfo * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, TaskFinish_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, TaskFinish_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 TaskFinish_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskExcuteInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__TaskExcuteInfo * >*)p)[len] = *(ns5__TaskExcuteInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskFinishInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__TaskFinishInfo * >*)p)[len] = *(ns5__TaskFinishInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskPathInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__TaskPathInfo * >*)p)[len] = *(ns5__TaskPathInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolPointInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__PatrolPointInfo * >*)p)[len] = *(ns5__PatrolPointInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__DockPointInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__DockPointInfo * >*)p)[len] = *(ns5__DockPointInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapEdgeInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__MapEdgeInfo * >*)p)[len] = *(ns5__MapEdgeInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolAreaInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__PatrolAreaInfo * >*)p)[len] = *(ns5__PatrolAreaInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapAreaInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__MapAreaInfo * >*)p)[len] = *(ns5__MapAreaInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotAlarmInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__RobotAlarmInfo * >*)p)[len] = *(ns5__RobotAlarmInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotGasInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__RobotGasInfo * >*)p)[len] = *(ns5__RobotGasInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotMileageInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__RobotMileageInfo * >*)p)[len] = *(ns5__RobotMileageInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__RobotYunTaiInfo * >*)p)[len] = *(ns5__RobotYunTaiInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotPosInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__RobotPosInfo * >*)p)[len] = *(ns5__RobotPosInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotTaskState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__RobotTaskState * >*)p)[len] = *(ns5__RobotTaskState **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__SpeedInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__SpeedInfo * >*)p)[len] = *(ns5__SpeedInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__BatteryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__BatteryInfo * >*)p)[len] = *(ns5__BatteryInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__RobotInfo * >*)p)[len] = *(ns5__RobotInfo **)q;
		break;
	case SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__ConnectInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container TaskFinish_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__ConnectInfo * >*)p)[len] = *(ns5__ConnectInfo **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_TaskFinish_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_TaskFinish_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_TaskFinish_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_TaskFinish_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_TaskFinish_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_TaskFinish_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__ControlTaskType(struct soap *soap, enum ns5__ControlTaskType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__ControlTaskType
	*a = SOAP_DEFAULT_ns5__ControlTaskType;
#else
	*a = (enum ns5__ControlTaskType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__ControlTaskType[] =
{	{ (long)ns5__ControlTaskType__CancelTask, "CancelTask" },
	{ (long)ns5__ControlTaskType__PauseTask, "PauseTask" },
	{ (long)ns5__ControlTaskType__ResumeTask, "ResumeTask" },
	{ (long)ns5__ControlTaskType__ChargeTask, "ChargeTask" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__ControlTaskType2s(struct soap *soap, enum ns5__ControlTaskType n)
{	const char *s = soap_code_str(soap_codes_ns5__ControlTaskType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ControlTaskType(struct soap *soap, const char *tag, int id, const enum ns5__ControlTaskType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__ControlTaskType), type) || soap_send(soap, soap_ns5__ControlTaskType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__ControlTaskType(struct soap *soap, const char *s, enum ns5__ControlTaskType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__ControlTaskType, s);
	if (map)
		*a = (enum ns5__ControlTaskType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__ControlTaskType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__ControlTaskType * SOAP_FMAC4 soap_in_ns5__ControlTaskType(struct soap *soap, const char *tag, enum ns5__ControlTaskType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__ControlTaskType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__ControlTaskType, sizeof(enum ns5__ControlTaskType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__ControlTaskType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__ControlTaskType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__ControlTaskType, 0, sizeof(enum ns5__ControlTaskType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__ControlTaskType(struct soap *soap, const enum ns5__ControlTaskType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__ControlTaskType);
	if (soap_out_ns5__ControlTaskType(soap, tag?tag:"ns5:ControlTaskType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__ControlTaskType * SOAP_FMAC4 soap_get_ns5__ControlTaskType(struct soap *soap, enum ns5__ControlTaskType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ControlTaskType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__PdControlType(struct soap *soap, enum ns5__PdControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__PdControlType
	*a = SOAP_DEFAULT_ns5__PdControlType;
#else
	*a = (enum ns5__PdControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__PdControlType[] =
{	{ (long)ns5__PdControlType__PdForWard, "PdForWard" },
	{ (long)ns5__PdControlType__PdBackWord, "PdBackWord" },
	{ (long)ns5__PdControlType__PdStop, "PdStop" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__PdControlType2s(struct soap *soap, enum ns5__PdControlType n)
{	const char *s = soap_code_str(soap_codes_ns5__PdControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__PdControlType(struct soap *soap, const char *tag, int id, const enum ns5__PdControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__PdControlType), type) || soap_send(soap, soap_ns5__PdControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__PdControlType(struct soap *soap, const char *s, enum ns5__PdControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__PdControlType, s);
	if (map)
		*a = (enum ns5__PdControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__PdControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__PdControlType * SOAP_FMAC4 soap_in_ns5__PdControlType(struct soap *soap, const char *tag, enum ns5__PdControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__PdControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__PdControlType, sizeof(enum ns5__PdControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__PdControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__PdControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__PdControlType, 0, sizeof(enum ns5__PdControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__PdControlType(struct soap *soap, const enum ns5__PdControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__PdControlType);
	if (soap_out_ns5__PdControlType(soap, tag?tag:"ns5:PdControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__PdControlType * SOAP_FMAC4 soap_get_ns5__PdControlType(struct soap *soap, enum ns5__PdControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__PdControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__LifterControlType(struct soap *soap, enum ns5__LifterControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__LifterControlType
	*a = SOAP_DEFAULT_ns5__LifterControlType;
#else
	*a = (enum ns5__LifterControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__LifterControlType[] =
{	{ (long)ns5__LifterControlType__LifterUp, "LifterUp" },
	{ (long)ns5__LifterControlType__LifterDown, "LifterDown" },
	{ (long)ns5__LifterControlType__LifterStop, "LifterStop" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__LifterControlType2s(struct soap *soap, enum ns5__LifterControlType n)
{	const char *s = soap_code_str(soap_codes_ns5__LifterControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__LifterControlType(struct soap *soap, const char *tag, int id, const enum ns5__LifterControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__LifterControlType), type) || soap_send(soap, soap_ns5__LifterControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__LifterControlType(struct soap *soap, const char *s, enum ns5__LifterControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__LifterControlType, s);
	if (map)
		*a = (enum ns5__LifterControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__LifterControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__LifterControlType * SOAP_FMAC4 soap_in_ns5__LifterControlType(struct soap *soap, const char *tag, enum ns5__LifterControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__LifterControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__LifterControlType, sizeof(enum ns5__LifterControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__LifterControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__LifterControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__LifterControlType, 0, sizeof(enum ns5__LifterControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__LifterControlType(struct soap *soap, const enum ns5__LifterControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__LifterControlType);
	if (soap_out_ns5__LifterControlType(soap, tag?tag:"ns5:LifterControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__LifterControlType * SOAP_FMAC4 soap_get_ns5__LifterControlType(struct soap *soap, enum ns5__LifterControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__LifterControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__FilrControlType(struct soap *soap, enum ns5__FilrControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__FilrControlType
	*a = SOAP_DEFAULT_ns5__FilrControlType;
#else
	*a = (enum ns5__FilrControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__FilrControlType[] =
{	{ (long)ns5__FilrControlType__FocusUp, "FocusUp" },
	{ (long)ns5__FilrControlType__FocusDown, "FocusDown" },
	{ (long)ns5__FilrControlType__AutoFocus, "AutoFocus" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__FilrControlType2s(struct soap *soap, enum ns5__FilrControlType n)
{	const char *s = soap_code_str(soap_codes_ns5__FilrControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__FilrControlType(struct soap *soap, const char *tag, int id, const enum ns5__FilrControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__FilrControlType), type) || soap_send(soap, soap_ns5__FilrControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__FilrControlType(struct soap *soap, const char *s, enum ns5__FilrControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__FilrControlType, s);
	if (map)
		*a = (enum ns5__FilrControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__FilrControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__FilrControlType * SOAP_FMAC4 soap_in_ns5__FilrControlType(struct soap *soap, const char *tag, enum ns5__FilrControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__FilrControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__FilrControlType, sizeof(enum ns5__FilrControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__FilrControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__FilrControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__FilrControlType, 0, sizeof(enum ns5__FilrControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__FilrControlType(struct soap *soap, const enum ns5__FilrControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__FilrControlType);
	if (soap_out_ns5__FilrControlType(soap, tag?tag:"ns5:FilrControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__FilrControlType * SOAP_FMAC4 soap_get_ns5__FilrControlType(struct soap *soap, enum ns5__FilrControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__FilrControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__WiperControlType(struct soap *soap, enum ns5__WiperControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__WiperControlType
	*a = SOAP_DEFAULT_ns5__WiperControlType;
#else
	*a = (enum ns5__WiperControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__WiperControlType[] =
{	{ (long)ns5__WiperControlType__WiperOn, "WiperOn" },
	{ (long)ns5__WiperControlType__WiperOff, "WiperOff" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__WiperControlType2s(struct soap *soap, enum ns5__WiperControlType n)
{	const char *s = soap_code_str(soap_codes_ns5__WiperControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__WiperControlType(struct soap *soap, const char *tag, int id, const enum ns5__WiperControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__WiperControlType), type) || soap_send(soap, soap_ns5__WiperControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__WiperControlType(struct soap *soap, const char *s, enum ns5__WiperControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__WiperControlType, s);
	if (map)
		*a = (enum ns5__WiperControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__WiperControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__WiperControlType * SOAP_FMAC4 soap_in_ns5__WiperControlType(struct soap *soap, const char *tag, enum ns5__WiperControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__WiperControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__WiperControlType, sizeof(enum ns5__WiperControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__WiperControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__WiperControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__WiperControlType, 0, sizeof(enum ns5__WiperControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__WiperControlType(struct soap *soap, const enum ns5__WiperControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__WiperControlType);
	if (soap_out_ns5__WiperControlType(soap, tag?tag:"ns5:WiperControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__WiperControlType * SOAP_FMAC4 soap_get_ns5__WiperControlType(struct soap *soap, enum ns5__WiperControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__WiperControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__LightControlType(struct soap *soap, enum ns5__LightControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__LightControlType
	*a = SOAP_DEFAULT_ns5__LightControlType;
#else
	*a = (enum ns5__LightControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__LightControlType[] =
{	{ (long)ns5__LightControlType__LightOn, "LightOn" },
	{ (long)ns5__LightControlType__LightOff, "LightOff" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__LightControlType2s(struct soap *soap, enum ns5__LightControlType n)
{	const char *s = soap_code_str(soap_codes_ns5__LightControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__LightControlType(struct soap *soap, const char *tag, int id, const enum ns5__LightControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__LightControlType), type) || soap_send(soap, soap_ns5__LightControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__LightControlType(struct soap *soap, const char *s, enum ns5__LightControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__LightControlType, s);
	if (map)
		*a = (enum ns5__LightControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__LightControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__LightControlType * SOAP_FMAC4 soap_in_ns5__LightControlType(struct soap *soap, const char *tag, enum ns5__LightControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__LightControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__LightControlType, sizeof(enum ns5__LightControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__LightControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__LightControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__LightControlType, 0, sizeof(enum ns5__LightControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__LightControlType(struct soap *soap, const enum ns5__LightControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__LightControlType);
	if (soap_out_ns5__LightControlType(soap, tag?tag:"ns5:LightControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__LightControlType * SOAP_FMAC4 soap_get_ns5__LightControlType(struct soap *soap, enum ns5__LightControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__LightControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CameraControlType(struct soap *soap, enum ns5__CameraControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__CameraControlType
	*a = SOAP_DEFAULT_ns5__CameraControlType;
#else
	*a = (enum ns5__CameraControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__CameraControlType[] =
{	{ (long)ns5__CameraControlType__ZoomUp, "ZoomUp" },
	{ (long)ns5__CameraControlType__ZoomUpStop, "ZoomUpStop" },
	{ (long)ns5__CameraControlType__ZoomDown, "ZoomDown" },
	{ (long)ns5__CameraControlType__ZoomDownStop, "ZoomDownStop" },
	{ (long)ns5__CameraControlType__FocusNear, "FocusNear" },
	{ (long)ns5__CameraControlType__FocusNearStop, "FocusNearStop" },
	{ (long)ns5__CameraControlType__FocusFar, "FocusFar" },
	{ (long)ns5__CameraControlType__FocusFarStop, "FocusFarStop" },
	{ (long)ns5__CameraControlType__CameraReset, "CameraReset" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__CameraControlType2s(struct soap *soap, enum ns5__CameraControlType n)
{	const char *s = soap_code_str(soap_codes_ns5__CameraControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CameraControlType(struct soap *soap, const char *tag, int id, const enum ns5__CameraControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__CameraControlType), type) || soap_send(soap, soap_ns5__CameraControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__CameraControlType(struct soap *soap, const char *s, enum ns5__CameraControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__CameraControlType, s);
	if (map)
		*a = (enum ns5__CameraControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__CameraControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__CameraControlType * SOAP_FMAC4 soap_in_ns5__CameraControlType(struct soap *soap, const char *tag, enum ns5__CameraControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__CameraControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__CameraControlType, sizeof(enum ns5__CameraControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__CameraControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__CameraControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__CameraControlType, 0, sizeof(enum ns5__CameraControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CameraControlType(struct soap *soap, const enum ns5__CameraControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__CameraControlType);
	if (soap_out_ns5__CameraControlType(soap, tag?tag:"ns5:CameraControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__CameraControlType * SOAP_FMAC4 soap_get_ns5__CameraControlType(struct soap *soap, enum ns5__CameraControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__CameraControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__YuntaiControlType(struct soap *soap, enum ns5__YuntaiControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__YuntaiControlType
	*a = SOAP_DEFAULT_ns5__YuntaiControlType;
#else
	*a = (enum ns5__YuntaiControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__YuntaiControlType[] =
{	{ (long)ns5__YuntaiControlType__TurnUp, "TurnUp" },
	{ (long)ns5__YuntaiControlType__TurnDown, "TurnDown" },
	{ (long)ns5__YuntaiControlType__TurnLeft, "TurnLeft" },
	{ (long)ns5__YuntaiControlType__TurnRight, "TurnRight" },
	{ (long)ns5__YuntaiControlType__TurnStop, "TurnStop" },
	{ (long)ns5__YuntaiControlType__TurnReset, "TurnReset" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__YuntaiControlType2s(struct soap *soap, enum ns5__YuntaiControlType n)
{	const char *s = soap_code_str(soap_codes_ns5__YuntaiControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__YuntaiControlType(struct soap *soap, const char *tag, int id, const enum ns5__YuntaiControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__YuntaiControlType), type) || soap_send(soap, soap_ns5__YuntaiControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__YuntaiControlType(struct soap *soap, const char *s, enum ns5__YuntaiControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__YuntaiControlType, s);
	if (map)
		*a = (enum ns5__YuntaiControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__YuntaiControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__YuntaiControlType * SOAP_FMAC4 soap_in_ns5__YuntaiControlType(struct soap *soap, const char *tag, enum ns5__YuntaiControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__YuntaiControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__YuntaiControlType, sizeof(enum ns5__YuntaiControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__YuntaiControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__YuntaiControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__YuntaiControlType, 0, sizeof(enum ns5__YuntaiControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__YuntaiControlType(struct soap *soap, const enum ns5__YuntaiControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__YuntaiControlType);
	if (soap_out_ns5__YuntaiControlType(soap, tag?tag:"ns5:YuntaiControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__YuntaiControlType * SOAP_FMAC4 soap_get_ns5__YuntaiControlType(struct soap *soap, enum ns5__YuntaiControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__YuntaiControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_TaskFinish_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_TaskFinish_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_TaskFinish_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_TaskFinish_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__string, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns5__GetTaskExcuteInfoByTaskIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__GetTaskExcuteInfoByTaskIdResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns5__GetTaskExcuteInfoByTaskIdResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__TaskExcuteInfos(soap, &this->_ns5__GetTaskExcuteInfoByTaskIdResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns5__GetTaskExcuteInfoByTaskIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetTaskExcuteInfoByTaskIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, const char *tag, int id, const _ns5__GetTaskExcuteInfoByTaskIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse), type))
		return soap->error;
	if (a->_ns5__GetTaskExcuteInfoByTaskIdResponse::Data)
	{	if (soap_out_PointerTons5__TaskExcuteInfos(soap, "Data", -1, &a->_ns5__GetTaskExcuteInfoByTaskIdResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetTaskExcuteInfoByTaskIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetTaskExcuteInfoByTaskIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetTaskExcuteInfoByTaskIdResponse * SOAP_FMAC4 soap_in__ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, const char *tag, _ns5__GetTaskExcuteInfoByTaskIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetTaskExcuteInfoByTaskIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse, sizeof(_ns5__GetTaskExcuteInfoByTaskIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__GetTaskExcuteInfoByTaskIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__TaskExcuteInfos(soap, "Data", &(a->_ns5__GetTaskExcuteInfoByTaskIdResponse::Data), "ns5:TaskExcuteInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetTaskExcuteInfoByTaskIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse, 0, sizeof(_ns5__GetTaskExcuteInfoByTaskIdResponse), 0, soap_copy__ns5__GetTaskExcuteInfoByTaskIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns5__GetTaskExcuteInfoByTaskIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse);
	if (this->soap_out(soap, tag?tag:"ns5:GetTaskExcuteInfoByTaskIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetTaskExcuteInfoByTaskIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetTaskExcuteInfoByTaskIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetTaskExcuteInfoByTaskIdResponse * SOAP_FMAC4 soap_get__ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, _ns5__GetTaskExcuteInfoByTaskIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetTaskExcuteInfoByTaskIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__GetTaskExcuteInfoByTaskIdResponse * SOAP_FMAC2 soap_instantiate__ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetTaskExcuteInfoByTaskIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__GetTaskExcuteInfoByTaskIdResponse);
		if (size)
			*size = sizeof(_ns5__GetTaskExcuteInfoByTaskIdResponse);
		((_ns5__GetTaskExcuteInfoByTaskIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__GetTaskExcuteInfoByTaskIdResponse, n);
		if (size)
			*size = n * sizeof(_ns5__GetTaskExcuteInfoByTaskIdResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__GetTaskExcuteInfoByTaskIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__GetTaskExcuteInfoByTaskIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__GetTaskExcuteInfoByTaskIdResponse %p -> %p\n", q, p));
	*(_ns5__GetTaskExcuteInfoByTaskIdResponse*)p = *(_ns5__GetTaskExcuteInfoByTaskIdResponse*)q;
}

void _ns5__GetTaskExcuteInfoByTaskId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns5__GetTaskExcuteInfoByTaskId::TaskId);
	/* transient soap skipped */
}

void _ns5__GetTaskExcuteInfoByTaskId::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns5__GetTaskExcuteInfoByTaskId::TaskId);
	/* transient soap skipped */
#endif
}

int _ns5__GetTaskExcuteInfoByTaskId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetTaskExcuteInfoByTaskId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, const char *tag, int id, const _ns5__GetTaskExcuteInfoByTaskId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->_ns5__GetTaskExcuteInfoByTaskId::TaskId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetTaskExcuteInfoByTaskId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetTaskExcuteInfoByTaskId(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetTaskExcuteInfoByTaskId * SOAP_FMAC4 soap_in__ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, const char *tag, _ns5__GetTaskExcuteInfoByTaskId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetTaskExcuteInfoByTaskId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId, sizeof(_ns5__GetTaskExcuteInfoByTaskId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__GetTaskExcuteInfoByTaskId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->_ns5__GetTaskExcuteInfoByTaskId::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetTaskExcuteInfoByTaskId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId, 0, sizeof(_ns5__GetTaskExcuteInfoByTaskId), 0, soap_copy__ns5__GetTaskExcuteInfoByTaskId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns5__GetTaskExcuteInfoByTaskId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId);
	if (this->soap_out(soap, tag?tag:"ns5:GetTaskExcuteInfoByTaskId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetTaskExcuteInfoByTaskId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetTaskExcuteInfoByTaskId(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetTaskExcuteInfoByTaskId * SOAP_FMAC4 soap_get__ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, _ns5__GetTaskExcuteInfoByTaskId *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetTaskExcuteInfoByTaskId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__GetTaskExcuteInfoByTaskId * SOAP_FMAC2 soap_instantiate__ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetTaskExcuteInfoByTaskId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__GetTaskExcuteInfoByTaskId);
		if (size)
			*size = sizeof(_ns5__GetTaskExcuteInfoByTaskId);
		((_ns5__GetTaskExcuteInfoByTaskId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__GetTaskExcuteInfoByTaskId, n);
		if (size)
			*size = n * sizeof(_ns5__GetTaskExcuteInfoByTaskId);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__GetTaskExcuteInfoByTaskId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__GetTaskExcuteInfoByTaskId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__GetTaskExcuteInfoByTaskId %p -> %p\n", q, p));
	*(_ns5__GetTaskExcuteInfoByTaskId*)p = *(_ns5__GetTaskExcuteInfoByTaskId*)q;
}

void _ns5__GetTaskFinishInfoByTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__GetTaskFinishInfoByTimeResponse::Data = NULL;
	/* transient soap skipped */
}

void _ns5__GetTaskFinishInfoByTimeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__TaskFinishInfos(soap, &this->_ns5__GetTaskFinishInfoByTimeResponse::Data);
	/* transient soap skipped */
#endif
}

int _ns5__GetTaskFinishInfoByTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetTaskFinishInfoByTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, const char *tag, int id, const _ns5__GetTaskFinishInfoByTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse), type))
		return soap->error;
	if (a->_ns5__GetTaskFinishInfoByTimeResponse::Data)
	{	if (soap_out_PointerTons5__TaskFinishInfos(soap, "Data", -1, &a->_ns5__GetTaskFinishInfoByTimeResponse::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetTaskFinishInfoByTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetTaskFinishInfoByTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetTaskFinishInfoByTimeResponse * SOAP_FMAC4 soap_in__ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, const char *tag, _ns5__GetTaskFinishInfoByTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetTaskFinishInfoByTimeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse, sizeof(_ns5__GetTaskFinishInfoByTimeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__GetTaskFinishInfoByTimeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__TaskFinishInfos(soap, "Data", &(a->_ns5__GetTaskFinishInfoByTimeResponse::Data), "ns5:TaskFinishInfos"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetTaskFinishInfoByTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse, 0, sizeof(_ns5__GetTaskFinishInfoByTimeResponse), 0, soap_copy__ns5__GetTaskFinishInfoByTimeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns5__GetTaskFinishInfoByTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse);
	if (this->soap_out(soap, tag?tag:"ns5:GetTaskFinishInfoByTimeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetTaskFinishInfoByTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetTaskFinishInfoByTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetTaskFinishInfoByTimeResponse * SOAP_FMAC4 soap_get__ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, _ns5__GetTaskFinishInfoByTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetTaskFinishInfoByTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__GetTaskFinishInfoByTimeResponse * SOAP_FMAC2 soap_instantiate__ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetTaskFinishInfoByTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__GetTaskFinishInfoByTimeResponse);
		if (size)
			*size = sizeof(_ns5__GetTaskFinishInfoByTimeResponse);
		((_ns5__GetTaskFinishInfoByTimeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__GetTaskFinishInfoByTimeResponse, n);
		if (size)
			*size = n * sizeof(_ns5__GetTaskFinishInfoByTimeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__GetTaskFinishInfoByTimeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__GetTaskFinishInfoByTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__GetTaskFinishInfoByTimeResponse %p -> %p\n", q, p));
	*(_ns5__GetTaskFinishInfoByTimeResponse*)p = *(_ns5__GetTaskFinishInfoByTimeResponse*)q;
}

void _ns5__GetTaskFinishInfoByTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns5__GetTaskFinishInfoByTime::StartTime);
	soap_default_std__string(soap, &this->_ns5__GetTaskFinishInfoByTime::EndTime);
	/* transient soap skipped */
}

void _ns5__GetTaskFinishInfoByTime::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_ns5__GetTaskFinishInfoByTime::StartTime);
	soap_serialize_std__string(soap, &this->_ns5__GetTaskFinishInfoByTime::EndTime);
	/* transient soap skipped */
#endif
}

int _ns5__GetTaskFinishInfoByTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetTaskFinishInfoByTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetTaskFinishInfoByTime(struct soap *soap, const char *tag, int id, const _ns5__GetTaskFinishInfoByTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime), type))
		return soap->error;
	if (soap_out_std__string(soap, "StartTime", -1, &(a->_ns5__GetTaskFinishInfoByTime::StartTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndTime", -1, &(a->_ns5__GetTaskFinishInfoByTime::EndTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetTaskFinishInfoByTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetTaskFinishInfoByTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetTaskFinishInfoByTime * SOAP_FMAC4 soap_in__ns5__GetTaskFinishInfoByTime(struct soap *soap, const char *tag, _ns5__GetTaskFinishInfoByTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetTaskFinishInfoByTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime, sizeof(_ns5__GetTaskFinishInfoByTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__GetTaskFinishInfoByTime *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StartTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartTime", &(a->_ns5__GetTaskFinishInfoByTime::StartTime), "xsd:string"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag_EndTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndTime", &(a->_ns5__GetTaskFinishInfoByTime::EndTime), "xsd:string"))
				{	soap_flag_EndTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetTaskFinishInfoByTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime, 0, sizeof(_ns5__GetTaskFinishInfoByTime), 0, soap_copy__ns5__GetTaskFinishInfoByTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime1 > 0 || soap_flag_EndTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns5__GetTaskFinishInfoByTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime);
	if (this->soap_out(soap, tag?tag:"ns5:GetTaskFinishInfoByTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetTaskFinishInfoByTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetTaskFinishInfoByTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetTaskFinishInfoByTime * SOAP_FMAC4 soap_get__ns5__GetTaskFinishInfoByTime(struct soap *soap, _ns5__GetTaskFinishInfoByTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetTaskFinishInfoByTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__GetTaskFinishInfoByTime * SOAP_FMAC2 soap_instantiate__ns5__GetTaskFinishInfoByTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetTaskFinishInfoByTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__GetTaskFinishInfoByTime);
		if (size)
			*size = sizeof(_ns5__GetTaskFinishInfoByTime);
		((_ns5__GetTaskFinishInfoByTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__GetTaskFinishInfoByTime, n);
		if (size)
			*size = n * sizeof(_ns5__GetTaskFinishInfoByTime);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__GetTaskFinishInfoByTime*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__GetTaskFinishInfoByTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__GetTaskFinishInfoByTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__GetTaskFinishInfoByTime %p -> %p\n", q, p));
	*(_ns5__GetTaskFinishInfoByTime*)p = *(_ns5__GetTaskFinishInfoByTime*)q;
}

void ns5__TaskExcuteInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(soap, &this->ns5__TaskExcuteInfos::Infos);
	/* transient soap skipped */
}

void ns5__TaskExcuteInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(soap, &this->ns5__TaskExcuteInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__TaskExcuteInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TaskExcuteInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TaskExcuteInfos(struct soap *soap, const char *tag, int id, const ns5__TaskExcuteInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(soap, "Infos", -1, &(a->ns5__TaskExcuteInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__TaskExcuteInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TaskExcuteInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TaskExcuteInfos * SOAP_FMAC4 soap_in_ns5__TaskExcuteInfos(struct soap *soap, const char *tag, ns5__TaskExcuteInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TaskExcuteInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos, sizeof(ns5__TaskExcuteInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TaskExcuteInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(soap, "Infos", &(a->ns5__TaskExcuteInfos::Infos), "ns5:TaskExcuteInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TaskExcuteInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos, 0, sizeof(ns5__TaskExcuteInfos), 0, soap_copy_ns5__TaskExcuteInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__TaskExcuteInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos);
	if (this->soap_out(soap, tag?tag:"ns5:TaskExcuteInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TaskExcuteInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TaskExcuteInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TaskExcuteInfos * SOAP_FMAC4 soap_get_ns5__TaskExcuteInfos(struct soap *soap, ns5__TaskExcuteInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TaskExcuteInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__TaskExcuteInfos * SOAP_FMAC2 soap_instantiate_ns5__TaskExcuteInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TaskExcuteInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__TaskExcuteInfos);
		if (size)
			*size = sizeof(ns5__TaskExcuteInfos);
		((ns5__TaskExcuteInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__TaskExcuteInfos, n);
		if (size)
			*size = n * sizeof(ns5__TaskExcuteInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__TaskExcuteInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__TaskExcuteInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TaskExcuteInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TaskExcuteInfos %p -> %p\n", q, p));
	*(ns5__TaskExcuteInfos*)p = *(ns5__TaskExcuteInfos*)q;
}

void ns5__TaskExcuteInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::TaskId);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::TaskName);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::TaskType);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::TaskPathId);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::TargetId);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::PointId);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::PointName);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::PointType);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteTime);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteValue);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteUnit);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteState);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteDesc);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::HDPicture);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::InfraredPicture);
	soap_default_std__string(soap, &this->ns5__TaskExcuteInfo::OtherFile);
	/* transient soap skipped */
}

void ns5__TaskExcuteInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::TaskId);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::TaskName);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::TaskType);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::TaskPathId);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::TargetId);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::PointId);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::PointName);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::PointType);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteTime);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteValue);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteUnit);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteState);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::ExcuteDesc);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::HDPicture);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::InfraredPicture);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteInfo::OtherFile);
	/* transient soap skipped */
#endif
}

int ns5__TaskExcuteInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TaskExcuteInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TaskExcuteInfo(struct soap *soap, const char *tag, int id, const ns5__TaskExcuteInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns5__TaskExcuteInfo::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns5__TaskExcuteInfo::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns5__TaskExcuteInfo::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns5__TaskExcuteInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TargetId", -1, &(a->ns5__TaskExcuteInfo::TargetId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointId", -1, &(a->ns5__TaskExcuteInfo::PointId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointName", -1, &(a->ns5__TaskExcuteInfo::PointName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointType", -1, &(a->ns5__TaskExcuteInfo::PointType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteTime", -1, &(a->ns5__TaskExcuteInfo::ExcuteTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteValue", -1, &(a->ns5__TaskExcuteInfo::ExcuteValue), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteUnit", -1, &(a->ns5__TaskExcuteInfo::ExcuteUnit), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteState", -1, &(a->ns5__TaskExcuteInfo::ExcuteState), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteDesc", -1, &(a->ns5__TaskExcuteInfo::ExcuteDesc), ""))
		return soap->error;
	if (soap_out_std__string(soap, "HDPicture", -1, &(a->ns5__TaskExcuteInfo::HDPicture), ""))
		return soap->error;
	if (soap_out_std__string(soap, "InfraredPicture", -1, &(a->ns5__TaskExcuteInfo::InfraredPicture), ""))
		return soap->error;
	if (soap_out_std__string(soap, "OtherFile", -1, &(a->ns5__TaskExcuteInfo::OtherFile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__TaskExcuteInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TaskExcuteInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TaskExcuteInfo * SOAP_FMAC4 soap_in_ns5__TaskExcuteInfo(struct soap *soap, const char *tag, ns5__TaskExcuteInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TaskExcuteInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo, sizeof(ns5__TaskExcuteInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TaskExcuteInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_TargetId1 = 1;
	size_t soap_flag_PointId1 = 1;
	size_t soap_flag_PointName1 = 1;
	size_t soap_flag_PointType1 = 1;
	size_t soap_flag_ExcuteTime1 = 1;
	size_t soap_flag_ExcuteValue1 = 1;
	size_t soap_flag_ExcuteUnit1 = 1;
	size_t soap_flag_ExcuteState1 = 1;
	size_t soap_flag_ExcuteDesc1 = 1;
	size_t soap_flag_HDPicture1 = 1;
	size_t soap_flag_InfraredPicture1 = 1;
	size_t soap_flag_OtherFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns5__TaskExcuteInfo::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns5__TaskExcuteInfo::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns5__TaskExcuteInfo::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns5__TaskExcuteInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap_flag_TargetId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TargetId", &(a->ns5__TaskExcuteInfo::TargetId), "xsd:string"))
				{	soap_flag_TargetId1--;
					continue;
				}
			if (soap_flag_PointId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointId", &(a->ns5__TaskExcuteInfo::PointId), "xsd:string"))
				{	soap_flag_PointId1--;
					continue;
				}
			if (soap_flag_PointName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointName", &(a->ns5__TaskExcuteInfo::PointName), "xsd:string"))
				{	soap_flag_PointName1--;
					continue;
				}
			if (soap_flag_PointType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointType", &(a->ns5__TaskExcuteInfo::PointType), "xsd:string"))
				{	soap_flag_PointType1--;
					continue;
				}
			if (soap_flag_ExcuteTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteTime", &(a->ns5__TaskExcuteInfo::ExcuteTime), "xsd:string"))
				{	soap_flag_ExcuteTime1--;
					continue;
				}
			if (soap_flag_ExcuteValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteValue", &(a->ns5__TaskExcuteInfo::ExcuteValue), "xsd:string"))
				{	soap_flag_ExcuteValue1--;
					continue;
				}
			if (soap_flag_ExcuteUnit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteUnit", &(a->ns5__TaskExcuteInfo::ExcuteUnit), "xsd:string"))
				{	soap_flag_ExcuteUnit1--;
					continue;
				}
			if (soap_flag_ExcuteState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteState", &(a->ns5__TaskExcuteInfo::ExcuteState), "xsd:string"))
				{	soap_flag_ExcuteState1--;
					continue;
				}
			if (soap_flag_ExcuteDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteDesc", &(a->ns5__TaskExcuteInfo::ExcuteDesc), "xsd:string"))
				{	soap_flag_ExcuteDesc1--;
					continue;
				}
			if (soap_flag_HDPicture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HDPicture", &(a->ns5__TaskExcuteInfo::HDPicture), "xsd:string"))
				{	soap_flag_HDPicture1--;
					continue;
				}
			if (soap_flag_InfraredPicture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "InfraredPicture", &(a->ns5__TaskExcuteInfo::InfraredPicture), "xsd:string"))
				{	soap_flag_InfraredPicture1--;
					continue;
				}
			if (soap_flag_OtherFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "OtherFile", &(a->ns5__TaskExcuteInfo::OtherFile), "xsd:string"))
				{	soap_flag_OtherFile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TaskExcuteInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo, 0, sizeof(ns5__TaskExcuteInfo), 0, soap_copy_ns5__TaskExcuteInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskPathId1 > 0 || soap_flag_TargetId1 > 0 || soap_flag_PointId1 > 0 || soap_flag_PointName1 > 0 || soap_flag_PointType1 > 0 || soap_flag_ExcuteTime1 > 0 || soap_flag_ExcuteValue1 > 0 || soap_flag_ExcuteUnit1 > 0 || soap_flag_ExcuteState1 > 0 || soap_flag_ExcuteDesc1 > 0 || soap_flag_HDPicture1 > 0 || soap_flag_InfraredPicture1 > 0 || soap_flag_OtherFile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__TaskExcuteInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo);
	if (this->soap_out(soap, tag?tag:"ns5:TaskExcuteInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TaskExcuteInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TaskExcuteInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TaskExcuteInfo * SOAP_FMAC4 soap_get_ns5__TaskExcuteInfo(struct soap *soap, ns5__TaskExcuteInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TaskExcuteInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__TaskExcuteInfo * SOAP_FMAC2 soap_instantiate_ns5__TaskExcuteInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TaskExcuteInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__TaskExcuteInfo);
		if (size)
			*size = sizeof(ns5__TaskExcuteInfo);
		((ns5__TaskExcuteInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__TaskExcuteInfo, n);
		if (size)
			*size = n * sizeof(ns5__TaskExcuteInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__TaskExcuteInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__TaskExcuteInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TaskExcuteInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TaskExcuteInfo %p -> %p\n", q, p));
	*(ns5__TaskExcuteInfo*)p = *(ns5__TaskExcuteInfo*)q;
}

void ns5__TaskFinishInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__TaskFinishInfo(soap, &this->ns5__TaskFinishInfos::Infos);
	/* transient soap skipped */
}

void ns5__TaskFinishInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__TaskFinishInfo(soap, &this->ns5__TaskFinishInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__TaskFinishInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TaskFinishInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TaskFinishInfos(struct soap *soap, const char *tag, int id, const ns5__TaskFinishInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__TaskFinishInfo(soap, "Infos", -1, &(a->ns5__TaskFinishInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__TaskFinishInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TaskFinishInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TaskFinishInfos * SOAP_FMAC4 soap_in_ns5__TaskFinishInfos(struct soap *soap, const char *tag, ns5__TaskFinishInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TaskFinishInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos, sizeof(ns5__TaskFinishInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TaskFinishInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__TaskFinishInfo(soap, "Infos", &(a->ns5__TaskFinishInfos::Infos), "ns5:TaskFinishInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TaskFinishInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos, 0, sizeof(ns5__TaskFinishInfos), 0, soap_copy_ns5__TaskFinishInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__TaskFinishInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos);
	if (this->soap_out(soap, tag?tag:"ns5:TaskFinishInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TaskFinishInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TaskFinishInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TaskFinishInfos * SOAP_FMAC4 soap_get_ns5__TaskFinishInfos(struct soap *soap, ns5__TaskFinishInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TaskFinishInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__TaskFinishInfos * SOAP_FMAC2 soap_instantiate_ns5__TaskFinishInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TaskFinishInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__TaskFinishInfos);
		if (size)
			*size = sizeof(ns5__TaskFinishInfos);
		((ns5__TaskFinishInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__TaskFinishInfos, n);
		if (size)
			*size = n * sizeof(ns5__TaskFinishInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__TaskFinishInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__TaskFinishInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TaskFinishInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TaskFinishInfos %p -> %p\n", q, p));
	*(ns5__TaskFinishInfos*)p = *(ns5__TaskFinishInfos*)q;
}

void ns5__TaskFinishInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__TaskFinishInfo::TaskId);
	soap_default_std__string(soap, &this->ns5__TaskFinishInfo::TaskName);
	soap_default_std__string(soap, &this->ns5__TaskFinishInfo::TaskType);
	soap_default_std__string(soap, &this->ns5__TaskFinishInfo::TaskPathId);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns5__TaskFinishInfo::PointList);
	soap_default_std__string(soap, &this->ns5__TaskFinishInfo::StartTime);
	soap_default_std__string(soap, &this->ns5__TaskFinishInfo::EndTime);
	soap_default_std__string(soap, &this->ns5__TaskFinishInfo::FinishState);
	soap_default_std__string(soap, &this->ns5__TaskFinishInfo::ExcuteRobot);
	/* transient soap skipped */
}

void ns5__TaskFinishInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__TaskFinishInfo::TaskId);
	soap_serialize_std__string(soap, &this->ns5__TaskFinishInfo::TaskName);
	soap_serialize_std__string(soap, &this->ns5__TaskFinishInfo::TaskType);
	soap_serialize_std__string(soap, &this->ns5__TaskFinishInfo::TaskPathId);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns5__TaskFinishInfo::PointList);
	soap_serialize_std__string(soap, &this->ns5__TaskFinishInfo::StartTime);
	soap_serialize_std__string(soap, &this->ns5__TaskFinishInfo::EndTime);
	soap_serialize_std__string(soap, &this->ns5__TaskFinishInfo::FinishState);
	soap_serialize_std__string(soap, &this->ns5__TaskFinishInfo::ExcuteRobot);
	/* transient soap skipped */
#endif
}

int ns5__TaskFinishInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TaskFinishInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TaskFinishInfo(struct soap *soap, const char *tag, int id, const ns5__TaskFinishInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns5__TaskFinishInfo::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns5__TaskFinishInfo::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns5__TaskFinishInfo::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns5__TaskFinishInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns5__TaskFinishInfo::PointList), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartTime", -1, &(a->ns5__TaskFinishInfo::StartTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndTime", -1, &(a->ns5__TaskFinishInfo::EndTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FinishState", -1, &(a->ns5__TaskFinishInfo::FinishState), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ExcuteRobot", -1, &(a->ns5__TaskFinishInfo::ExcuteRobot), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__TaskFinishInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TaskFinishInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TaskFinishInfo * SOAP_FMAC4 soap_in_ns5__TaskFinishInfo(struct soap *soap, const char *tag, ns5__TaskFinishInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TaskFinishInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo, sizeof(ns5__TaskFinishInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TaskFinishInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_StartTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	size_t soap_flag_FinishState1 = 1;
	size_t soap_flag_ExcuteRobot1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns5__TaskFinishInfo::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns5__TaskFinishInfo::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns5__TaskFinishInfo::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns5__TaskFinishInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns5__TaskFinishInfo::PointList), "xsd:string"))
					continue;
			if (soap_flag_StartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartTime", &(a->ns5__TaskFinishInfo::StartTime), "xsd:string"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag_EndTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndTime", &(a->ns5__TaskFinishInfo::EndTime), "xsd:string"))
				{	soap_flag_EndTime1--;
					continue;
				}
			if (soap_flag_FinishState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FinishState", &(a->ns5__TaskFinishInfo::FinishState), "xsd:string"))
				{	soap_flag_FinishState1--;
					continue;
				}
			if (soap_flag_ExcuteRobot1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ExcuteRobot", &(a->ns5__TaskFinishInfo::ExcuteRobot), "xsd:string"))
				{	soap_flag_ExcuteRobot1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TaskFinishInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo, 0, sizeof(ns5__TaskFinishInfo), 0, soap_copy_ns5__TaskFinishInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskPathId1 > 0 || soap_flag_StartTime1 > 0 || soap_flag_EndTime1 > 0 || soap_flag_FinishState1 > 0 || soap_flag_ExcuteRobot1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__TaskFinishInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo);
	if (this->soap_out(soap, tag?tag:"ns5:TaskFinishInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TaskFinishInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TaskFinishInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TaskFinishInfo * SOAP_FMAC4 soap_get_ns5__TaskFinishInfo(struct soap *soap, ns5__TaskFinishInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TaskFinishInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__TaskFinishInfo * SOAP_FMAC2 soap_instantiate_ns5__TaskFinishInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TaskFinishInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__TaskFinishInfo);
		if (size)
			*size = sizeof(ns5__TaskFinishInfo);
		((ns5__TaskFinishInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__TaskFinishInfo, n);
		if (size)
			*size = n * sizeof(ns5__TaskFinishInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__TaskFinishInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__TaskFinishInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TaskFinishInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TaskFinishInfo %p -> %p\n", q, p));
	*(ns5__TaskFinishInfo*)p = *(ns5__TaskFinishInfo*)q;
}

void ns5__TaskExcuteData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__TaskExcuteData::RobotIp);
	soap_default_std__string(soap, &this->ns5__TaskExcuteData::TaskType);
	soap_default_std__string(soap, &this->ns5__TaskExcuteData::TaskId);
	soap_default_std__string(soap, &this->ns5__TaskExcuteData::TaskName);
	soap_default_std__string(soap, &this->ns5__TaskExcuteData::PatrolDeviceName);
	soap_default_std__string(soap, &this->ns5__TaskExcuteData::PatrolDeviceId);
	soap_default_int(soap, &this->ns5__TaskExcuteData::TotalDeviceSize);
	soap_default_int(soap, &this->ns5__TaskExcuteData::ErrorDeviceSize);
	soap_default_int(soap, &this->ns5__TaskExcuteData::FinishDeviceSize);
	soap_default_int(soap, &this->ns5__TaskExcuteData::TaskFinishPercentage);
	/* transient soap skipped */
}

void ns5__TaskExcuteData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteData::RobotIp);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteData::TaskType);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteData::TaskId);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteData::TaskName);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteData::PatrolDeviceName);
	soap_serialize_std__string(soap, &this->ns5__TaskExcuteData::PatrolDeviceId);
	/* transient soap skipped */
#endif
}

int ns5__TaskExcuteData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TaskExcuteData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TaskExcuteData(struct soap *soap, const char *tag, int id, const ns5__TaskExcuteData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteData), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__TaskExcuteData::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns5__TaskExcuteData::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns5__TaskExcuteData::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskName", -1, &(a->ns5__TaskExcuteData::TaskName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PatrolDeviceName", -1, &(a->ns5__TaskExcuteData::PatrolDeviceName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PatrolDeviceId", -1, &(a->ns5__TaskExcuteData::PatrolDeviceId), ""))
		return soap->error;
	if (soap_out_int(soap, "TotalDeviceSize", -1, &(a->ns5__TaskExcuteData::TotalDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "ErrorDeviceSize", -1, &(a->ns5__TaskExcuteData::ErrorDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "FinishDeviceSize", -1, &(a->ns5__TaskExcuteData::FinishDeviceSize), ""))
		return soap->error;
	if (soap_out_int(soap, "TaskFinishPercentage", -1, &(a->ns5__TaskExcuteData::TaskFinishPercentage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__TaskExcuteData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TaskExcuteData(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TaskExcuteData * SOAP_FMAC4 soap_in_ns5__TaskExcuteData(struct soap *soap, const char *tag, ns5__TaskExcuteData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TaskExcuteData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteData, sizeof(ns5__TaskExcuteData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__TaskExcuteData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TaskExcuteData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskName1 = 1;
	size_t soap_flag_PatrolDeviceName1 = 1;
	size_t soap_flag_PatrolDeviceId1 = 1;
	size_t soap_flag_TotalDeviceSize1 = 1;
	size_t soap_flag_ErrorDeviceSize1 = 1;
	size_t soap_flag_FinishDeviceSize1 = 1;
	size_t soap_flag_TaskFinishPercentage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__TaskExcuteData::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns5__TaskExcuteData::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns5__TaskExcuteData::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskName", &(a->ns5__TaskExcuteData::TaskName), "xsd:string"))
				{	soap_flag_TaskName1--;
					continue;
				}
			if (soap_flag_PatrolDeviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PatrolDeviceName", &(a->ns5__TaskExcuteData::PatrolDeviceName), "xsd:string"))
				{	soap_flag_PatrolDeviceName1--;
					continue;
				}
			if (soap_flag_PatrolDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PatrolDeviceId", &(a->ns5__TaskExcuteData::PatrolDeviceId), "xsd:string"))
				{	soap_flag_PatrolDeviceId1--;
					continue;
				}
			if (soap_flag_TotalDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TotalDeviceSize", &(a->ns5__TaskExcuteData::TotalDeviceSize), "xsd:int"))
				{	soap_flag_TotalDeviceSize1--;
					continue;
				}
			if (soap_flag_ErrorDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ErrorDeviceSize", &(a->ns5__TaskExcuteData::ErrorDeviceSize), "xsd:int"))
				{	soap_flag_ErrorDeviceSize1--;
					continue;
				}
			if (soap_flag_FinishDeviceSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FinishDeviceSize", &(a->ns5__TaskExcuteData::FinishDeviceSize), "xsd:int"))
				{	soap_flag_FinishDeviceSize1--;
					continue;
				}
			if (soap_flag_TaskFinishPercentage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TaskFinishPercentage", &(a->ns5__TaskExcuteData::TaskFinishPercentage), "xsd:int"))
				{	soap_flag_TaskFinishPercentage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TaskExcuteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__TaskExcuteData, 0, sizeof(ns5__TaskExcuteData), 0, soap_copy_ns5__TaskExcuteData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskId1 > 0 || soap_flag_TaskName1 > 0 || soap_flag_PatrolDeviceName1 > 0 || soap_flag_PatrolDeviceId1 > 0 || soap_flag_TotalDeviceSize1 > 0 || soap_flag_ErrorDeviceSize1 > 0 || soap_flag_FinishDeviceSize1 > 0 || soap_flag_TaskFinishPercentage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__TaskExcuteData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__TaskExcuteData);
	if (this->soap_out(soap, tag?tag:"ns5:TaskExcuteData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TaskExcuteData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TaskExcuteData(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TaskExcuteData * SOAP_FMAC4 soap_get_ns5__TaskExcuteData(struct soap *soap, ns5__TaskExcuteData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TaskExcuteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__TaskExcuteData * SOAP_FMAC2 soap_instantiate_ns5__TaskExcuteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TaskExcuteData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__TaskExcuteData, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__TaskExcuteData);
		if (size)
			*size = sizeof(ns5__TaskExcuteData);
		((ns5__TaskExcuteData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__TaskExcuteData, n);
		if (size)
			*size = n * sizeof(ns5__TaskExcuteData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__TaskExcuteData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__TaskExcuteData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TaskExcuteData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TaskExcuteData %p -> %p\n", q, p));
	*(ns5__TaskExcuteData*)p = *(ns5__TaskExcuteData*)q;
}

void ns5__TaskPathInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__TaskPathInfo(soap, &this->ns5__TaskPathInfos::Infos);
	/* transient soap skipped */
}

void ns5__TaskPathInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__TaskPathInfo(soap, &this->ns5__TaskPathInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__TaskPathInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TaskPathInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TaskPathInfos(struct soap *soap, const char *tag, int id, const ns5__TaskPathInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__TaskPathInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__TaskPathInfo(soap, "Infos", -1, &(a->ns5__TaskPathInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__TaskPathInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TaskPathInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TaskPathInfos * SOAP_FMAC4 soap_in_ns5__TaskPathInfos(struct soap *soap, const char *tag, ns5__TaskPathInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TaskPathInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__TaskPathInfos, sizeof(ns5__TaskPathInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__TaskPathInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TaskPathInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__TaskPathInfo(soap, "Infos", &(a->ns5__TaskPathInfos::Infos), "ns5:TaskPathInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TaskPathInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__TaskPathInfos, 0, sizeof(ns5__TaskPathInfos), 0, soap_copy_ns5__TaskPathInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__TaskPathInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__TaskPathInfos);
	if (this->soap_out(soap, tag?tag:"ns5:TaskPathInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TaskPathInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TaskPathInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TaskPathInfos * SOAP_FMAC4 soap_get_ns5__TaskPathInfos(struct soap *soap, ns5__TaskPathInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TaskPathInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__TaskPathInfos * SOAP_FMAC2 soap_instantiate_ns5__TaskPathInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TaskPathInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__TaskPathInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__TaskPathInfos);
		if (size)
			*size = sizeof(ns5__TaskPathInfos);
		((ns5__TaskPathInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__TaskPathInfos, n);
		if (size)
			*size = n * sizeof(ns5__TaskPathInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__TaskPathInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__TaskPathInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TaskPathInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TaskPathInfos %p -> %p\n", q, p));
	*(ns5__TaskPathInfos*)p = *(ns5__TaskPathInfos*)q;
}

void ns5__TaskPathInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__TaskPathInfo::TaskPathId);
	soap_default_std__string(soap, &this->ns5__TaskPathInfo::TaskPathName);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns5__TaskPathInfo::PointList);
	soap_default_std__string(soap, &this->ns5__TaskPathInfo::TaskPathType);
	soap_default_std__string(soap, &this->ns5__TaskPathInfo::CreateTime);
	soap_default_int(soap, &this->ns5__TaskPathInfo::FinishAction);
	/* transient soap skipped */
}

void ns5__TaskPathInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__TaskPathInfo::TaskPathId);
	soap_serialize_std__string(soap, &this->ns5__TaskPathInfo::TaskPathName);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns5__TaskPathInfo::PointList);
	soap_serialize_std__string(soap, &this->ns5__TaskPathInfo::TaskPathType);
	soap_serialize_std__string(soap, &this->ns5__TaskPathInfo::CreateTime);
	/* transient soap skipped */
#endif
}

int ns5__TaskPathInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TaskPathInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TaskPathInfo(struct soap *soap, const char *tag, int id, const ns5__TaskPathInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__TaskPathInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathId", -1, &(a->ns5__TaskPathInfo::TaskPathId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathName", -1, &(a->ns5__TaskPathInfo::TaskPathName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns5__TaskPathInfo::PointList), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskPathType", -1, &(a->ns5__TaskPathInfo::TaskPathType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CreateTime", -1, &(a->ns5__TaskPathInfo::CreateTime), ""))
		return soap->error;
	if (soap_out_int(soap, "FinishAction", -1, &(a->ns5__TaskPathInfo::FinishAction), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__TaskPathInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TaskPathInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TaskPathInfo * SOAP_FMAC4 soap_in_ns5__TaskPathInfo(struct soap *soap, const char *tag, ns5__TaskPathInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TaskPathInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__TaskPathInfo, sizeof(ns5__TaskPathInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__TaskPathInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TaskPathInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TaskPathId1 = 1;
	size_t soap_flag_TaskPathName1 = 1;
	size_t soap_flag_TaskPathType1 = 1;
	size_t soap_flag_CreateTime1 = 1;
	size_t soap_flag_FinishAction1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TaskPathId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathId", &(a->ns5__TaskPathInfo::TaskPathId), "xsd:string"))
				{	soap_flag_TaskPathId1--;
					continue;
				}
			if (soap_flag_TaskPathName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathName", &(a->ns5__TaskPathInfo::TaskPathName), "xsd:string"))
				{	soap_flag_TaskPathName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns5__TaskPathInfo::PointList), "xsd:string"))
					continue;
			if (soap_flag_TaskPathType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskPathType", &(a->ns5__TaskPathInfo::TaskPathType), "xsd:string"))
				{	soap_flag_TaskPathType1--;
					continue;
				}
			if (soap_flag_CreateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CreateTime", &(a->ns5__TaskPathInfo::CreateTime), "xsd:string"))
				{	soap_flag_CreateTime1--;
					continue;
				}
			if (soap_flag_FinishAction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FinishAction", &(a->ns5__TaskPathInfo::FinishAction), "xsd:int"))
				{	soap_flag_FinishAction1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TaskPathInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__TaskPathInfo, 0, sizeof(ns5__TaskPathInfo), 0, soap_copy_ns5__TaskPathInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TaskPathId1 > 0 || soap_flag_TaskPathName1 > 0 || soap_flag_TaskPathType1 > 0 || soap_flag_CreateTime1 > 0 || soap_flag_FinishAction1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__TaskPathInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__TaskPathInfo);
	if (this->soap_out(soap, tag?tag:"ns5:TaskPathInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TaskPathInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TaskPathInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TaskPathInfo * SOAP_FMAC4 soap_get_ns5__TaskPathInfo(struct soap *soap, ns5__TaskPathInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__TaskPathInfo * SOAP_FMAC2 soap_instantiate_ns5__TaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__TaskPathInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__TaskPathInfo);
		if (size)
			*size = sizeof(ns5__TaskPathInfo);
		((ns5__TaskPathInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__TaskPathInfo, n);
		if (size)
			*size = n * sizeof(ns5__TaskPathInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__TaskPathInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__TaskPathInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TaskPathInfo %p -> %p\n", q, p));
	*(ns5__TaskPathInfo*)p = *(ns5__TaskPathInfo*)q;
}

void ns5__PatrolPointInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__PatrolPointInfo(soap, &this->ns5__PatrolPointInfos::Infos);
	/* transient soap skipped */
}

void ns5__PatrolPointInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__PatrolPointInfo(soap, &this->ns5__PatrolPointInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__PatrolPointInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__PatrolPointInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__PatrolPointInfos(struct soap *soap, const char *tag, int id, const ns5__PatrolPointInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__PatrolPointInfo(soap, "Infos", -1, &(a->ns5__PatrolPointInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__PatrolPointInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__PatrolPointInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__PatrolPointInfos * SOAP_FMAC4 soap_in_ns5__PatrolPointInfos(struct soap *soap, const char *tag, ns5__PatrolPointInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__PatrolPointInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos, sizeof(ns5__PatrolPointInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__PatrolPointInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__PatrolPointInfo(soap, "Infos", &(a->ns5__PatrolPointInfos::Infos), "ns5:PatrolPointInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__PatrolPointInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos, 0, sizeof(ns5__PatrolPointInfos), 0, soap_copy_ns5__PatrolPointInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__PatrolPointInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos);
	if (this->soap_out(soap, tag?tag:"ns5:PatrolPointInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__PatrolPointInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__PatrolPointInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__PatrolPointInfos * SOAP_FMAC4 soap_get_ns5__PatrolPointInfos(struct soap *soap, ns5__PatrolPointInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__PatrolPointInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__PatrolPointInfos * SOAP_FMAC2 soap_instantiate_ns5__PatrolPointInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__PatrolPointInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__PatrolPointInfos);
		if (size)
			*size = sizeof(ns5__PatrolPointInfos);
		((ns5__PatrolPointInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__PatrolPointInfos, n);
		if (size)
			*size = n * sizeof(ns5__PatrolPointInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__PatrolPointInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__PatrolPointInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__PatrolPointInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__PatrolPointInfos %p -> %p\n", q, p));
	*(ns5__PatrolPointInfos*)p = *(ns5__PatrolPointInfos*)q;
}

void ns5__PatrolPointInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__PatrolPointInfo::PointId);
	soap_default_std__string(soap, &this->ns5__PatrolPointInfo::PointName);
	soap_default_std__string(soap, &this->ns5__PatrolPointInfo::PointType);
	soap_default_std__string(soap, &this->ns5__PatrolPointInfo::DeviceType);
	soap_default_std__string(soap, &this->ns5__PatrolPointInfo::AreaId);
	soap_default_std__string(soap, &this->ns5__PatrolPointInfo::DockId);
	soap_default_std__string(soap, &this->ns5__PatrolPointInfo::RobotIp);
	/* transient soap skipped */
}

void ns5__PatrolPointInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__PatrolPointInfo::PointId);
	soap_serialize_std__string(soap, &this->ns5__PatrolPointInfo::PointName);
	soap_serialize_std__string(soap, &this->ns5__PatrolPointInfo::PointType);
	soap_serialize_std__string(soap, &this->ns5__PatrolPointInfo::DeviceType);
	soap_serialize_std__string(soap, &this->ns5__PatrolPointInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns5__PatrolPointInfo::DockId);
	soap_serialize_std__string(soap, &this->ns5__PatrolPointInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns5__PatrolPointInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__PatrolPointInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__PatrolPointInfo(struct soap *soap, const char *tag, int id, const ns5__PatrolPointInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "PointId", -1, &(a->ns5__PatrolPointInfo::PointId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointName", -1, &(a->ns5__PatrolPointInfo::PointName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PointType", -1, &(a->ns5__PatrolPointInfo::PointType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DeviceType", -1, &(a->ns5__PatrolPointInfo::DeviceType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns5__PatrolPointInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockId", -1, &(a->ns5__PatrolPointInfo::DockId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__PatrolPointInfo::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__PatrolPointInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__PatrolPointInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__PatrolPointInfo * SOAP_FMAC4 soap_in_ns5__PatrolPointInfo(struct soap *soap, const char *tag, ns5__PatrolPointInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__PatrolPointInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo, sizeof(ns5__PatrolPointInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__PatrolPointInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PointId1 = 1;
	size_t soap_flag_PointName1 = 1;
	size_t soap_flag_PointType1 = 1;
	size_t soap_flag_DeviceType1 = 1;
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_DockId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PointId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointId", &(a->ns5__PatrolPointInfo::PointId), "xsd:string"))
				{	soap_flag_PointId1--;
					continue;
				}
			if (soap_flag_PointName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointName", &(a->ns5__PatrolPointInfo::PointName), "xsd:string"))
				{	soap_flag_PointName1--;
					continue;
				}
			if (soap_flag_PointType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PointType", &(a->ns5__PatrolPointInfo::PointType), "xsd:string"))
				{	soap_flag_PointType1--;
					continue;
				}
			if (soap_flag_DeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DeviceType", &(a->ns5__PatrolPointInfo::DeviceType), "xsd:string"))
				{	soap_flag_DeviceType1--;
					continue;
				}
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns5__PatrolPointInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_DockId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockId", &(a->ns5__PatrolPointInfo::DockId), "xsd:string"))
				{	soap_flag_DockId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__PatrolPointInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__PatrolPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo, 0, sizeof(ns5__PatrolPointInfo), 0, soap_copy_ns5__PatrolPointInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PointId1 > 0 || soap_flag_PointName1 > 0 || soap_flag_PointType1 > 0 || soap_flag_DeviceType1 > 0 || soap_flag_AreaId1 > 0 || soap_flag_DockId1 > 0 || soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__PatrolPointInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo);
	if (this->soap_out(soap, tag?tag:"ns5:PatrolPointInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__PatrolPointInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__PatrolPointInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__PatrolPointInfo * SOAP_FMAC4 soap_get_ns5__PatrolPointInfo(struct soap *soap, ns5__PatrolPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__PatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__PatrolPointInfo * SOAP_FMAC2 soap_instantiate_ns5__PatrolPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__PatrolPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__PatrolPointInfo);
		if (size)
			*size = sizeof(ns5__PatrolPointInfo);
		((ns5__PatrolPointInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__PatrolPointInfo, n);
		if (size)
			*size = n * sizeof(ns5__PatrolPointInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__PatrolPointInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__PatrolPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__PatrolPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__PatrolPointInfo %p -> %p\n", q, p));
	*(ns5__PatrolPointInfo*)p = *(ns5__PatrolPointInfo*)q;
}

void ns5__DockPointInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__DockPointInfo(soap, &this->ns5__DockPointInfos::Infos);
	/* transient soap skipped */
}

void ns5__DockPointInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__DockPointInfo(soap, &this->ns5__DockPointInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__DockPointInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__DockPointInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DockPointInfos(struct soap *soap, const char *tag, int id, const ns5__DockPointInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__DockPointInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__DockPointInfo(soap, "Infos", -1, &(a->ns5__DockPointInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__DockPointInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__DockPointInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__DockPointInfos * SOAP_FMAC4 soap_in_ns5__DockPointInfos(struct soap *soap, const char *tag, ns5__DockPointInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__DockPointInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__DockPointInfos, sizeof(ns5__DockPointInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__DockPointInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__DockPointInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__DockPointInfo(soap, "Infos", &(a->ns5__DockPointInfos::Infos), "ns5:DockPointInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__DockPointInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__DockPointInfos, 0, sizeof(ns5__DockPointInfos), 0, soap_copy_ns5__DockPointInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__DockPointInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__DockPointInfos);
	if (this->soap_out(soap, tag?tag:"ns5:DockPointInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__DockPointInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__DockPointInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__DockPointInfos * SOAP_FMAC4 soap_get_ns5__DockPointInfos(struct soap *soap, ns5__DockPointInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DockPointInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__DockPointInfos * SOAP_FMAC2 soap_instantiate_ns5__DockPointInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__DockPointInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__DockPointInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__DockPointInfos);
		if (size)
			*size = sizeof(ns5__DockPointInfos);
		((ns5__DockPointInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__DockPointInfos, n);
		if (size)
			*size = n * sizeof(ns5__DockPointInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__DockPointInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__DockPointInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__DockPointInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__DockPointInfos %p -> %p\n", q, p));
	*(ns5__DockPointInfos*)p = *(ns5__DockPointInfos*)q;
}

void ns5__DockPointInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__DockPointInfo::DockId);
	soap_default_std__string(soap, &this->ns5__DockPointInfo::DockX);
	soap_default_std__string(soap, &this->ns5__DockPointInfo::DockY);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns5__DockPointInfo::PointList);
	/* transient soap skipped */
}

void ns5__DockPointInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__DockPointInfo::DockId);
	soap_serialize_std__string(soap, &this->ns5__DockPointInfo::DockX);
	soap_serialize_std__string(soap, &this->ns5__DockPointInfo::DockY);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns5__DockPointInfo::PointList);
	/* transient soap skipped */
#endif
}

int ns5__DockPointInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__DockPointInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DockPointInfo(struct soap *soap, const char *tag, int id, const ns5__DockPointInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__DockPointInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "DockId", -1, &(a->ns5__DockPointInfo::DockId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockX", -1, &(a->ns5__DockPointInfo::DockX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "DockY", -1, &(a->ns5__DockPointInfo::DockY), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PointList", -1, &(a->ns5__DockPointInfo::PointList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__DockPointInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__DockPointInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__DockPointInfo * SOAP_FMAC4 soap_in_ns5__DockPointInfo(struct soap *soap, const char *tag, ns5__DockPointInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__DockPointInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__DockPointInfo, sizeof(ns5__DockPointInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__DockPointInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__DockPointInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DockId1 = 1;
	size_t soap_flag_DockX1 = 1;
	size_t soap_flag_DockY1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DockId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockId", &(a->ns5__DockPointInfo::DockId), "xsd:string"))
				{	soap_flag_DockId1--;
					continue;
				}
			if (soap_flag_DockX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockX", &(a->ns5__DockPointInfo::DockX), "xsd:string"))
				{	soap_flag_DockX1--;
					continue;
				}
			if (soap_flag_DockY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "DockY", &(a->ns5__DockPointInfo::DockY), "xsd:string"))
				{	soap_flag_DockY1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "PointList", &(a->ns5__DockPointInfo::PointList), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__DockPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__DockPointInfo, 0, sizeof(ns5__DockPointInfo), 0, soap_copy_ns5__DockPointInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DockId1 > 0 || soap_flag_DockX1 > 0 || soap_flag_DockY1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__DockPointInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__DockPointInfo);
	if (this->soap_out(soap, tag?tag:"ns5:DockPointInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__DockPointInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__DockPointInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__DockPointInfo * SOAP_FMAC4 soap_get_ns5__DockPointInfo(struct soap *soap, ns5__DockPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__DockPointInfo * SOAP_FMAC2 soap_instantiate_ns5__DockPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__DockPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__DockPointInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__DockPointInfo);
		if (size)
			*size = sizeof(ns5__DockPointInfo);
		((ns5__DockPointInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__DockPointInfo, n);
		if (size)
			*size = n * sizeof(ns5__DockPointInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__DockPointInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__DockPointInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__DockPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__DockPointInfo %p -> %p\n", q, p));
	*(ns5__DockPointInfo*)p = *(ns5__DockPointInfo*)q;
}

void ns5__MapEdgeInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__MapEdgeInfo(soap, &this->ns5__MapEdgeInfos::Infos);
	/* transient soap skipped */
}

void ns5__MapEdgeInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__MapEdgeInfo(soap, &this->ns5__MapEdgeInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__MapEdgeInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__MapEdgeInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__MapEdgeInfos(struct soap *soap, const char *tag, int id, const ns5__MapEdgeInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__MapEdgeInfo(soap, "Infos", -1, &(a->ns5__MapEdgeInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__MapEdgeInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__MapEdgeInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__MapEdgeInfos * SOAP_FMAC4 soap_in_ns5__MapEdgeInfos(struct soap *soap, const char *tag, ns5__MapEdgeInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__MapEdgeInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos, sizeof(ns5__MapEdgeInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__MapEdgeInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__MapEdgeInfo(soap, "Infos", &(a->ns5__MapEdgeInfos::Infos), "ns5:MapEdgeInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__MapEdgeInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos, 0, sizeof(ns5__MapEdgeInfos), 0, soap_copy_ns5__MapEdgeInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__MapEdgeInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos);
	if (this->soap_out(soap, tag?tag:"ns5:MapEdgeInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__MapEdgeInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__MapEdgeInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__MapEdgeInfos * SOAP_FMAC4 soap_get_ns5__MapEdgeInfos(struct soap *soap, ns5__MapEdgeInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__MapEdgeInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__MapEdgeInfos * SOAP_FMAC2 soap_instantiate_ns5__MapEdgeInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__MapEdgeInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__MapEdgeInfos);
		if (size)
			*size = sizeof(ns5__MapEdgeInfos);
		((ns5__MapEdgeInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__MapEdgeInfos, n);
		if (size)
			*size = n * sizeof(ns5__MapEdgeInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__MapEdgeInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__MapEdgeInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__MapEdgeInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__MapEdgeInfos %p -> %p\n", q, p));
	*(ns5__MapEdgeInfos*)p = *(ns5__MapEdgeInfos*)q;
}

void ns5__MapEdgeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::EdgeId);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::StartNodeId);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::EndNodeId);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::StartNodeX);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::StartNodeY);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::EndNodeX);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::EndNodeY);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::FirstControlX);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::FirstControlY);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::SecondControlX);
	soap_default_std__string(soap, &this->ns5__MapEdgeInfo::SecondControlY);
	/* transient soap skipped */
}

void ns5__MapEdgeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::EdgeId);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::StartNodeId);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::EndNodeId);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::StartNodeX);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::StartNodeY);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::EndNodeX);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::EndNodeY);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::FirstControlX);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::FirstControlY);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::SecondControlX);
	soap_serialize_std__string(soap, &this->ns5__MapEdgeInfo::SecondControlY);
	/* transient soap skipped */
#endif
}

int ns5__MapEdgeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__MapEdgeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__MapEdgeInfo(struct soap *soap, const char *tag, int id, const ns5__MapEdgeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "EdgeId", -1, &(a->ns5__MapEdgeInfo::EdgeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeId", -1, &(a->ns5__MapEdgeInfo::StartNodeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeId", -1, &(a->ns5__MapEdgeInfo::EndNodeId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeX", -1, &(a->ns5__MapEdgeInfo::StartNodeX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartNodeY", -1, &(a->ns5__MapEdgeInfo::StartNodeY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeX", -1, &(a->ns5__MapEdgeInfo::EndNodeX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndNodeY", -1, &(a->ns5__MapEdgeInfo::EndNodeY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FirstControlX", -1, &(a->ns5__MapEdgeInfo::FirstControlX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FirstControlY", -1, &(a->ns5__MapEdgeInfo::FirstControlY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SecondControlX", -1, &(a->ns5__MapEdgeInfo::SecondControlX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SecondControlY", -1, &(a->ns5__MapEdgeInfo::SecondControlY), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__MapEdgeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__MapEdgeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__MapEdgeInfo * SOAP_FMAC4 soap_in_ns5__MapEdgeInfo(struct soap *soap, const char *tag, ns5__MapEdgeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__MapEdgeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo, sizeof(ns5__MapEdgeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__MapEdgeInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EdgeId1 = 1;
	size_t soap_flag_StartNodeId1 = 1;
	size_t soap_flag_EndNodeId1 = 1;
	size_t soap_flag_StartNodeX1 = 1;
	size_t soap_flag_StartNodeY1 = 1;
	size_t soap_flag_EndNodeX1 = 1;
	size_t soap_flag_EndNodeY1 = 1;
	size_t soap_flag_FirstControlX1 = 1;
	size_t soap_flag_FirstControlY1 = 1;
	size_t soap_flag_SecondControlX1 = 1;
	size_t soap_flag_SecondControlY1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EdgeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EdgeId", &(a->ns5__MapEdgeInfo::EdgeId), "xsd:string"))
				{	soap_flag_EdgeId1--;
					continue;
				}
			if (soap_flag_StartNodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeId", &(a->ns5__MapEdgeInfo::StartNodeId), "xsd:string"))
				{	soap_flag_StartNodeId1--;
					continue;
				}
			if (soap_flag_EndNodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeId", &(a->ns5__MapEdgeInfo::EndNodeId), "xsd:string"))
				{	soap_flag_EndNodeId1--;
					continue;
				}
			if (soap_flag_StartNodeX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeX", &(a->ns5__MapEdgeInfo::StartNodeX), "xsd:string"))
				{	soap_flag_StartNodeX1--;
					continue;
				}
			if (soap_flag_StartNodeY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartNodeY", &(a->ns5__MapEdgeInfo::StartNodeY), "xsd:string"))
				{	soap_flag_StartNodeY1--;
					continue;
				}
			if (soap_flag_EndNodeX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeX", &(a->ns5__MapEdgeInfo::EndNodeX), "xsd:string"))
				{	soap_flag_EndNodeX1--;
					continue;
				}
			if (soap_flag_EndNodeY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndNodeY", &(a->ns5__MapEdgeInfo::EndNodeY), "xsd:string"))
				{	soap_flag_EndNodeY1--;
					continue;
				}
			if (soap_flag_FirstControlX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FirstControlX", &(a->ns5__MapEdgeInfo::FirstControlX), "xsd:string"))
				{	soap_flag_FirstControlX1--;
					continue;
				}
			if (soap_flag_FirstControlY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FirstControlY", &(a->ns5__MapEdgeInfo::FirstControlY), "xsd:string"))
				{	soap_flag_FirstControlY1--;
					continue;
				}
			if (soap_flag_SecondControlX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SecondControlX", &(a->ns5__MapEdgeInfo::SecondControlX), "xsd:string"))
				{	soap_flag_SecondControlX1--;
					continue;
				}
			if (soap_flag_SecondControlY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SecondControlY", &(a->ns5__MapEdgeInfo::SecondControlY), "xsd:string"))
				{	soap_flag_SecondControlY1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__MapEdgeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo, 0, sizeof(ns5__MapEdgeInfo), 0, soap_copy_ns5__MapEdgeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EdgeId1 > 0 || soap_flag_StartNodeId1 > 0 || soap_flag_EndNodeId1 > 0 || soap_flag_StartNodeX1 > 0 || soap_flag_StartNodeY1 > 0 || soap_flag_EndNodeX1 > 0 || soap_flag_EndNodeY1 > 0 || soap_flag_FirstControlX1 > 0 || soap_flag_FirstControlY1 > 0 || soap_flag_SecondControlX1 > 0 || soap_flag_SecondControlY1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__MapEdgeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo);
	if (this->soap_out(soap, tag?tag:"ns5:MapEdgeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__MapEdgeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__MapEdgeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__MapEdgeInfo * SOAP_FMAC4 soap_get_ns5__MapEdgeInfo(struct soap *soap, ns5__MapEdgeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__MapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__MapEdgeInfo * SOAP_FMAC2 soap_instantiate_ns5__MapEdgeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__MapEdgeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__MapEdgeInfo);
		if (size)
			*size = sizeof(ns5__MapEdgeInfo);
		((ns5__MapEdgeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__MapEdgeInfo, n);
		if (size)
			*size = n * sizeof(ns5__MapEdgeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__MapEdgeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__MapEdgeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__MapEdgeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__MapEdgeInfo %p -> %p\n", q, p));
	*(ns5__MapEdgeInfo*)p = *(ns5__MapEdgeInfo*)q;
}

void ns5__PatrolAreaInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(soap, &this->ns5__PatrolAreaInfos::Infos);
	/* transient soap skipped */
}

void ns5__PatrolAreaInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(soap, &this->ns5__PatrolAreaInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__PatrolAreaInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__PatrolAreaInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__PatrolAreaInfos(struct soap *soap, const char *tag, int id, const ns5__PatrolAreaInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(soap, "Infos", -1, &(a->ns5__PatrolAreaInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__PatrolAreaInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__PatrolAreaInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__PatrolAreaInfos * SOAP_FMAC4 soap_in_ns5__PatrolAreaInfos(struct soap *soap, const char *tag, ns5__PatrolAreaInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__PatrolAreaInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos, sizeof(ns5__PatrolAreaInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__PatrolAreaInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(soap, "Infos", &(a->ns5__PatrolAreaInfos::Infos), "ns5:PatrolAreaInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__PatrolAreaInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos, 0, sizeof(ns5__PatrolAreaInfos), 0, soap_copy_ns5__PatrolAreaInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__PatrolAreaInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos);
	if (this->soap_out(soap, tag?tag:"ns5:PatrolAreaInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__PatrolAreaInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__PatrolAreaInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__PatrolAreaInfos * SOAP_FMAC4 soap_get_ns5__PatrolAreaInfos(struct soap *soap, ns5__PatrolAreaInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__PatrolAreaInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__PatrolAreaInfos * SOAP_FMAC2 soap_instantiate_ns5__PatrolAreaInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__PatrolAreaInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__PatrolAreaInfos);
		if (size)
			*size = sizeof(ns5__PatrolAreaInfos);
		((ns5__PatrolAreaInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__PatrolAreaInfos, n);
		if (size)
			*size = n * sizeof(ns5__PatrolAreaInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__PatrolAreaInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__PatrolAreaInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__PatrolAreaInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__PatrolAreaInfos %p -> %p\n", q, p));
	*(ns5__PatrolAreaInfos*)p = *(ns5__PatrolAreaInfos*)q;
}

void ns5__PatrolAreaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__PatrolAreaInfo::AreaId);
	soap_default_std__string(soap, &this->ns5__PatrolAreaInfo::AreaName);
	soap_default_std__string(soap, &this->ns5__PatrolAreaInfo::ParentId);
	soap_default_std__string(soap, &this->ns5__PatrolAreaInfo::RobotIp);
	/* transient soap skipped */
}

void ns5__PatrolAreaInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__PatrolAreaInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns5__PatrolAreaInfo::AreaName);
	soap_serialize_std__string(soap, &this->ns5__PatrolAreaInfo::ParentId);
	soap_serialize_std__string(soap, &this->ns5__PatrolAreaInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns5__PatrolAreaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__PatrolAreaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__PatrolAreaInfo(struct soap *soap, const char *tag, int id, const ns5__PatrolAreaInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns5__PatrolAreaInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaName", -1, &(a->ns5__PatrolAreaInfo::AreaName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ParentId", -1, &(a->ns5__PatrolAreaInfo::ParentId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__PatrolAreaInfo::RobotIp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__PatrolAreaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__PatrolAreaInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__PatrolAreaInfo * SOAP_FMAC4 soap_in_ns5__PatrolAreaInfo(struct soap *soap, const char *tag, ns5__PatrolAreaInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__PatrolAreaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo, sizeof(ns5__PatrolAreaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__PatrolAreaInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_AreaName1 = 1;
	size_t soap_flag_ParentId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns5__PatrolAreaInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_AreaName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaName", &(a->ns5__PatrolAreaInfo::AreaName), "xsd:string"))
				{	soap_flag_AreaName1--;
					continue;
				}
			if (soap_flag_ParentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ParentId", &(a->ns5__PatrolAreaInfo::ParentId), "xsd:string"))
				{	soap_flag_ParentId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__PatrolAreaInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__PatrolAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo, 0, sizeof(ns5__PatrolAreaInfo), 0, soap_copy_ns5__PatrolAreaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AreaId1 > 0 || soap_flag_AreaName1 > 0 || soap_flag_ParentId1 > 0 || soap_flag_RobotIp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__PatrolAreaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo);
	if (this->soap_out(soap, tag?tag:"ns5:PatrolAreaInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__PatrolAreaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__PatrolAreaInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__PatrolAreaInfo * SOAP_FMAC4 soap_get_ns5__PatrolAreaInfo(struct soap *soap, ns5__PatrolAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__PatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__PatrolAreaInfo * SOAP_FMAC2 soap_instantiate_ns5__PatrolAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__PatrolAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__PatrolAreaInfo);
		if (size)
			*size = sizeof(ns5__PatrolAreaInfo);
		((ns5__PatrolAreaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__PatrolAreaInfo, n);
		if (size)
			*size = n * sizeof(ns5__PatrolAreaInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__PatrolAreaInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__PatrolAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__PatrolAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__PatrolAreaInfo %p -> %p\n", q, p));
	*(ns5__PatrolAreaInfo*)p = *(ns5__PatrolAreaInfo*)q;
}

void ns5__MapAreaInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__MapAreaInfo(soap, &this->ns5__MapAreaInfos::Infos);
	/* transient soap skipped */
}

void ns5__MapAreaInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__MapAreaInfo(soap, &this->ns5__MapAreaInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__MapAreaInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__MapAreaInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__MapAreaInfos(struct soap *soap, const char *tag, int id, const ns5__MapAreaInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__MapAreaInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__MapAreaInfo(soap, "Infos", -1, &(a->ns5__MapAreaInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__MapAreaInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__MapAreaInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__MapAreaInfos * SOAP_FMAC4 soap_in_ns5__MapAreaInfos(struct soap *soap, const char *tag, ns5__MapAreaInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__MapAreaInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__MapAreaInfos, sizeof(ns5__MapAreaInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__MapAreaInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__MapAreaInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__MapAreaInfo(soap, "Infos", &(a->ns5__MapAreaInfos::Infos), "ns5:MapAreaInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__MapAreaInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__MapAreaInfos, 0, sizeof(ns5__MapAreaInfos), 0, soap_copy_ns5__MapAreaInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__MapAreaInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__MapAreaInfos);
	if (this->soap_out(soap, tag?tag:"ns5:MapAreaInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__MapAreaInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__MapAreaInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__MapAreaInfos * SOAP_FMAC4 soap_get_ns5__MapAreaInfos(struct soap *soap, ns5__MapAreaInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__MapAreaInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__MapAreaInfos * SOAP_FMAC2 soap_instantiate_ns5__MapAreaInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__MapAreaInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__MapAreaInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__MapAreaInfos);
		if (size)
			*size = sizeof(ns5__MapAreaInfos);
		((ns5__MapAreaInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__MapAreaInfos, n);
		if (size)
			*size = n * sizeof(ns5__MapAreaInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__MapAreaInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__MapAreaInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__MapAreaInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__MapAreaInfos %p -> %p\n", q, p));
	*(ns5__MapAreaInfos*)p = *(ns5__MapAreaInfos*)q;
}

void ns5__MapAreaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::RobotIp);
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::AreaId);
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::AreaName);
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::AreaMap);
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::MaxX);
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::MaxY);
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::MinX);
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::MinY);
	soap_default_std__string(soap, &this->ns5__MapAreaInfo::ParentId);
	/* transient soap skipped */
}

void ns5__MapAreaInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::AreaId);
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::AreaName);
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::AreaMap);
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::MaxX);
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::MaxY);
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::MinX);
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::MinY);
	soap_serialize_std__string(soap, &this->ns5__MapAreaInfo::ParentId);
	/* transient soap skipped */
#endif
}

int ns5__MapAreaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__MapAreaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__MapAreaInfo(struct soap *soap, const char *tag, int id, const ns5__MapAreaInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__MapAreaInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__MapAreaInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaId", -1, &(a->ns5__MapAreaInfo::AreaId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaName", -1, &(a->ns5__MapAreaInfo::AreaName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AreaMap", -1, &(a->ns5__MapAreaInfo::AreaMap), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MaxX", -1, &(a->ns5__MapAreaInfo::MaxX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MaxY", -1, &(a->ns5__MapAreaInfo::MaxY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MinX", -1, &(a->ns5__MapAreaInfo::MinX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "MinY", -1, &(a->ns5__MapAreaInfo::MinY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ParentId", -1, &(a->ns5__MapAreaInfo::ParentId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__MapAreaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__MapAreaInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__MapAreaInfo * SOAP_FMAC4 soap_in_ns5__MapAreaInfo(struct soap *soap, const char *tag, ns5__MapAreaInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__MapAreaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__MapAreaInfo, sizeof(ns5__MapAreaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__MapAreaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__MapAreaInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_AreaId1 = 1;
	size_t soap_flag_AreaName1 = 1;
	size_t soap_flag_AreaMap1 = 1;
	size_t soap_flag_MaxX1 = 1;
	size_t soap_flag_MaxY1 = 1;
	size_t soap_flag_MinX1 = 1;
	size_t soap_flag_MinY1 = 1;
	size_t soap_flag_ParentId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__MapAreaInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_AreaId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaId", &(a->ns5__MapAreaInfo::AreaId), "xsd:string"))
				{	soap_flag_AreaId1--;
					continue;
				}
			if (soap_flag_AreaName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaName", &(a->ns5__MapAreaInfo::AreaName), "xsd:string"))
				{	soap_flag_AreaName1--;
					continue;
				}
			if (soap_flag_AreaMap1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AreaMap", &(a->ns5__MapAreaInfo::AreaMap), "xsd:string"))
				{	soap_flag_AreaMap1--;
					continue;
				}
			if (soap_flag_MaxX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MaxX", &(a->ns5__MapAreaInfo::MaxX), "xsd:string"))
				{	soap_flag_MaxX1--;
					continue;
				}
			if (soap_flag_MaxY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MaxY", &(a->ns5__MapAreaInfo::MaxY), "xsd:string"))
				{	soap_flag_MaxY1--;
					continue;
				}
			if (soap_flag_MinX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MinX", &(a->ns5__MapAreaInfo::MinX), "xsd:string"))
				{	soap_flag_MinX1--;
					continue;
				}
			if (soap_flag_MinY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "MinY", &(a->ns5__MapAreaInfo::MinY), "xsd:string"))
				{	soap_flag_MinY1--;
					continue;
				}
			if (soap_flag_ParentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ParentId", &(a->ns5__MapAreaInfo::ParentId), "xsd:string"))
				{	soap_flag_ParentId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__MapAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__MapAreaInfo, 0, sizeof(ns5__MapAreaInfo), 0, soap_copy_ns5__MapAreaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_AreaId1 > 0 || soap_flag_AreaName1 > 0 || soap_flag_AreaMap1 > 0 || soap_flag_MaxX1 > 0 || soap_flag_MaxY1 > 0 || soap_flag_MinX1 > 0 || soap_flag_MinY1 > 0 || soap_flag_ParentId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__MapAreaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__MapAreaInfo);
	if (this->soap_out(soap, tag?tag:"ns5:MapAreaInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__MapAreaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__MapAreaInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__MapAreaInfo * SOAP_FMAC4 soap_get_ns5__MapAreaInfo(struct soap *soap, ns5__MapAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__MapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__MapAreaInfo * SOAP_FMAC2 soap_instantiate_ns5__MapAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__MapAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__MapAreaInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__MapAreaInfo);
		if (size)
			*size = sizeof(ns5__MapAreaInfo);
		((ns5__MapAreaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__MapAreaInfo, n);
		if (size)
			*size = n * sizeof(ns5__MapAreaInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__MapAreaInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__MapAreaInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__MapAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__MapAreaInfo %p -> %p\n", q, p));
	*(ns5__MapAreaInfo*)p = *(ns5__MapAreaInfo*)q;
}

void ns5__RobotAlarmInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(soap, &this->ns5__RobotAlarmInfos::Infos);
	/* transient soap skipped */
}

void ns5__RobotAlarmInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(soap, &this->ns5__RobotAlarmInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__RobotAlarmInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotAlarmInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotAlarmInfos(struct soap *soap, const char *tag, int id, const ns5__RobotAlarmInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(soap, "Infos", -1, &(a->ns5__RobotAlarmInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotAlarmInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotAlarmInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotAlarmInfos * SOAP_FMAC4 soap_in_ns5__RobotAlarmInfos(struct soap *soap, const char *tag, ns5__RobotAlarmInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotAlarmInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos, sizeof(ns5__RobotAlarmInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotAlarmInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(soap, "Infos", &(a->ns5__RobotAlarmInfos::Infos), "ns5:RobotAlarmInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotAlarmInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos, 0, sizeof(ns5__RobotAlarmInfos), 0, soap_copy_ns5__RobotAlarmInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__RobotAlarmInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos);
	if (this->soap_out(soap, tag?tag:"ns5:RobotAlarmInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotAlarmInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotAlarmInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotAlarmInfos * SOAP_FMAC4 soap_get_ns5__RobotAlarmInfos(struct soap *soap, ns5__RobotAlarmInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotAlarmInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotAlarmInfos * SOAP_FMAC2 soap_instantiate_ns5__RobotAlarmInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotAlarmInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotAlarmInfos);
		if (size)
			*size = sizeof(ns5__RobotAlarmInfos);
		((ns5__RobotAlarmInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotAlarmInfos, n);
		if (size)
			*size = n * sizeof(ns5__RobotAlarmInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotAlarmInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotAlarmInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotAlarmInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotAlarmInfos %p -> %p\n", q, p));
	*(ns5__RobotAlarmInfos*)p = *(ns5__RobotAlarmInfos*)q;
}

void ns5__RobotAlarmInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__RobotAlarmInfo::AlarmId);
	soap_default_std__string(soap, &this->ns5__RobotAlarmInfo::RobotIp);
	soap_default_std__string(soap, &this->ns5__RobotAlarmInfo::AlarmType);
	soap_default_std__string(soap, &this->ns5__RobotAlarmInfo::AlarmDesc);
	soap_default_std__string(soap, &this->ns5__RobotAlarmInfo::AlarmTime);
	/* transient soap skipped */
}

void ns5__RobotAlarmInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__RobotAlarmInfo::AlarmId);
	soap_serialize_std__string(soap, &this->ns5__RobotAlarmInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns5__RobotAlarmInfo::AlarmType);
	soap_serialize_std__string(soap, &this->ns5__RobotAlarmInfo::AlarmDesc);
	soap_serialize_std__string(soap, &this->ns5__RobotAlarmInfo::AlarmTime);
	/* transient soap skipped */
#endif
}

int ns5__RobotAlarmInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotAlarmInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotAlarmInfo(struct soap *soap, const char *tag, int id, const ns5__RobotAlarmInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmId", -1, &(a->ns5__RobotAlarmInfo::AlarmId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__RobotAlarmInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmType", -1, &(a->ns5__RobotAlarmInfo::AlarmType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmDesc", -1, &(a->ns5__RobotAlarmInfo::AlarmDesc), ""))
		return soap->error;
	if (soap_out_std__string(soap, "AlarmTime", -1, &(a->ns5__RobotAlarmInfo::AlarmTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotAlarmInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotAlarmInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotAlarmInfo * SOAP_FMAC4 soap_in_ns5__RobotAlarmInfo(struct soap *soap, const char *tag, ns5__RobotAlarmInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotAlarmInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo, sizeof(ns5__RobotAlarmInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotAlarmInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AlarmId1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_AlarmType1 = 1;
	size_t soap_flag_AlarmDesc1 = 1;
	size_t soap_flag_AlarmTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AlarmId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmId", &(a->ns5__RobotAlarmInfo::AlarmId), "xsd:string"))
				{	soap_flag_AlarmId1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__RobotAlarmInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_AlarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmType", &(a->ns5__RobotAlarmInfo::AlarmType), "xsd:string"))
				{	soap_flag_AlarmType1--;
					continue;
				}
			if (soap_flag_AlarmDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmDesc", &(a->ns5__RobotAlarmInfo::AlarmDesc), "xsd:string"))
				{	soap_flag_AlarmDesc1--;
					continue;
				}
			if (soap_flag_AlarmTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "AlarmTime", &(a->ns5__RobotAlarmInfo::AlarmTime), "xsd:string"))
				{	soap_flag_AlarmTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotAlarmInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo, 0, sizeof(ns5__RobotAlarmInfo), 0, soap_copy_ns5__RobotAlarmInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AlarmId1 > 0 || soap_flag_RobotIp1 > 0 || soap_flag_AlarmType1 > 0 || soap_flag_AlarmDesc1 > 0 || soap_flag_AlarmTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__RobotAlarmInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo);
	if (this->soap_out(soap, tag?tag:"ns5:RobotAlarmInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotAlarmInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotAlarmInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotAlarmInfo * SOAP_FMAC4 soap_get_ns5__RobotAlarmInfo(struct soap *soap, ns5__RobotAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotAlarmInfo * SOAP_FMAC2 soap_instantiate_ns5__RobotAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotAlarmInfo);
		if (size)
			*size = sizeof(ns5__RobotAlarmInfo);
		((ns5__RobotAlarmInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotAlarmInfo, n);
		if (size)
			*size = n * sizeof(ns5__RobotAlarmInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotAlarmInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotAlarmInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotAlarmInfo %p -> %p\n", q, p));
	*(ns5__RobotAlarmInfo*)p = *(ns5__RobotAlarmInfo*)q;
}

void ns5__RobotGasInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__RobotGasInfo(soap, &this->ns5__RobotGasInfos::GasContents);
	/* transient soap skipped */
}

void ns5__RobotGasInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__RobotGasInfo(soap, &this->ns5__RobotGasInfos::GasContents);
	/* transient soap skipped */
#endif
}

int ns5__RobotGasInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotGasInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotGasInfos(struct soap *soap, const char *tag, int id, const ns5__RobotGasInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotGasInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RobotGasInfo(soap, "GasContents", -1, &(a->ns5__RobotGasInfos::GasContents), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotGasInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotGasInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotGasInfos * SOAP_FMAC4 soap_in_ns5__RobotGasInfos(struct soap *soap, const char *tag, ns5__RobotGasInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotGasInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotGasInfos, sizeof(ns5__RobotGasInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotGasInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotGasInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__RobotGasInfo(soap, "GasContents", &(a->ns5__RobotGasInfos::GasContents), "ns5:RobotGasInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotGasInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotGasInfos, 0, sizeof(ns5__RobotGasInfos), 0, soap_copy_ns5__RobotGasInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__RobotGasInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotGasInfos);
	if (this->soap_out(soap, tag?tag:"ns5:RobotGasInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotGasInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotGasInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotGasInfos * SOAP_FMAC4 soap_get_ns5__RobotGasInfos(struct soap *soap, ns5__RobotGasInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotGasInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotGasInfos * SOAP_FMAC2 soap_instantiate_ns5__RobotGasInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotGasInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotGasInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotGasInfos);
		if (size)
			*size = sizeof(ns5__RobotGasInfos);
		((ns5__RobotGasInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotGasInfos, n);
		if (size)
			*size = n * sizeof(ns5__RobotGasInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotGasInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotGasInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotGasInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotGasInfos %p -> %p\n", q, p));
	*(ns5__RobotGasInfos*)p = *(ns5__RobotGasInfos*)q;
}

void ns5__RobotGasInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::robot_ip);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::H2S);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::CO);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::O2);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::CH4);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::TEMP);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::HUM);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::PM25);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::PM10);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::O3);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::SF6);
	soap_default_std__string(soap, &this->ns5__RobotGasInfo::Desc);
	/* transient soap skipped */
}

void ns5__RobotGasInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::robot_ip);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::H2S);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::CO);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::O2);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::CH4);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::TEMP);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::HUM);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::PM25);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::PM10);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::O3);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::SF6);
	soap_serialize_std__string(soap, &this->ns5__RobotGasInfo::Desc);
	/* transient soap skipped */
#endif
}

int ns5__RobotGasInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotGasInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotGasInfo(struct soap *soap, const char *tag, int id, const ns5__RobotGasInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotGasInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "robot-ip", -1, &(a->ns5__RobotGasInfo::robot_ip), ""))
		return soap->error;
	if (soap_out_std__string(soap, "H2S", -1, &(a->ns5__RobotGasInfo::H2S), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CO", -1, &(a->ns5__RobotGasInfo::CO), ""))
		return soap->error;
	if (soap_out_std__string(soap, "O2", -1, &(a->ns5__RobotGasInfo::O2), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CH4", -1, &(a->ns5__RobotGasInfo::CH4), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TEMP", -1, &(a->ns5__RobotGasInfo::TEMP), ""))
		return soap->error;
	if (soap_out_std__string(soap, "HUM", -1, &(a->ns5__RobotGasInfo::HUM), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PM25", -1, &(a->ns5__RobotGasInfo::PM25), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PM10", -1, &(a->ns5__RobotGasInfo::PM10), ""))
		return soap->error;
	if (soap_out_std__string(soap, "O3", -1, &(a->ns5__RobotGasInfo::O3), ""))
		return soap->error;
	if (soap_out_std__string(soap, "SF6", -1, &(a->ns5__RobotGasInfo::SF6), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Desc", -1, &(a->ns5__RobotGasInfo::Desc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotGasInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotGasInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotGasInfo * SOAP_FMAC4 soap_in_ns5__RobotGasInfo(struct soap *soap, const char *tag, ns5__RobotGasInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotGasInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotGasInfo, sizeof(ns5__RobotGasInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotGasInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotGasInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot_ip1 = 1;
	size_t soap_flag_H2S1 = 1;
	size_t soap_flag_CO1 = 1;
	size_t soap_flag_O21 = 1;
	size_t soap_flag_CH41 = 1;
	size_t soap_flag_TEMP1 = 1;
	size_t soap_flag_HUM1 = 1;
	size_t soap_flag_PM251 = 1;
	size_t soap_flag_PM101 = 1;
	size_t soap_flag_O31 = 1;
	size_t soap_flag_SF61 = 1;
	size_t soap_flag_Desc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot_ip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "robot-ip", &(a->ns5__RobotGasInfo::robot_ip), "xsd:string"))
				{	soap_flag_robot_ip1--;
					continue;
				}
			if (soap_flag_H2S1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "H2S", &(a->ns5__RobotGasInfo::H2S), "xsd:string"))
				{	soap_flag_H2S1--;
					continue;
				}
			if (soap_flag_CO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CO", &(a->ns5__RobotGasInfo::CO), "xsd:string"))
				{	soap_flag_CO1--;
					continue;
				}
			if (soap_flag_O21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "O2", &(a->ns5__RobotGasInfo::O2), "xsd:string"))
				{	soap_flag_O21--;
					continue;
				}
			if (soap_flag_CH41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CH4", &(a->ns5__RobotGasInfo::CH4), "xsd:string"))
				{	soap_flag_CH41--;
					continue;
				}
			if (soap_flag_TEMP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TEMP", &(a->ns5__RobotGasInfo::TEMP), "xsd:string"))
				{	soap_flag_TEMP1--;
					continue;
				}
			if (soap_flag_HUM1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "HUM", &(a->ns5__RobotGasInfo::HUM), "xsd:string"))
				{	soap_flag_HUM1--;
					continue;
				}
			if (soap_flag_PM251 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PM25", &(a->ns5__RobotGasInfo::PM25), "xsd:string"))
				{	soap_flag_PM251--;
					continue;
				}
			if (soap_flag_PM101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PM10", &(a->ns5__RobotGasInfo::PM10), "xsd:string"))
				{	soap_flag_PM101--;
					continue;
				}
			if (soap_flag_O31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "O3", &(a->ns5__RobotGasInfo::O3), "xsd:string"))
				{	soap_flag_O31--;
					continue;
				}
			if (soap_flag_SF61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "SF6", &(a->ns5__RobotGasInfo::SF6), "xsd:string"))
				{	soap_flag_SF61--;
					continue;
				}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Desc", &(a->ns5__RobotGasInfo::Desc), "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotGasInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotGasInfo, 0, sizeof(ns5__RobotGasInfo), 0, soap_copy_ns5__RobotGasInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot_ip1 > 0 || soap_flag_H2S1 > 0 || soap_flag_CO1 > 0 || soap_flag_O21 > 0 || soap_flag_CH41 > 0 || soap_flag_TEMP1 > 0 || soap_flag_HUM1 > 0 || soap_flag_PM251 > 0 || soap_flag_PM101 > 0 || soap_flag_O31 > 0 || soap_flag_SF61 > 0 || soap_flag_Desc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__RobotGasInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotGasInfo);
	if (this->soap_out(soap, tag?tag:"ns5:RobotGasInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotGasInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotGasInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotGasInfo * SOAP_FMAC4 soap_get_ns5__RobotGasInfo(struct soap *soap, ns5__RobotGasInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotGasInfo * SOAP_FMAC2 soap_instantiate_ns5__RobotGasInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotGasInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotGasInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotGasInfo);
		if (size)
			*size = sizeof(ns5__RobotGasInfo);
		((ns5__RobotGasInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotGasInfo, n);
		if (size)
			*size = n * sizeof(ns5__RobotGasInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotGasInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotGasInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotGasInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotGasInfo %p -> %p\n", q, p));
	*(ns5__RobotGasInfo*)p = *(ns5__RobotGasInfo*)q;
}

void ns5__RobotMileageInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__RobotMileageInfo(soap, &this->ns5__RobotMileageInfos::Infos);
	/* transient soap skipped */
}

void ns5__RobotMileageInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__RobotMileageInfo(soap, &this->ns5__RobotMileageInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__RobotMileageInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotMileageInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotMileageInfos(struct soap *soap, const char *tag, int id, const ns5__RobotMileageInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RobotMileageInfo(soap, "Infos", -1, &(a->ns5__RobotMileageInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotMileageInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotMileageInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotMileageInfos * SOAP_FMAC4 soap_in_ns5__RobotMileageInfos(struct soap *soap, const char *tag, ns5__RobotMileageInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotMileageInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos, sizeof(ns5__RobotMileageInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotMileageInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__RobotMileageInfo(soap, "Infos", &(a->ns5__RobotMileageInfos::Infos), "ns5:RobotMileageInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotMileageInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos, 0, sizeof(ns5__RobotMileageInfos), 0, soap_copy_ns5__RobotMileageInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__RobotMileageInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos);
	if (this->soap_out(soap, tag?tag:"ns5:RobotMileageInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotMileageInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotMileageInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotMileageInfos * SOAP_FMAC4 soap_get_ns5__RobotMileageInfos(struct soap *soap, ns5__RobotMileageInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotMileageInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotMileageInfos * SOAP_FMAC2 soap_instantiate_ns5__RobotMileageInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotMileageInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotMileageInfos);
		if (size)
			*size = sizeof(ns5__RobotMileageInfos);
		((ns5__RobotMileageInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotMileageInfos, n);
		if (size)
			*size = n * sizeof(ns5__RobotMileageInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotMileageInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotMileageInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotMileageInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotMileageInfos %p -> %p\n", q, p));
	*(ns5__RobotMileageInfos*)p = *(ns5__RobotMileageInfos*)q;
}

void ns5__RobotMileageInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__RobotMileageInfo::RobotIp);
	soap_default_double(soap, &this->ns5__RobotMileageInfo::Mileage);
	/* transient soap skipped */
}

void ns5__RobotMileageInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__RobotMileageInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns5__RobotMileageInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotMileageInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotMileageInfo(struct soap *soap, const char *tag, int id, const ns5__RobotMileageInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__RobotMileageInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "Mileage", -1, &(a->ns5__RobotMileageInfo::Mileage), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotMileageInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotMileageInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotMileageInfo * SOAP_FMAC4 soap_in_ns5__RobotMileageInfo(struct soap *soap, const char *tag, ns5__RobotMileageInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotMileageInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo, sizeof(ns5__RobotMileageInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotMileageInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_Mileage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__RobotMileageInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_Mileage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Mileage", &(a->ns5__RobotMileageInfo::Mileage), "xsd:double"))
				{	soap_flag_Mileage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotMileageInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo, 0, sizeof(ns5__RobotMileageInfo), 0, soap_copy_ns5__RobotMileageInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_Mileage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__RobotMileageInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo);
	if (this->soap_out(soap, tag?tag:"ns5:RobotMileageInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotMileageInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotMileageInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotMileageInfo * SOAP_FMAC4 soap_get_ns5__RobotMileageInfo(struct soap *soap, ns5__RobotMileageInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotMileageInfo * SOAP_FMAC2 soap_instantiate_ns5__RobotMileageInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotMileageInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotMileageInfo);
		if (size)
			*size = sizeof(ns5__RobotMileageInfo);
		((ns5__RobotMileageInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotMileageInfo, n);
		if (size)
			*size = n * sizeof(ns5__RobotMileageInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotMileageInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotMileageInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotMileageInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotMileageInfo %p -> %p\n", q, p));
	*(ns5__RobotMileageInfo*)p = *(ns5__RobotMileageInfo*)q;
}

void ns5__RobotYunTaiInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(soap, &this->ns5__RobotYunTaiInfos::Infos);
	/* transient soap skipped */
}

void ns5__RobotYunTaiInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(soap, &this->ns5__RobotYunTaiInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__RobotYunTaiInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotYunTaiInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotYunTaiInfos(struct soap *soap, const char *tag, int id, const ns5__RobotYunTaiInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(soap, "Infos", -1, &(a->ns5__RobotYunTaiInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotYunTaiInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotYunTaiInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotYunTaiInfos * SOAP_FMAC4 soap_in_ns5__RobotYunTaiInfos(struct soap *soap, const char *tag, ns5__RobotYunTaiInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotYunTaiInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos, sizeof(ns5__RobotYunTaiInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotYunTaiInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(soap, "Infos", &(a->ns5__RobotYunTaiInfos::Infos), "ns5:RobotYunTaiInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotYunTaiInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos, 0, sizeof(ns5__RobotYunTaiInfos), 0, soap_copy_ns5__RobotYunTaiInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__RobotYunTaiInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos);
	if (this->soap_out(soap, tag?tag:"ns5:RobotYunTaiInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotYunTaiInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotYunTaiInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotYunTaiInfos * SOAP_FMAC4 soap_get_ns5__RobotYunTaiInfos(struct soap *soap, ns5__RobotYunTaiInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotYunTaiInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotYunTaiInfos * SOAP_FMAC2 soap_instantiate_ns5__RobotYunTaiInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotYunTaiInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotYunTaiInfos);
		if (size)
			*size = sizeof(ns5__RobotYunTaiInfos);
		((ns5__RobotYunTaiInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotYunTaiInfos, n);
		if (size)
			*size = n * sizeof(ns5__RobotYunTaiInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotYunTaiInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotYunTaiInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotYunTaiInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotYunTaiInfos %p -> %p\n", q, p));
	*(ns5__RobotYunTaiInfos*)p = *(ns5__RobotYunTaiInfos*)q;
}

void ns5__RobotYunTaiInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__RobotYunTaiInfo::RobotIp);
	soap_default_std__string(soap, &this->ns5__RobotYunTaiInfo::PosPan);
	soap_default_std__string(soap, &this->ns5__RobotYunTaiInfo::PosTile);
	/* transient soap skipped */
}

void ns5__RobotYunTaiInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__RobotYunTaiInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns5__RobotYunTaiInfo::PosPan);
	soap_serialize_std__string(soap, &this->ns5__RobotYunTaiInfo::PosTile);
	/* transient soap skipped */
#endif
}

int ns5__RobotYunTaiInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotYunTaiInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, const ns5__RobotYunTaiInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__RobotYunTaiInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosPan", -1, &(a->ns5__RobotYunTaiInfo::PosPan), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosTile", -1, &(a->ns5__RobotYunTaiInfo::PosTile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotYunTaiInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotYunTaiInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotYunTaiInfo * SOAP_FMAC4 soap_in_ns5__RobotYunTaiInfo(struct soap *soap, const char *tag, ns5__RobotYunTaiInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotYunTaiInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo, sizeof(ns5__RobotYunTaiInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotYunTaiInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_PosPan1 = 1;
	size_t soap_flag_PosTile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__RobotYunTaiInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_PosPan1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosPan", &(a->ns5__RobotYunTaiInfo::PosPan), "xsd:string"))
				{	soap_flag_PosPan1--;
					continue;
				}
			if (soap_flag_PosTile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosTile", &(a->ns5__RobotYunTaiInfo::PosTile), "xsd:string"))
				{	soap_flag_PosTile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotYunTaiInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo, 0, sizeof(ns5__RobotYunTaiInfo), 0, soap_copy_ns5__RobotYunTaiInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_PosPan1 > 0 || soap_flag_PosTile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__RobotYunTaiInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo);
	if (this->soap_out(soap, tag?tag:"ns5:RobotYunTaiInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotYunTaiInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotYunTaiInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotYunTaiInfo * SOAP_FMAC4 soap_get_ns5__RobotYunTaiInfo(struct soap *soap, ns5__RobotYunTaiInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotYunTaiInfo * SOAP_FMAC2 soap_instantiate_ns5__RobotYunTaiInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotYunTaiInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotYunTaiInfo);
		if (size)
			*size = sizeof(ns5__RobotYunTaiInfo);
		((ns5__RobotYunTaiInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotYunTaiInfo, n);
		if (size)
			*size = n * sizeof(ns5__RobotYunTaiInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotYunTaiInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotYunTaiInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotYunTaiInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotYunTaiInfo %p -> %p\n", q, p));
	*(ns5__RobotYunTaiInfo*)p = *(ns5__RobotYunTaiInfo*)q;
}

void ns5__RobotPosInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__RobotPosInfo(soap, &this->ns5__RobotPosInfos::Infos);
	/* transient soap skipped */
}

void ns5__RobotPosInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__RobotPosInfo(soap, &this->ns5__RobotPosInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__RobotPosInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotPosInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotPosInfos(struct soap *soap, const char *tag, int id, const ns5__RobotPosInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotPosInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RobotPosInfo(soap, "Infos", -1, &(a->ns5__RobotPosInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotPosInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotPosInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotPosInfos * SOAP_FMAC4 soap_in_ns5__RobotPosInfos(struct soap *soap, const char *tag, ns5__RobotPosInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotPosInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotPosInfos, sizeof(ns5__RobotPosInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotPosInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotPosInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__RobotPosInfo(soap, "Infos", &(a->ns5__RobotPosInfos::Infos), "ns5:RobotPosInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotPosInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotPosInfos, 0, sizeof(ns5__RobotPosInfos), 0, soap_copy_ns5__RobotPosInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__RobotPosInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotPosInfos);
	if (this->soap_out(soap, tag?tag:"ns5:RobotPosInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotPosInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotPosInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotPosInfos * SOAP_FMAC4 soap_get_ns5__RobotPosInfos(struct soap *soap, ns5__RobotPosInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotPosInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotPosInfos * SOAP_FMAC2 soap_instantiate_ns5__RobotPosInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotPosInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotPosInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotPosInfos);
		if (size)
			*size = sizeof(ns5__RobotPosInfos);
		((ns5__RobotPosInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotPosInfos, n);
		if (size)
			*size = n * sizeof(ns5__RobotPosInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotPosInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotPosInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotPosInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotPosInfos %p -> %p\n", q, p));
	*(ns5__RobotPosInfos*)p = *(ns5__RobotPosInfos*)q;
}

void ns5__RobotPosInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__RobotPosInfo::RobotIp);
	soap_default_std__string(soap, &this->ns5__RobotPosInfo::PosX);
	soap_default_std__string(soap, &this->ns5__RobotPosInfo::PosY);
	soap_default_std__string(soap, &this->ns5__RobotPosInfo::Angle);
	soap_default_std__string(soap, &this->ns5__RobotPosInfo::EdgeID);
	soap_default_std__string(soap, &this->ns5__RobotPosInfo::Precent);
	/* transient soap skipped */
}

void ns5__RobotPosInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__RobotPosInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns5__RobotPosInfo::PosX);
	soap_serialize_std__string(soap, &this->ns5__RobotPosInfo::PosY);
	soap_serialize_std__string(soap, &this->ns5__RobotPosInfo::Angle);
	soap_serialize_std__string(soap, &this->ns5__RobotPosInfo::EdgeID);
	soap_serialize_std__string(soap, &this->ns5__RobotPosInfo::Precent);
	/* transient soap skipped */
#endif
}

int ns5__RobotPosInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotPosInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotPosInfo(struct soap *soap, const char *tag, int id, const ns5__RobotPosInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotPosInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__RobotPosInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosX", -1, &(a->ns5__RobotPosInfo::PosX), ""))
		return soap->error;
	if (soap_out_std__string(soap, "PosY", -1, &(a->ns5__RobotPosInfo::PosY), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Angle", -1, &(a->ns5__RobotPosInfo::Angle), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EdgeID", -1, &(a->ns5__RobotPosInfo::EdgeID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Precent", -1, &(a->ns5__RobotPosInfo::Precent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotPosInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotPosInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotPosInfo * SOAP_FMAC4 soap_in_ns5__RobotPosInfo(struct soap *soap, const char *tag, ns5__RobotPosInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotPosInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotPosInfo, sizeof(ns5__RobotPosInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotPosInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotPosInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_PosX1 = 1;
	size_t soap_flag_PosY1 = 1;
	size_t soap_flag_Angle1 = 1;
	size_t soap_flag_EdgeID1 = 1;
	size_t soap_flag_Precent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__RobotPosInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_PosX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosX", &(a->ns5__RobotPosInfo::PosX), "xsd:string"))
				{	soap_flag_PosX1--;
					continue;
				}
			if (soap_flag_PosY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "PosY", &(a->ns5__RobotPosInfo::PosY), "xsd:string"))
				{	soap_flag_PosY1--;
					continue;
				}
			if (soap_flag_Angle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Angle", &(a->ns5__RobotPosInfo::Angle), "xsd:string"))
				{	soap_flag_Angle1--;
					continue;
				}
			if (soap_flag_EdgeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EdgeID", &(a->ns5__RobotPosInfo::EdgeID), "xsd:string"))
				{	soap_flag_EdgeID1--;
					continue;
				}
			if (soap_flag_Precent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Precent", &(a->ns5__RobotPosInfo::Precent), "xsd:string"))
				{	soap_flag_Precent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotPosInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotPosInfo, 0, sizeof(ns5__RobotPosInfo), 0, soap_copy_ns5__RobotPosInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_PosX1 > 0 || soap_flag_PosY1 > 0 || soap_flag_Angle1 > 0 || soap_flag_EdgeID1 > 0 || soap_flag_Precent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__RobotPosInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotPosInfo);
	if (this->soap_out(soap, tag?tag:"ns5:RobotPosInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotPosInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotPosInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotPosInfo * SOAP_FMAC4 soap_get_ns5__RobotPosInfo(struct soap *soap, ns5__RobotPosInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotPosInfo * SOAP_FMAC2 soap_instantiate_ns5__RobotPosInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotPosInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotPosInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotPosInfo);
		if (size)
			*size = sizeof(ns5__RobotPosInfo);
		((ns5__RobotPosInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotPosInfo, n);
		if (size)
			*size = n * sizeof(ns5__RobotPosInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotPosInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotPosInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotPosInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotPosInfo %p -> %p\n", q, p));
	*(ns5__RobotPosInfo*)p = *(ns5__RobotPosInfo*)q;
}

void ns5__RobotTaskStates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__RobotTaskState(soap, &this->ns5__RobotTaskStates::States);
	/* transient soap skipped */
}

void ns5__RobotTaskStates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__RobotTaskState(soap, &this->ns5__RobotTaskStates::States);
	/* transient soap skipped */
#endif
}

int ns5__RobotTaskStates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotTaskStates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotTaskStates(struct soap *soap, const char *tag, int id, const ns5__RobotTaskStates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotTaskStates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RobotTaskState(soap, "States", -1, &(a->ns5__RobotTaskStates::States), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotTaskStates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotTaskStates(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotTaskStates * SOAP_FMAC4 soap_in_ns5__RobotTaskStates(struct soap *soap, const char *tag, ns5__RobotTaskStates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotTaskStates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotTaskStates, sizeof(ns5__RobotTaskStates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotTaskStates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotTaskStates *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__RobotTaskState(soap, "States", &(a->ns5__RobotTaskStates::States), "ns5:RobotTaskState"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotTaskStates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotTaskStates, 0, sizeof(ns5__RobotTaskStates), 0, soap_copy_ns5__RobotTaskStates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__RobotTaskStates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotTaskStates);
	if (this->soap_out(soap, tag?tag:"ns5:RobotTaskStates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotTaskStates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotTaskStates(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotTaskStates * SOAP_FMAC4 soap_get_ns5__RobotTaskStates(struct soap *soap, ns5__RobotTaskStates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotTaskStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotTaskStates * SOAP_FMAC2 soap_instantiate_ns5__RobotTaskStates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotTaskStates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotTaskStates, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotTaskStates);
		if (size)
			*size = sizeof(ns5__RobotTaskStates);
		((ns5__RobotTaskStates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotTaskStates, n);
		if (size)
			*size = n * sizeof(ns5__RobotTaskStates);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotTaskStates*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotTaskStates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotTaskStates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotTaskStates %p -> %p\n", q, p));
	*(ns5__RobotTaskStates*)p = *(ns5__RobotTaskStates*)q;
}

void ns5__RobotTaskState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__RobotTaskState::RobotIp);
	soap_default_std__string(soap, &this->ns5__RobotTaskState::TaskId);
	soap_default_std__string(soap, &this->ns5__RobotTaskState::TaskType);
	soap_default_std__string(soap, &this->ns5__RobotTaskState::TaskDesc);
	/* transient soap skipped */
}

void ns5__RobotTaskState::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__RobotTaskState::RobotIp);
	soap_serialize_std__string(soap, &this->ns5__RobotTaskState::TaskId);
	soap_serialize_std__string(soap, &this->ns5__RobotTaskState::TaskType);
	soap_serialize_std__string(soap, &this->ns5__RobotTaskState::TaskDesc);
	/* transient soap skipped */
#endif
}

int ns5__RobotTaskState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotTaskState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotTaskState(struct soap *soap, const char *tag, int id, const ns5__RobotTaskState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotTaskState), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__RobotTaskState::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskId", -1, &(a->ns5__RobotTaskState::TaskId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskType", -1, &(a->ns5__RobotTaskState::TaskType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "TaskDesc", -1, &(a->ns5__RobotTaskState::TaskDesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotTaskState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotTaskState(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotTaskState * SOAP_FMAC4 soap_in_ns5__RobotTaskState(struct soap *soap, const char *tag, ns5__RobotTaskState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotTaskState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotTaskState, sizeof(ns5__RobotTaskState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotTaskState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotTaskState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_TaskId1 = 1;
	size_t soap_flag_TaskType1 = 1;
	size_t soap_flag_TaskDesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__RobotTaskState::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_TaskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskId", &(a->ns5__RobotTaskState::TaskId), "xsd:string"))
				{	soap_flag_TaskId1--;
					continue;
				}
			if (soap_flag_TaskType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskType", &(a->ns5__RobotTaskState::TaskType), "xsd:string"))
				{	soap_flag_TaskType1--;
					continue;
				}
			if (soap_flag_TaskDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "TaskDesc", &(a->ns5__RobotTaskState::TaskDesc), "xsd:string"))
				{	soap_flag_TaskDesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotTaskState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotTaskState, 0, sizeof(ns5__RobotTaskState), 0, soap_copy_ns5__RobotTaskState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_TaskId1 > 0 || soap_flag_TaskType1 > 0 || soap_flag_TaskDesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__RobotTaskState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotTaskState);
	if (this->soap_out(soap, tag?tag:"ns5:RobotTaskState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotTaskState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotTaskState(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotTaskState * SOAP_FMAC4 soap_get_ns5__RobotTaskState(struct soap *soap, ns5__RobotTaskState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotTaskState * SOAP_FMAC2 soap_instantiate_ns5__RobotTaskState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotTaskState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotTaskState, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotTaskState);
		if (size)
			*size = sizeof(ns5__RobotTaskState);
		((ns5__RobotTaskState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotTaskState, n);
		if (size)
			*size = n * sizeof(ns5__RobotTaskState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotTaskState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotTaskState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotTaskState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotTaskState %p -> %p\n", q, p));
	*(ns5__RobotTaskState*)p = *(ns5__RobotTaskState*)q;
}

void ns5__SpeedInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__SpeedInfo(soap, &this->ns5__SpeedInfos::Infos);
	/* transient soap skipped */
}

void ns5__SpeedInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__SpeedInfo(soap, &this->ns5__SpeedInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__SpeedInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SpeedInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SpeedInfos(struct soap *soap, const char *tag, int id, const ns5__SpeedInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__SpeedInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__SpeedInfo(soap, "Infos", -1, &(a->ns5__SpeedInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__SpeedInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SpeedInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SpeedInfos * SOAP_FMAC4 soap_in_ns5__SpeedInfos(struct soap *soap, const char *tag, ns5__SpeedInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SpeedInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__SpeedInfos, sizeof(ns5__SpeedInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__SpeedInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__SpeedInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__SpeedInfo(soap, "Infos", &(a->ns5__SpeedInfos::Infos), "ns5:SpeedInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SpeedInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__SpeedInfos, 0, sizeof(ns5__SpeedInfos), 0, soap_copy_ns5__SpeedInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__SpeedInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__SpeedInfos);
	if (this->soap_out(soap, tag?tag:"ns5:SpeedInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SpeedInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SpeedInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SpeedInfos * SOAP_FMAC4 soap_get_ns5__SpeedInfos(struct soap *soap, ns5__SpeedInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SpeedInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__SpeedInfos * SOAP_FMAC2 soap_instantiate_ns5__SpeedInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SpeedInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__SpeedInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__SpeedInfos);
		if (size)
			*size = sizeof(ns5__SpeedInfos);
		((ns5__SpeedInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__SpeedInfos, n);
		if (size)
			*size = n * sizeof(ns5__SpeedInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__SpeedInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__SpeedInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__SpeedInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__SpeedInfos %p -> %p\n", q, p));
	*(ns5__SpeedInfos*)p = *(ns5__SpeedInfos*)q;
}

void ns5__SpeedInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__SpeedInfo::RobotIp);
	soap_default_double(soap, &this->ns5__SpeedInfo::Speed);
	/* transient soap skipped */
}

void ns5__SpeedInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__SpeedInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns5__SpeedInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SpeedInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SpeedInfo(struct soap *soap, const char *tag, int id, const ns5__SpeedInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__SpeedInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__SpeedInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "Speed", -1, &(a->ns5__SpeedInfo::Speed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__SpeedInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SpeedInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SpeedInfo * SOAP_FMAC4 soap_in_ns5__SpeedInfo(struct soap *soap, const char *tag, ns5__SpeedInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SpeedInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__SpeedInfo, sizeof(ns5__SpeedInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__SpeedInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__SpeedInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__SpeedInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Speed", &(a->ns5__SpeedInfo::Speed), "xsd:double"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SpeedInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__SpeedInfo, 0, sizeof(ns5__SpeedInfo), 0, soap_copy_ns5__SpeedInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_Speed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__SpeedInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__SpeedInfo);
	if (this->soap_out(soap, tag?tag:"ns5:SpeedInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SpeedInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SpeedInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SpeedInfo * SOAP_FMAC4 soap_get_ns5__SpeedInfo(struct soap *soap, ns5__SpeedInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__SpeedInfo * SOAP_FMAC2 soap_instantiate_ns5__SpeedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SpeedInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__SpeedInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__SpeedInfo);
		if (size)
			*size = sizeof(ns5__SpeedInfo);
		((ns5__SpeedInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__SpeedInfo, n);
		if (size)
			*size = n * sizeof(ns5__SpeedInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__SpeedInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__SpeedInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__SpeedInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__SpeedInfo %p -> %p\n", q, p));
	*(ns5__SpeedInfo*)p = *(ns5__SpeedInfo*)q;
}

void ns5__BatteryInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__BatteryInfo(soap, &this->ns5__BatteryInfos::Infos);
	/* transient soap skipped */
}

void ns5__BatteryInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__BatteryInfo(soap, &this->ns5__BatteryInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__BatteryInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__BatteryInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__BatteryInfos(struct soap *soap, const char *tag, int id, const ns5__BatteryInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__BatteryInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__BatteryInfo(soap, "Infos", -1, &(a->ns5__BatteryInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__BatteryInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__BatteryInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__BatteryInfos * SOAP_FMAC4 soap_in_ns5__BatteryInfos(struct soap *soap, const char *tag, ns5__BatteryInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__BatteryInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__BatteryInfos, sizeof(ns5__BatteryInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__BatteryInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__BatteryInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__BatteryInfo(soap, "Infos", &(a->ns5__BatteryInfos::Infos), "ns5:BatteryInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__BatteryInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__BatteryInfos, 0, sizeof(ns5__BatteryInfos), 0, soap_copy_ns5__BatteryInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__BatteryInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__BatteryInfos);
	if (this->soap_out(soap, tag?tag:"ns5:BatteryInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__BatteryInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__BatteryInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__BatteryInfos * SOAP_FMAC4 soap_get_ns5__BatteryInfos(struct soap *soap, ns5__BatteryInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__BatteryInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__BatteryInfos * SOAP_FMAC2 soap_instantiate_ns5__BatteryInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__BatteryInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__BatteryInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__BatteryInfos);
		if (size)
			*size = sizeof(ns5__BatteryInfos);
		((ns5__BatteryInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__BatteryInfos, n);
		if (size)
			*size = n * sizeof(ns5__BatteryInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__BatteryInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__BatteryInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__BatteryInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__BatteryInfos %p -> %p\n", q, p));
	*(ns5__BatteryInfos*)p = *(ns5__BatteryInfos*)q;
}

void ns5__BatteryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__BatteryInfo::RobotIp);
	soap_default_double(soap, &this->ns5__BatteryInfo::BatteryValue);
	soap_default_double(soap, &this->ns5__BatteryInfo::BatteryPercent);
	/* transient soap skipped */
}

void ns5__BatteryInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__BatteryInfo::RobotIp);
	/* transient soap skipped */
#endif
}

int ns5__BatteryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__BatteryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__BatteryInfo(struct soap *soap, const char *tag, int id, const ns5__BatteryInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__BatteryInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__BatteryInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_double(soap, "BatteryValue", -1, &(a->ns5__BatteryInfo::BatteryValue), ""))
		return soap->error;
	if (soap_out_double(soap, "BatteryPercent", -1, &(a->ns5__BatteryInfo::BatteryPercent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__BatteryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__BatteryInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__BatteryInfo * SOAP_FMAC4 soap_in_ns5__BatteryInfo(struct soap *soap, const char *tag, ns5__BatteryInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__BatteryInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__BatteryInfo, sizeof(ns5__BatteryInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__BatteryInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__BatteryInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_BatteryValue1 = 1;
	size_t soap_flag_BatteryPercent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__BatteryInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_BatteryValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BatteryValue", &(a->ns5__BatteryInfo::BatteryValue), "xsd:double"))
				{	soap_flag_BatteryValue1--;
					continue;
				}
			if (soap_flag_BatteryPercent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BatteryPercent", &(a->ns5__BatteryInfo::BatteryPercent), "xsd:double"))
				{	soap_flag_BatteryPercent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__BatteryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__BatteryInfo, 0, sizeof(ns5__BatteryInfo), 0, soap_copy_ns5__BatteryInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_BatteryValue1 > 0 || soap_flag_BatteryPercent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__BatteryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__BatteryInfo);
	if (this->soap_out(soap, tag?tag:"ns5:BatteryInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__BatteryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__BatteryInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__BatteryInfo * SOAP_FMAC4 soap_get_ns5__BatteryInfo(struct soap *soap, ns5__BatteryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__BatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__BatteryInfo * SOAP_FMAC2 soap_instantiate_ns5__BatteryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__BatteryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__BatteryInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__BatteryInfo);
		if (size)
			*size = sizeof(ns5__BatteryInfo);
		((ns5__BatteryInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__BatteryInfo, n);
		if (size)
			*size = n * sizeof(ns5__BatteryInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__BatteryInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__BatteryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__BatteryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__BatteryInfo %p -> %p\n", q, p));
	*(ns5__BatteryInfo*)p = *(ns5__BatteryInfo*)q;
}

void ns5__RobotInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__RobotInfo(soap, &this->ns5__RobotInfos::Infos);
	/* transient soap skipped */
}

void ns5__RobotInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__RobotInfo(soap, &this->ns5__RobotInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__RobotInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotInfos(struct soap *soap, const char *tag, int id, const ns5__RobotInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RobotInfo(soap, "Infos", -1, &(a->ns5__RobotInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotInfos * SOAP_FMAC4 soap_in_ns5__RobotInfos(struct soap *soap, const char *tag, ns5__RobotInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotInfos, sizeof(ns5__RobotInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__RobotInfo(soap, "Infos", &(a->ns5__RobotInfos::Infos), "ns5:RobotInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotInfos, 0, sizeof(ns5__RobotInfos), 0, soap_copy_ns5__RobotInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__RobotInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotInfos);
	if (this->soap_out(soap, tag?tag:"ns5:RobotInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotInfos * SOAP_FMAC4 soap_get_ns5__RobotInfos(struct soap *soap, ns5__RobotInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotInfos * SOAP_FMAC2 soap_instantiate_ns5__RobotInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotInfos);
		if (size)
			*size = sizeof(ns5__RobotInfos);
		((ns5__RobotInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotInfos, n);
		if (size)
			*size = n * sizeof(ns5__RobotInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotInfos %p -> %p\n", q, p));
	*(ns5__RobotInfos*)p = *(ns5__RobotInfos*)q;
}

void ns5__RobotInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__RobotInfo::RobotName);
	soap_default_std__string(soap, &this->ns5__RobotInfo::RobotIp);
	soap_default_std__string(soap, &this->ns5__RobotInfo::CameraIp);
	soap_default_int(soap, &this->ns5__RobotInfo::CameraPort);
	soap_default_std__string(soap, &this->ns5__RobotInfo::FlirIp);
	soap_default_int(soap, &this->ns5__RobotInfo::FlirPort);
	soap_default_std__string(soap, &this->ns5__RobotInfo::CameraUser);
	soap_default_std__string(soap, &this->ns5__RobotInfo::CameraPassword);
	soap_default_std__string(soap, &this->ns5__RobotInfo::FlirUser);
	soap_default_std__string(soap, &this->ns5__RobotInfo::FlirPassword);
	/* transient soap skipped */
}

void ns5__RobotInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__RobotInfo::RobotName);
	soap_serialize_std__string(soap, &this->ns5__RobotInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns5__RobotInfo::CameraIp);
	soap_serialize_std__string(soap, &this->ns5__RobotInfo::FlirIp);
	soap_serialize_std__string(soap, &this->ns5__RobotInfo::CameraUser);
	soap_serialize_std__string(soap, &this->ns5__RobotInfo::CameraPassword);
	soap_serialize_std__string(soap, &this->ns5__RobotInfo::FlirUser);
	soap_serialize_std__string(soap, &this->ns5__RobotInfo::FlirPassword);
	/* transient soap skipped */
#endif
}

int ns5__RobotInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RobotInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RobotInfo(struct soap *soap, const char *tag, int id, const ns5__RobotInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__RobotInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotName", -1, &(a->ns5__RobotInfo::RobotName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__RobotInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraIp", -1, &(a->ns5__RobotInfo::CameraIp), ""))
		return soap->error;
	if (soap_out_int(soap, "CameraPort", -1, &(a->ns5__RobotInfo::CameraPort), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirIp", -1, &(a->ns5__RobotInfo::FlirIp), ""))
		return soap->error;
	if (soap_out_int(soap, "FlirPort", -1, &(a->ns5__RobotInfo::FlirPort), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraUser", -1, &(a->ns5__RobotInfo::CameraUser), ""))
		return soap->error;
	if (soap_out_std__string(soap, "CameraPassword", -1, &(a->ns5__RobotInfo::CameraPassword), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirUser", -1, &(a->ns5__RobotInfo::FlirUser), ""))
		return soap->error;
	if (soap_out_std__string(soap, "FlirPassword", -1, &(a->ns5__RobotInfo::FlirPassword), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__RobotInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RobotInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RobotInfo * SOAP_FMAC4 soap_in_ns5__RobotInfo(struct soap *soap, const char *tag, ns5__RobotInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RobotInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__RobotInfo, sizeof(ns5__RobotInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__RobotInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RobotInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotName1 = 1;
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_CameraIp1 = 1;
	size_t soap_flag_CameraPort1 = 1;
	size_t soap_flag_FlirIp1 = 1;
	size_t soap_flag_FlirPort1 = 1;
	size_t soap_flag_CameraUser1 = 1;
	size_t soap_flag_CameraPassword1 = 1;
	size_t soap_flag_FlirUser1 = 1;
	size_t soap_flag_FlirPassword1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotName", &(a->ns5__RobotInfo::RobotName), "xsd:string"))
				{	soap_flag_RobotName1--;
					continue;
				}
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__RobotInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_CameraIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraIp", &(a->ns5__RobotInfo::CameraIp), "xsd:string"))
				{	soap_flag_CameraIp1--;
					continue;
				}
			if (soap_flag_CameraPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CameraPort", &(a->ns5__RobotInfo::CameraPort), "xsd:int"))
				{	soap_flag_CameraPort1--;
					continue;
				}
			if (soap_flag_FlirIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirIp", &(a->ns5__RobotInfo::FlirIp), "xsd:string"))
				{	soap_flag_FlirIp1--;
					continue;
				}
			if (soap_flag_FlirPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "FlirPort", &(a->ns5__RobotInfo::FlirPort), "xsd:int"))
				{	soap_flag_FlirPort1--;
					continue;
				}
			if (soap_flag_CameraUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraUser", &(a->ns5__RobotInfo::CameraUser), "xsd:string"))
				{	soap_flag_CameraUser1--;
					continue;
				}
			if (soap_flag_CameraPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "CameraPassword", &(a->ns5__RobotInfo::CameraPassword), "xsd:string"))
				{	soap_flag_CameraPassword1--;
					continue;
				}
			if (soap_flag_FlirUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirUser", &(a->ns5__RobotInfo::FlirUser), "xsd:string"))
				{	soap_flag_FlirUser1--;
					continue;
				}
			if (soap_flag_FlirPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FlirPassword", &(a->ns5__RobotInfo::FlirPassword), "xsd:string"))
				{	soap_flag_FlirPassword1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RobotInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__RobotInfo, 0, sizeof(ns5__RobotInfo), 0, soap_copy_ns5__RobotInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotName1 > 0 || soap_flag_RobotIp1 > 0 || soap_flag_CameraIp1 > 0 || soap_flag_CameraPort1 > 0 || soap_flag_FlirIp1 > 0 || soap_flag_FlirPort1 > 0 || soap_flag_CameraUser1 > 0 || soap_flag_CameraPassword1 > 0 || soap_flag_FlirUser1 > 0 || soap_flag_FlirPassword1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__RobotInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__RobotInfo);
	if (this->soap_out(soap, tag?tag:"ns5:RobotInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RobotInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RobotInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RobotInfo * SOAP_FMAC4 soap_get_ns5__RobotInfo(struct soap *soap, ns5__RobotInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RobotInfo * SOAP_FMAC2 soap_instantiate_ns5__RobotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RobotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__RobotInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__RobotInfo);
		if (size)
			*size = sizeof(ns5__RobotInfo);
		((ns5__RobotInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__RobotInfo, n);
		if (size)
			*size = n * sizeof(ns5__RobotInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__RobotInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__RobotInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RobotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RobotInfo %p -> %p\n", q, p));
	*(ns5__RobotInfo*)p = *(ns5__RobotInfo*)q;
}

void ns5__ConnectInfos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__ConnectInfo(soap, &this->ns5__ConnectInfos::Infos);
	/* transient soap skipped */
}

void ns5__ConnectInfos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__ConnectInfo(soap, &this->ns5__ConnectInfos::Infos);
	/* transient soap skipped */
#endif
}

int ns5__ConnectInfos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ConnectInfos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ConnectInfos(struct soap *soap, const char *tag, int id, const ns5__ConnectInfos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__ConnectInfos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ConnectInfo(soap, "Infos", -1, &(a->ns5__ConnectInfos::Infos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__ConnectInfos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ConnectInfos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ConnectInfos * SOAP_FMAC4 soap_in_ns5__ConnectInfos(struct soap *soap, const char *tag, ns5__ConnectInfos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ConnectInfos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__ConnectInfos, sizeof(ns5__ConnectInfos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__ConnectInfos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ConnectInfos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ConnectInfo(soap, "Infos", &(a->ns5__ConnectInfos::Infos), "ns5:ConnectInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ConnectInfos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__ConnectInfos, 0, sizeof(ns5__ConnectInfos), 0, soap_copy_ns5__ConnectInfos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ConnectInfos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__ConnectInfos);
	if (this->soap_out(soap, tag?tag:"ns5:ConnectInfos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ConnectInfos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ConnectInfos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ConnectInfos * SOAP_FMAC4 soap_get_ns5__ConnectInfos(struct soap *soap, ns5__ConnectInfos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ConnectInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ConnectInfos * SOAP_FMAC2 soap_instantiate_ns5__ConnectInfos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ConnectInfos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__ConnectInfos, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ConnectInfos);
		if (size)
			*size = sizeof(ns5__ConnectInfos);
		((ns5__ConnectInfos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ConnectInfos, n);
		if (size)
			*size = n * sizeof(ns5__ConnectInfos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__ConnectInfos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__ConnectInfos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ConnectInfos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ConnectInfos %p -> %p\n", q, p));
	*(ns5__ConnectInfos*)p = *(ns5__ConnectInfos*)q;
}

void ns5__ConnectInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__ConnectInfo::RobotIp);
	soap_default_bool(soap, &this->ns5__ConnectInfo::State);
	soap_default_std__string(soap, &this->ns5__ConnectInfo::ConnectDesc);
	/* transient soap skipped */
}

void ns5__ConnectInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns5__ConnectInfo::RobotIp);
	soap_serialize_std__string(soap, &this->ns5__ConnectInfo::ConnectDesc);
	/* transient soap skipped */
#endif
}

int ns5__ConnectInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ConnectInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ConnectInfo(struct soap *soap, const char *tag, int id, const ns5__ConnectInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_ns5__ConnectInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "RobotIp", -1, &(a->ns5__ConnectInfo::RobotIp), ""))
		return soap->error;
	if (soap_out_bool(soap, "State", -1, &(a->ns5__ConnectInfo::State), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ConnectDesc", -1, &(a->ns5__ConnectInfo::ConnectDesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__ConnectInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ConnectInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ConnectInfo * SOAP_FMAC4 soap_in_ns5__ConnectInfo(struct soap *soap, const char *tag, ns5__ConnectInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ConnectInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_ns5__ConnectInfo, sizeof(ns5__ConnectInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TaskFinish_ns5__ConnectInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ConnectInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RobotIp1 = 1;
	size_t soap_flag_State1 = 1;
	size_t soap_flag_ConnectDesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RobotIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RobotIp", &(a->ns5__ConnectInfo::RobotIp), "xsd:string"))
				{	soap_flag_RobotIp1--;
					continue;
				}
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "State", &(a->ns5__ConnectInfo::State), "xsd:boolean"))
				{	soap_flag_State1--;
					continue;
				}
			if (soap_flag_ConnectDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ConnectDesc", &(a->ns5__ConnectInfo::ConnectDesc), "xsd:string"))
				{	soap_flag_ConnectDesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ConnectInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_ns5__ConnectInfo, 0, sizeof(ns5__ConnectInfo), 0, soap_copy_ns5__ConnectInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RobotIp1 > 0 || soap_flag_State1 > 0 || soap_flag_ConnectDesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ConnectInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TaskFinish_ns5__ConnectInfo);
	if (this->soap_out(soap, tag?tag:"ns5:ConnectInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ConnectInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ConnectInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ConnectInfo * SOAP_FMAC4 soap_get_ns5__ConnectInfo(struct soap *soap, ns5__ConnectInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ConnectInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ConnectInfo * SOAP_FMAC2 soap_instantiate_ns5__ConnectInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ConnectInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_ns5__ConnectInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ConnectInfo);
		if (size)
			*size = sizeof(ns5__ConnectInfo);
		((ns5__ConnectInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ConnectInfo, n);
		if (size)
			*size = n * sizeof(ns5__ConnectInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__ConnectInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__ConnectInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ConnectInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ConnectInfo %p -> %p\n", q, p));
	*(ns5__ConnectInfo*)p = *(ns5__ConnectInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_SOAP_ENV__Fault, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_SOAP_ENV__Reason, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_SOAP_ENV__Detail, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_SOAP_ENV__Code, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TaskFinish_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TaskFinish_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_SOAP_ENV__Header, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTaskExcuteInfoByTaskId(struct soap *soap, struct __ns1__GetTaskExcuteInfoByTaskId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__GetTaskExcuteInfoByTaskId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTaskExcuteInfoByTaskId(struct soap *soap, const struct __ns1__GetTaskExcuteInfoByTaskId *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__GetTaskExcuteInfoByTaskId(soap, &a->ns5__GetTaskExcuteInfoByTaskId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTaskExcuteInfoByTaskId(struct soap *soap, const char *tag, int id, const struct __ns1__GetTaskExcuteInfoByTaskId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__GetTaskExcuteInfoByTaskId(soap, "ns5:GetTaskExcuteInfoByTaskId", -1, &a->ns5__GetTaskExcuteInfoByTaskId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskExcuteInfoByTaskId * SOAP_FMAC4 soap_in___ns1__GetTaskExcuteInfoByTaskId(struct soap *soap, const char *tag, struct __ns1__GetTaskExcuteInfoByTaskId *a, const char *type)
{
	size_t soap_flag_ns5__GetTaskExcuteInfoByTaskId = 1;
	short soap_flag;
	a = (struct __ns1__GetTaskExcuteInfoByTaskId *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskFinish___ns1__GetTaskExcuteInfoByTaskId, sizeof(struct __ns1__GetTaskExcuteInfoByTaskId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTaskExcuteInfoByTaskId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__GetTaskExcuteInfoByTaskId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__GetTaskExcuteInfoByTaskId(soap, "ns5:GetTaskExcuteInfoByTaskId", &a->ns5__GetTaskExcuteInfoByTaskId, ""))
				{	soap_flag_ns5__GetTaskExcuteInfoByTaskId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTaskExcuteInfoByTaskId(struct soap *soap, const struct __ns1__GetTaskExcuteInfoByTaskId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTaskExcuteInfoByTaskId(soap, tag?tag:"-ns1:GetTaskExcuteInfoByTaskId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskExcuteInfoByTaskId * SOAP_FMAC4 soap_get___ns1__GetTaskExcuteInfoByTaskId(struct soap *soap, struct __ns1__GetTaskExcuteInfoByTaskId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTaskExcuteInfoByTaskId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetTaskExcuteInfoByTaskId * SOAP_FMAC2 soap_instantiate___ns1__GetTaskExcuteInfoByTaskId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTaskExcuteInfoByTaskId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish___ns1__GetTaskExcuteInfoByTaskId, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetTaskExcuteInfoByTaskId);
		if (size)
			*size = sizeof(struct __ns1__GetTaskExcuteInfoByTaskId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetTaskExcuteInfoByTaskId, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetTaskExcuteInfoByTaskId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetTaskExcuteInfoByTaskId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTaskExcuteInfoByTaskId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTaskExcuteInfoByTaskId %p -> %p\n", q, p));
	*(struct __ns1__GetTaskExcuteInfoByTaskId*)p = *(struct __ns1__GetTaskExcuteInfoByTaskId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTaskFinishInfoByTime(struct soap *soap, struct __ns1__GetTaskFinishInfoByTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__GetTaskFinishInfoByTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTaskFinishInfoByTime(struct soap *soap, const struct __ns1__GetTaskFinishInfoByTime *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__GetTaskFinishInfoByTime(soap, &a->ns5__GetTaskFinishInfoByTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTaskFinishInfoByTime(struct soap *soap, const char *tag, int id, const struct __ns1__GetTaskFinishInfoByTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__GetTaskFinishInfoByTime(soap, "ns5:GetTaskFinishInfoByTime", -1, &a->ns5__GetTaskFinishInfoByTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskFinishInfoByTime * SOAP_FMAC4 soap_in___ns1__GetTaskFinishInfoByTime(struct soap *soap, const char *tag, struct __ns1__GetTaskFinishInfoByTime *a, const char *type)
{
	size_t soap_flag_ns5__GetTaskFinishInfoByTime = 1;
	short soap_flag;
	a = (struct __ns1__GetTaskFinishInfoByTime *)soap_id_enter(soap, "", a, SOAP_TYPE_TaskFinish___ns1__GetTaskFinishInfoByTime, sizeof(struct __ns1__GetTaskFinishInfoByTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTaskFinishInfoByTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__GetTaskFinishInfoByTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__GetTaskFinishInfoByTime(soap, "ns5:GetTaskFinishInfoByTime", &a->ns5__GetTaskFinishInfoByTime, ""))
				{	soap_flag_ns5__GetTaskFinishInfoByTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTaskFinishInfoByTime(struct soap *soap, const struct __ns1__GetTaskFinishInfoByTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTaskFinishInfoByTime(soap, tag?tag:"-ns1:GetTaskFinishInfoByTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskFinishInfoByTime * SOAP_FMAC4 soap_get___ns1__GetTaskFinishInfoByTime(struct soap *soap, struct __ns1__GetTaskFinishInfoByTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTaskFinishInfoByTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetTaskFinishInfoByTime * SOAP_FMAC2 soap_instantiate___ns1__GetTaskFinishInfoByTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTaskFinishInfoByTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish___ns1__GetTaskFinishInfoByTime, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetTaskFinishInfoByTime);
		if (size)
			*size = sizeof(struct __ns1__GetTaskFinishInfoByTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetTaskFinishInfoByTime, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetTaskFinishInfoByTime);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetTaskFinishInfoByTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTaskFinishInfoByTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTaskFinishInfoByTime %p -> %p\n", q, p));
	*(struct __ns1__GetTaskFinishInfoByTime*)p = *(struct __ns1__GetTaskFinishInfoByTime*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, _ns5__GetTaskExcuteInfoByTaskIdResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, const char *tag, int id, _ns5__GetTaskExcuteInfoByTaskIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__GetTaskExcuteInfoByTaskIdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, const char *tag, _ns5__GetTaskExcuteInfoByTaskIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetTaskExcuteInfoByTaskIdResponse **)soap_malloc(soap, sizeof(_ns5__GetTaskExcuteInfoByTaskIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetTaskExcuteInfoByTaskIdResponse *)soap_instantiate__ns5__GetTaskExcuteInfoByTaskIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__GetTaskExcuteInfoByTaskIdResponse ** p = (_ns5__GetTaskExcuteInfoByTaskIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskIdResponse, sizeof(_ns5__GetTaskExcuteInfoByTaskIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, _ns5__GetTaskExcuteInfoByTaskIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse);
	if (soap_out_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(soap, tag?tag:"ns5:GetTaskExcuteInfoByTaskIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetTaskExcuteInfoByTaskIdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(struct soap *soap, _ns5__GetTaskExcuteInfoByTaskIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetTaskExcuteInfoByTaskIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, _ns5__GetTaskExcuteInfoByTaskId *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, const char *tag, int id, _ns5__GetTaskExcuteInfoByTaskId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__GetTaskExcuteInfoByTaskId ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, const char *tag, _ns5__GetTaskExcuteInfoByTaskId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetTaskExcuteInfoByTaskId **)soap_malloc(soap, sizeof(_ns5__GetTaskExcuteInfoByTaskId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetTaskExcuteInfoByTaskId *)soap_instantiate__ns5__GetTaskExcuteInfoByTaskId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__GetTaskExcuteInfoByTaskId ** p = (_ns5__GetTaskExcuteInfoByTaskId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish__ns5__GetTaskExcuteInfoByTaskId, sizeof(_ns5__GetTaskExcuteInfoByTaskId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, _ns5__GetTaskExcuteInfoByTaskId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskExcuteInfoByTaskId);
	if (soap_out_PointerTo_ns5__GetTaskExcuteInfoByTaskId(soap, tag?tag:"ns5:GetTaskExcuteInfoByTaskId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetTaskExcuteInfoByTaskId ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetTaskExcuteInfoByTaskId(struct soap *soap, _ns5__GetTaskExcuteInfoByTaskId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetTaskExcuteInfoByTaskId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, _ns5__GetTaskFinishInfoByTimeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, const char *tag, int id, _ns5__GetTaskFinishInfoByTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__GetTaskFinishInfoByTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, const char *tag, _ns5__GetTaskFinishInfoByTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetTaskFinishInfoByTimeResponse **)soap_malloc(soap, sizeof(_ns5__GetTaskFinishInfoByTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetTaskFinishInfoByTimeResponse *)soap_instantiate__ns5__GetTaskFinishInfoByTimeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__GetTaskFinishInfoByTimeResponse ** p = (_ns5__GetTaskFinishInfoByTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTimeResponse, sizeof(_ns5__GetTaskFinishInfoByTimeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, _ns5__GetTaskFinishInfoByTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskFinishInfoByTimeResponse);
	if (soap_out_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(soap, tag?tag:"ns5:GetTaskFinishInfoByTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetTaskFinishInfoByTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(struct soap *soap, _ns5__GetTaskFinishInfoByTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetTaskFinishInfoByTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetTaskFinishInfoByTime(struct soap *soap, _ns5__GetTaskFinishInfoByTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetTaskFinishInfoByTime(struct soap *soap, const char *tag, int id, _ns5__GetTaskFinishInfoByTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__GetTaskFinishInfoByTime ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetTaskFinishInfoByTime(struct soap *soap, const char *tag, _ns5__GetTaskFinishInfoByTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetTaskFinishInfoByTime **)soap_malloc(soap, sizeof(_ns5__GetTaskFinishInfoByTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetTaskFinishInfoByTime *)soap_instantiate__ns5__GetTaskFinishInfoByTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__GetTaskFinishInfoByTime ** p = (_ns5__GetTaskFinishInfoByTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish__ns5__GetTaskFinishInfoByTime, sizeof(_ns5__GetTaskFinishInfoByTime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetTaskFinishInfoByTime(struct soap *soap, _ns5__GetTaskFinishInfoByTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTo_ns5__GetTaskFinishInfoByTime);
	if (soap_out_PointerTo_ns5__GetTaskFinishInfoByTime(soap, tag?tag:"ns5:GetTaskFinishInfoByTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetTaskFinishInfoByTime ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetTaskFinishInfoByTime(struct soap *soap, _ns5__GetTaskFinishInfoByTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetTaskFinishInfoByTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TaskExcuteInfos(struct soap *soap, ns5__TaskExcuteInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TaskExcuteInfos(struct soap *soap, const char *tag, int id, ns5__TaskExcuteInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TaskExcuteInfos ** SOAP_FMAC4 soap_in_PointerTons5__TaskExcuteInfos(struct soap *soap, const char *tag, ns5__TaskExcuteInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TaskExcuteInfos **)soap_malloc(soap, sizeof(ns5__TaskExcuteInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TaskExcuteInfos *)soap_instantiate_ns5__TaskExcuteInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__TaskExcuteInfos ** p = (ns5__TaskExcuteInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfos, sizeof(ns5__TaskExcuteInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TaskExcuteInfos(struct soap *soap, ns5__TaskExcuteInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__TaskExcuteInfos);
	if (soap_out_PointerTons5__TaskExcuteInfos(soap, tag?tag:"ns5:TaskExcuteInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__TaskExcuteInfos ** SOAP_FMAC4 soap_get_PointerTons5__TaskExcuteInfos(struct soap *soap, ns5__TaskExcuteInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TaskExcuteInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TaskFinishInfos(struct soap *soap, ns5__TaskFinishInfos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TaskFinishInfos(struct soap *soap, const char *tag, int id, ns5__TaskFinishInfos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TaskFinishInfos ** SOAP_FMAC4 soap_in_PointerTons5__TaskFinishInfos(struct soap *soap, const char *tag, ns5__TaskFinishInfos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TaskFinishInfos **)soap_malloc(soap, sizeof(ns5__TaskFinishInfos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TaskFinishInfos *)soap_instantiate_ns5__TaskFinishInfos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__TaskFinishInfos ** p = (ns5__TaskFinishInfos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfos, sizeof(ns5__TaskFinishInfos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TaskFinishInfos(struct soap *soap, ns5__TaskFinishInfos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__TaskFinishInfos);
	if (soap_out_PointerTons5__TaskFinishInfos(soap, tag?tag:"ns5:TaskFinishInfos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__TaskFinishInfos ** SOAP_FMAC4 soap_get_PointerTons5__TaskFinishInfos(struct soap *soap, ns5__TaskFinishInfos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TaskFinishInfos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TaskExcuteInfo(struct soap *soap, ns5__TaskExcuteInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TaskExcuteInfo(struct soap *soap, const char *tag, int id, ns5__TaskExcuteInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TaskExcuteInfo ** SOAP_FMAC4 soap_in_PointerTons5__TaskExcuteInfo(struct soap *soap, const char *tag, ns5__TaskExcuteInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TaskExcuteInfo **)soap_malloc(soap, sizeof(ns5__TaskExcuteInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TaskExcuteInfo *)soap_instantiate_ns5__TaskExcuteInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__TaskExcuteInfo ** p = (ns5__TaskExcuteInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo, sizeof(ns5__TaskExcuteInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TaskExcuteInfo(struct soap *soap, ns5__TaskExcuteInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__TaskExcuteInfo);
	if (soap_out_PointerTons5__TaskExcuteInfo(soap, tag?tag:"ns5:TaskExcuteInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__TaskExcuteInfo ** SOAP_FMAC4 soap_get_PointerTons5__TaskExcuteInfo(struct soap *soap, ns5__TaskExcuteInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TaskExcuteInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TaskFinishInfo(struct soap *soap, ns5__TaskFinishInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TaskFinishInfo(struct soap *soap, const char *tag, int id, ns5__TaskFinishInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TaskFinishInfo ** SOAP_FMAC4 soap_in_PointerTons5__TaskFinishInfo(struct soap *soap, const char *tag, ns5__TaskFinishInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TaskFinishInfo **)soap_malloc(soap, sizeof(ns5__TaskFinishInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TaskFinishInfo *)soap_instantiate_ns5__TaskFinishInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__TaskFinishInfo ** p = (ns5__TaskFinishInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo, sizeof(ns5__TaskFinishInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TaskFinishInfo(struct soap *soap, ns5__TaskFinishInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__TaskFinishInfo);
	if (soap_out_PointerTons5__TaskFinishInfo(soap, tag?tag:"ns5:TaskFinishInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__TaskFinishInfo ** SOAP_FMAC4 soap_get_PointerTons5__TaskFinishInfo(struct soap *soap, ns5__TaskFinishInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TaskFinishInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TaskPathInfo(struct soap *soap, ns5__TaskPathInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__TaskPathInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TaskPathInfo(struct soap *soap, const char *tag, int id, ns5__TaskPathInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__TaskPathInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TaskPathInfo ** SOAP_FMAC4 soap_in_PointerTons5__TaskPathInfo(struct soap *soap, const char *tag, ns5__TaskPathInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TaskPathInfo **)soap_malloc(soap, sizeof(ns5__TaskPathInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TaskPathInfo *)soap_instantiate_ns5__TaskPathInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__TaskPathInfo ** p = (ns5__TaskPathInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__TaskPathInfo, sizeof(ns5__TaskPathInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TaskPathInfo(struct soap *soap, ns5__TaskPathInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__TaskPathInfo);
	if (soap_out_PointerTons5__TaskPathInfo(soap, tag?tag:"ns5:TaskPathInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__TaskPathInfo ** SOAP_FMAC4 soap_get_PointerTons5__TaskPathInfo(struct soap *soap, ns5__TaskPathInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TaskPathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__PatrolPointInfo(struct soap *soap, ns5__PatrolPointInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__PatrolPointInfo(struct soap *soap, const char *tag, int id, ns5__PatrolPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__PatrolPointInfo ** SOAP_FMAC4 soap_in_PointerTons5__PatrolPointInfo(struct soap *soap, const char *tag, ns5__PatrolPointInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__PatrolPointInfo **)soap_malloc(soap, sizeof(ns5__PatrolPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__PatrolPointInfo *)soap_instantiate_ns5__PatrolPointInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__PatrolPointInfo ** p = (ns5__PatrolPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo, sizeof(ns5__PatrolPointInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__PatrolPointInfo(struct soap *soap, ns5__PatrolPointInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__PatrolPointInfo);
	if (soap_out_PointerTons5__PatrolPointInfo(soap, tag?tag:"ns5:PatrolPointInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__PatrolPointInfo ** SOAP_FMAC4 soap_get_PointerTons5__PatrolPointInfo(struct soap *soap, ns5__PatrolPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__PatrolPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DockPointInfo(struct soap *soap, ns5__DockPointInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__DockPointInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DockPointInfo(struct soap *soap, const char *tag, int id, ns5__DockPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__DockPointInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__DockPointInfo ** SOAP_FMAC4 soap_in_PointerTons5__DockPointInfo(struct soap *soap, const char *tag, ns5__DockPointInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__DockPointInfo **)soap_malloc(soap, sizeof(ns5__DockPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__DockPointInfo *)soap_instantiate_ns5__DockPointInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__DockPointInfo ** p = (ns5__DockPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__DockPointInfo, sizeof(ns5__DockPointInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DockPointInfo(struct soap *soap, ns5__DockPointInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__DockPointInfo);
	if (soap_out_PointerTons5__DockPointInfo(soap, tag?tag:"ns5:DockPointInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__DockPointInfo ** SOAP_FMAC4 soap_get_PointerTons5__DockPointInfo(struct soap *soap, ns5__DockPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DockPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__MapEdgeInfo(struct soap *soap, ns5__MapEdgeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__MapEdgeInfo(struct soap *soap, const char *tag, int id, ns5__MapEdgeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__MapEdgeInfo ** SOAP_FMAC4 soap_in_PointerTons5__MapEdgeInfo(struct soap *soap, const char *tag, ns5__MapEdgeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__MapEdgeInfo **)soap_malloc(soap, sizeof(ns5__MapEdgeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__MapEdgeInfo *)soap_instantiate_ns5__MapEdgeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__MapEdgeInfo ** p = (ns5__MapEdgeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo, sizeof(ns5__MapEdgeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__MapEdgeInfo(struct soap *soap, ns5__MapEdgeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__MapEdgeInfo);
	if (soap_out_PointerTons5__MapEdgeInfo(soap, tag?tag:"ns5:MapEdgeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__MapEdgeInfo ** SOAP_FMAC4 soap_get_PointerTons5__MapEdgeInfo(struct soap *soap, ns5__MapEdgeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__MapEdgeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__PatrolAreaInfo(struct soap *soap, ns5__PatrolAreaInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__PatrolAreaInfo(struct soap *soap, const char *tag, int id, ns5__PatrolAreaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__PatrolAreaInfo ** SOAP_FMAC4 soap_in_PointerTons5__PatrolAreaInfo(struct soap *soap, const char *tag, ns5__PatrolAreaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__PatrolAreaInfo **)soap_malloc(soap, sizeof(ns5__PatrolAreaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__PatrolAreaInfo *)soap_instantiate_ns5__PatrolAreaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__PatrolAreaInfo ** p = (ns5__PatrolAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo, sizeof(ns5__PatrolAreaInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__PatrolAreaInfo(struct soap *soap, ns5__PatrolAreaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__PatrolAreaInfo);
	if (soap_out_PointerTons5__PatrolAreaInfo(soap, tag?tag:"ns5:PatrolAreaInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__PatrolAreaInfo ** SOAP_FMAC4 soap_get_PointerTons5__PatrolAreaInfo(struct soap *soap, ns5__PatrolAreaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__PatrolAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__MapAreaInfo(struct soap *soap, ns5__MapAreaInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__MapAreaInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__MapAreaInfo(struct soap *soap, const char *tag, int id, ns5__MapAreaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__MapAreaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__MapAreaInfo ** SOAP_FMAC4 soap_in_PointerTons5__MapAreaInfo(struct soap *soap, const char *tag, ns5__MapAreaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__MapAreaInfo **)soap_malloc(soap, sizeof(ns5__MapAreaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__MapAreaInfo *)soap_instantiate_ns5__MapAreaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__MapAreaInfo ** p = (ns5__MapAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__MapAreaInfo, sizeof(ns5__MapAreaInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__MapAreaInfo(struct soap *soap, ns5__MapAreaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__MapAreaInfo);
	if (soap_out_PointerTons5__MapAreaInfo(soap, tag?tag:"ns5:MapAreaInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__MapAreaInfo ** SOAP_FMAC4 soap_get_PointerTons5__MapAreaInfo(struct soap *soap, ns5__MapAreaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__MapAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RobotAlarmInfo(struct soap *soap, ns5__RobotAlarmInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RobotAlarmInfo(struct soap *soap, const char *tag, int id, ns5__RobotAlarmInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RobotAlarmInfo ** SOAP_FMAC4 soap_in_PointerTons5__RobotAlarmInfo(struct soap *soap, const char *tag, ns5__RobotAlarmInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RobotAlarmInfo **)soap_malloc(soap, sizeof(ns5__RobotAlarmInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RobotAlarmInfo *)soap_instantiate_ns5__RobotAlarmInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__RobotAlarmInfo ** p = (ns5__RobotAlarmInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo, sizeof(ns5__RobotAlarmInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RobotAlarmInfo(struct soap *soap, ns5__RobotAlarmInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__RobotAlarmInfo);
	if (soap_out_PointerTons5__RobotAlarmInfo(soap, tag?tag:"ns5:RobotAlarmInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RobotAlarmInfo ** SOAP_FMAC4 soap_get_PointerTons5__RobotAlarmInfo(struct soap *soap, ns5__RobotAlarmInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RobotAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RobotGasInfo(struct soap *soap, ns5__RobotGasInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__RobotGasInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RobotGasInfo(struct soap *soap, const char *tag, int id, ns5__RobotGasInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__RobotGasInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RobotGasInfo ** SOAP_FMAC4 soap_in_PointerTons5__RobotGasInfo(struct soap *soap, const char *tag, ns5__RobotGasInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RobotGasInfo **)soap_malloc(soap, sizeof(ns5__RobotGasInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RobotGasInfo *)soap_instantiate_ns5__RobotGasInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__RobotGasInfo ** p = (ns5__RobotGasInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__RobotGasInfo, sizeof(ns5__RobotGasInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RobotGasInfo(struct soap *soap, ns5__RobotGasInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__RobotGasInfo);
	if (soap_out_PointerTons5__RobotGasInfo(soap, tag?tag:"ns5:RobotGasInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RobotGasInfo ** SOAP_FMAC4 soap_get_PointerTons5__RobotGasInfo(struct soap *soap, ns5__RobotGasInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RobotGasInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RobotMileageInfo(struct soap *soap, ns5__RobotMileageInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RobotMileageInfo(struct soap *soap, const char *tag, int id, ns5__RobotMileageInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RobotMileageInfo ** SOAP_FMAC4 soap_in_PointerTons5__RobotMileageInfo(struct soap *soap, const char *tag, ns5__RobotMileageInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RobotMileageInfo **)soap_malloc(soap, sizeof(ns5__RobotMileageInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RobotMileageInfo *)soap_instantiate_ns5__RobotMileageInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__RobotMileageInfo ** p = (ns5__RobotMileageInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo, sizeof(ns5__RobotMileageInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RobotMileageInfo(struct soap *soap, ns5__RobotMileageInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__RobotMileageInfo);
	if (soap_out_PointerTons5__RobotMileageInfo(soap, tag?tag:"ns5:RobotMileageInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RobotMileageInfo ** SOAP_FMAC4 soap_get_PointerTons5__RobotMileageInfo(struct soap *soap, ns5__RobotMileageInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RobotMileageInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RobotYunTaiInfo(struct soap *soap, ns5__RobotYunTaiInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, ns5__RobotYunTaiInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RobotYunTaiInfo ** SOAP_FMAC4 soap_in_PointerTons5__RobotYunTaiInfo(struct soap *soap, const char *tag, ns5__RobotYunTaiInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RobotYunTaiInfo **)soap_malloc(soap, sizeof(ns5__RobotYunTaiInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RobotYunTaiInfo *)soap_instantiate_ns5__RobotYunTaiInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__RobotYunTaiInfo ** p = (ns5__RobotYunTaiInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo, sizeof(ns5__RobotYunTaiInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RobotYunTaiInfo(struct soap *soap, ns5__RobotYunTaiInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__RobotYunTaiInfo);
	if (soap_out_PointerTons5__RobotYunTaiInfo(soap, tag?tag:"ns5:RobotYunTaiInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RobotYunTaiInfo ** SOAP_FMAC4 soap_get_PointerTons5__RobotYunTaiInfo(struct soap *soap, ns5__RobotYunTaiInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RobotYunTaiInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RobotPosInfo(struct soap *soap, ns5__RobotPosInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__RobotPosInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RobotPosInfo(struct soap *soap, const char *tag, int id, ns5__RobotPosInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__RobotPosInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RobotPosInfo ** SOAP_FMAC4 soap_in_PointerTons5__RobotPosInfo(struct soap *soap, const char *tag, ns5__RobotPosInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RobotPosInfo **)soap_malloc(soap, sizeof(ns5__RobotPosInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RobotPosInfo *)soap_instantiate_ns5__RobotPosInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__RobotPosInfo ** p = (ns5__RobotPosInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__RobotPosInfo, sizeof(ns5__RobotPosInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RobotPosInfo(struct soap *soap, ns5__RobotPosInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__RobotPosInfo);
	if (soap_out_PointerTons5__RobotPosInfo(soap, tag?tag:"ns5:RobotPosInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RobotPosInfo ** SOAP_FMAC4 soap_get_PointerTons5__RobotPosInfo(struct soap *soap, ns5__RobotPosInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RobotPosInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RobotTaskState(struct soap *soap, ns5__RobotTaskState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__RobotTaskState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RobotTaskState(struct soap *soap, const char *tag, int id, ns5__RobotTaskState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__RobotTaskState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RobotTaskState ** SOAP_FMAC4 soap_in_PointerTons5__RobotTaskState(struct soap *soap, const char *tag, ns5__RobotTaskState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RobotTaskState **)soap_malloc(soap, sizeof(ns5__RobotTaskState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RobotTaskState *)soap_instantiate_ns5__RobotTaskState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__RobotTaskState ** p = (ns5__RobotTaskState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__RobotTaskState, sizeof(ns5__RobotTaskState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RobotTaskState(struct soap *soap, ns5__RobotTaskState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__RobotTaskState);
	if (soap_out_PointerTons5__RobotTaskState(soap, tag?tag:"ns5:RobotTaskState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RobotTaskState ** SOAP_FMAC4 soap_get_PointerTons5__RobotTaskState(struct soap *soap, ns5__RobotTaskState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RobotTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SpeedInfo(struct soap *soap, ns5__SpeedInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__SpeedInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SpeedInfo(struct soap *soap, const char *tag, int id, ns5__SpeedInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__SpeedInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__SpeedInfo ** SOAP_FMAC4 soap_in_PointerTons5__SpeedInfo(struct soap *soap, const char *tag, ns5__SpeedInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SpeedInfo **)soap_malloc(soap, sizeof(ns5__SpeedInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SpeedInfo *)soap_instantiate_ns5__SpeedInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__SpeedInfo ** p = (ns5__SpeedInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__SpeedInfo, sizeof(ns5__SpeedInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SpeedInfo(struct soap *soap, ns5__SpeedInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__SpeedInfo);
	if (soap_out_PointerTons5__SpeedInfo(soap, tag?tag:"ns5:SpeedInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SpeedInfo ** SOAP_FMAC4 soap_get_PointerTons5__SpeedInfo(struct soap *soap, ns5__SpeedInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SpeedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__BatteryInfo(struct soap *soap, ns5__BatteryInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__BatteryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__BatteryInfo(struct soap *soap, const char *tag, int id, ns5__BatteryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__BatteryInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__BatteryInfo ** SOAP_FMAC4 soap_in_PointerTons5__BatteryInfo(struct soap *soap, const char *tag, ns5__BatteryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__BatteryInfo **)soap_malloc(soap, sizeof(ns5__BatteryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__BatteryInfo *)soap_instantiate_ns5__BatteryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__BatteryInfo ** p = (ns5__BatteryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__BatteryInfo, sizeof(ns5__BatteryInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__BatteryInfo(struct soap *soap, ns5__BatteryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__BatteryInfo);
	if (soap_out_PointerTons5__BatteryInfo(soap, tag?tag:"ns5:BatteryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__BatteryInfo ** SOAP_FMAC4 soap_get_PointerTons5__BatteryInfo(struct soap *soap, ns5__BatteryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__BatteryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RobotInfo(struct soap *soap, ns5__RobotInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__RobotInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RobotInfo(struct soap *soap, const char *tag, int id, ns5__RobotInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__RobotInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RobotInfo ** SOAP_FMAC4 soap_in_PointerTons5__RobotInfo(struct soap *soap, const char *tag, ns5__RobotInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RobotInfo **)soap_malloc(soap, sizeof(ns5__RobotInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RobotInfo *)soap_instantiate_ns5__RobotInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__RobotInfo ** p = (ns5__RobotInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__RobotInfo, sizeof(ns5__RobotInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RobotInfo(struct soap *soap, ns5__RobotInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__RobotInfo);
	if (soap_out_PointerTons5__RobotInfo(soap, tag?tag:"ns5:RobotInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RobotInfo ** SOAP_FMAC4 soap_get_PointerTons5__RobotInfo(struct soap *soap, ns5__RobotInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RobotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ConnectInfo(struct soap *soap, ns5__ConnectInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_TaskFinish_ns5__ConnectInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ConnectInfo(struct soap *soap, const char *tag, int id, ns5__ConnectInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TaskFinish_ns5__ConnectInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ConnectInfo ** SOAP_FMAC4 soap_in_PointerTons5__ConnectInfo(struct soap *soap, const char *tag, ns5__ConnectInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ConnectInfo **)soap_malloc(soap, sizeof(ns5__ConnectInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ConnectInfo *)soap_instantiate_ns5__ConnectInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__ConnectInfo ** p = (ns5__ConnectInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TaskFinish_ns5__ConnectInfo, sizeof(ns5__ConnectInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ConnectInfo(struct soap *soap, ns5__ConnectInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_PointerTons5__ConnectInfo);
	if (soap_out_PointerTons5__ConnectInfo(soap, tag?tag:"ns5:ConnectInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ConnectInfo ** SOAP_FMAC4 soap_get_PointerTons5__ConnectInfo(struct soap *soap, ns5__ConnectInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ConnectInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_TaskFinish__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_TaskFinish__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_TaskFinish__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_TaskFinish_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_TaskFinish_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_TaskFinish_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TaskFinish_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(struct soap *soap, std::vector<ns5__TaskExcuteInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(struct soap *soap, const std::vector<ns5__TaskExcuteInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__TaskExcuteInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__TaskExcuteInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__TaskExcuteInfo * >*a, const char *type)
{
	for (std::vector<ns5__TaskExcuteInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__TaskExcuteInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__TaskExcuteInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(struct soap *soap, const char *tag, std::vector<ns5__TaskExcuteInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__TaskExcuteInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__TaskExcuteInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskExcuteInfo, sizeof(ns5__TaskExcuteInfo), 1))
				break;
			if (!soap_in_PointerTons5__TaskExcuteInfo(soap, tag, NULL, "ns5:TaskExcuteInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__TaskExcuteInfo(soap, tag, &n, "ns5:TaskExcuteInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__TaskExcuteInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskExcuteInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__TaskExcuteInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__TaskExcuteInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__TaskExcuteInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__TaskExcuteInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__TaskExcuteInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__TaskExcuteInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__TaskExcuteInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__TaskExcuteInfo * >*)p = *(std::vector<ns5__TaskExcuteInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__TaskFinishInfo(struct soap *soap, std::vector<ns5__TaskFinishInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__TaskFinishInfo(struct soap *soap, const std::vector<ns5__TaskFinishInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__TaskFinishInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__TaskFinishInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__TaskFinishInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__TaskFinishInfo * >*a, const char *type)
{
	for (std::vector<ns5__TaskFinishInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__TaskFinishInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__TaskFinishInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__TaskFinishInfo(struct soap *soap, const char *tag, std::vector<ns5__TaskFinishInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__TaskFinishInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__TaskFinishInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskFinishInfo, sizeof(ns5__TaskFinishInfo), 1))
				break;
			if (!soap_in_PointerTons5__TaskFinishInfo(soap, tag, NULL, "ns5:TaskFinishInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__TaskFinishInfo(soap, tag, &n, "ns5:TaskFinishInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__TaskFinishInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__TaskFinishInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__TaskFinishInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__TaskFinishInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskFinishInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__TaskFinishInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__TaskFinishInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__TaskFinishInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__TaskFinishInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__TaskFinishInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__TaskFinishInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__TaskFinishInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__TaskFinishInfo * >*)p = *(std::vector<ns5__TaskFinishInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__TaskPathInfo(struct soap *soap, std::vector<ns5__TaskPathInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__TaskPathInfo(struct soap *soap, const std::vector<ns5__TaskPathInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__TaskPathInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__TaskPathInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__TaskPathInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__TaskPathInfo * >*a, const char *type)
{
	for (std::vector<ns5__TaskPathInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__TaskPathInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__TaskPathInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__TaskPathInfo(struct soap *soap, const char *tag, std::vector<ns5__TaskPathInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__TaskPathInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__TaskPathInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskPathInfo, sizeof(ns5__TaskPathInfo), 1))
				break;
			if (!soap_in_PointerTons5__TaskPathInfo(soap, tag, NULL, "ns5:TaskPathInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__TaskPathInfo(soap, tag, &n, "ns5:TaskPathInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__TaskPathInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__TaskPathInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__TaskPathInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__TaskPathInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__TaskPathInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__TaskPathInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__TaskPathInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__TaskPathInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__TaskPathInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__TaskPathInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__TaskPathInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__TaskPathInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__TaskPathInfo * >*)p = *(std::vector<ns5__TaskPathInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__PatrolPointInfo(struct soap *soap, std::vector<ns5__PatrolPointInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__PatrolPointInfo(struct soap *soap, const std::vector<ns5__PatrolPointInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__PatrolPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__PatrolPointInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__PatrolPointInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__PatrolPointInfo * >*a, const char *type)
{
	for (std::vector<ns5__PatrolPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__PatrolPointInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__PatrolPointInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__PatrolPointInfo(struct soap *soap, const char *tag, std::vector<ns5__PatrolPointInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__PatrolPointInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__PatrolPointInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolPointInfo, sizeof(ns5__PatrolPointInfo), 1))
				break;
			if (!soap_in_PointerTons5__PatrolPointInfo(soap, tag, NULL, "ns5:PatrolPointInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__PatrolPointInfo(soap, tag, &n, "ns5:PatrolPointInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__PatrolPointInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__PatrolPointInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__PatrolPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__PatrolPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolPointInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__PatrolPointInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__PatrolPointInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__PatrolPointInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__PatrolPointInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__PatrolPointInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__PatrolPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__PatrolPointInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__PatrolPointInfo * >*)p = *(std::vector<ns5__PatrolPointInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__DockPointInfo(struct soap *soap, std::vector<ns5__DockPointInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__DockPointInfo(struct soap *soap, const std::vector<ns5__DockPointInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__DockPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__DockPointInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__DockPointInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__DockPointInfo * >*a, const char *type)
{
	for (std::vector<ns5__DockPointInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__DockPointInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__DockPointInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__DockPointInfo(struct soap *soap, const char *tag, std::vector<ns5__DockPointInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__DockPointInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__DockPointInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__DockPointInfo, sizeof(ns5__DockPointInfo), 1))
				break;
			if (!soap_in_PointerTons5__DockPointInfo(soap, tag, NULL, "ns5:DockPointInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__DockPointInfo(soap, tag, &n, "ns5:DockPointInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__DockPointInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__DockPointInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__DockPointInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__DockPointInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__DockPointInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__DockPointInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__DockPointInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__DockPointInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__DockPointInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__DockPointInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__DockPointInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__DockPointInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__DockPointInfo * >*)p = *(std::vector<ns5__DockPointInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_std__string(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_std__string, SOAP_TYPE_TaskFinish_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfstd__string, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__MapEdgeInfo(struct soap *soap, std::vector<ns5__MapEdgeInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__MapEdgeInfo(struct soap *soap, const std::vector<ns5__MapEdgeInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__MapEdgeInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__MapEdgeInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__MapEdgeInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__MapEdgeInfo * >*a, const char *type)
{
	for (std::vector<ns5__MapEdgeInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__MapEdgeInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__MapEdgeInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__MapEdgeInfo(struct soap *soap, const char *tag, std::vector<ns5__MapEdgeInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__MapEdgeInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__MapEdgeInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapEdgeInfo, sizeof(ns5__MapEdgeInfo), 1))
				break;
			if (!soap_in_PointerTons5__MapEdgeInfo(soap, tag, NULL, "ns5:MapEdgeInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__MapEdgeInfo(soap, tag, &n, "ns5:MapEdgeInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__MapEdgeInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__MapEdgeInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__MapEdgeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__MapEdgeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapEdgeInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__MapEdgeInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__MapEdgeInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__MapEdgeInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__MapEdgeInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__MapEdgeInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__MapEdgeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__MapEdgeInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__MapEdgeInfo * >*)p = *(std::vector<ns5__MapEdgeInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(struct soap *soap, std::vector<ns5__PatrolAreaInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(struct soap *soap, const std::vector<ns5__PatrolAreaInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__PatrolAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__PatrolAreaInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__PatrolAreaInfo * >*a, const char *type)
{
	for (std::vector<ns5__PatrolAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__PatrolAreaInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__PatrolAreaInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(struct soap *soap, const char *tag, std::vector<ns5__PatrolAreaInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__PatrolAreaInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__PatrolAreaInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolAreaInfo, sizeof(ns5__PatrolAreaInfo), 1))
				break;
			if (!soap_in_PointerTons5__PatrolAreaInfo(soap, tag, NULL, "ns5:PatrolAreaInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__PatrolAreaInfo(soap, tag, &n, "ns5:PatrolAreaInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__PatrolAreaInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__PatrolAreaInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__PatrolAreaInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__PatrolAreaInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__PatrolAreaInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__PatrolAreaInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__PatrolAreaInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__PatrolAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__PatrolAreaInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__PatrolAreaInfo * >*)p = *(std::vector<ns5__PatrolAreaInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__MapAreaInfo(struct soap *soap, std::vector<ns5__MapAreaInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__MapAreaInfo(struct soap *soap, const std::vector<ns5__MapAreaInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__MapAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__MapAreaInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__MapAreaInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__MapAreaInfo * >*a, const char *type)
{
	for (std::vector<ns5__MapAreaInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__MapAreaInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__MapAreaInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__MapAreaInfo(struct soap *soap, const char *tag, std::vector<ns5__MapAreaInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__MapAreaInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__MapAreaInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapAreaInfo, sizeof(ns5__MapAreaInfo), 1))
				break;
			if (!soap_in_PointerTons5__MapAreaInfo(soap, tag, NULL, "ns5:MapAreaInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__MapAreaInfo(soap, tag, &n, "ns5:MapAreaInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__MapAreaInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__MapAreaInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__MapAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__MapAreaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__MapAreaInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__MapAreaInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__MapAreaInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__MapAreaInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__MapAreaInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__MapAreaInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__MapAreaInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__MapAreaInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__MapAreaInfo * >*)p = *(std::vector<ns5__MapAreaInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(struct soap *soap, std::vector<ns5__RobotAlarmInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(struct soap *soap, const std::vector<ns5__RobotAlarmInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RobotAlarmInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RobotAlarmInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__RobotAlarmInfo * >*a, const char *type)
{
	for (std::vector<ns5__RobotAlarmInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RobotAlarmInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RobotAlarmInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(struct soap *soap, const char *tag, std::vector<ns5__RobotAlarmInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__RobotAlarmInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__RobotAlarmInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotAlarmInfo, sizeof(ns5__RobotAlarmInfo), 1))
				break;
			if (!soap_in_PointerTons5__RobotAlarmInfo(soap, tag, NULL, "ns5:RobotAlarmInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__RobotAlarmInfo(soap, tag, &n, "ns5:RobotAlarmInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RobotAlarmInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotAlarmInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__RobotAlarmInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__RobotAlarmInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__RobotAlarmInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__RobotAlarmInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__RobotAlarmInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__RobotAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__RobotAlarmInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__RobotAlarmInfo * >*)p = *(std::vector<ns5__RobotAlarmInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RobotGasInfo(struct soap *soap, std::vector<ns5__RobotGasInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RobotGasInfo(struct soap *soap, const std::vector<ns5__RobotGasInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RobotGasInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RobotGasInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RobotGasInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__RobotGasInfo * >*a, const char *type)
{
	for (std::vector<ns5__RobotGasInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RobotGasInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RobotGasInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RobotGasInfo(struct soap *soap, const char *tag, std::vector<ns5__RobotGasInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__RobotGasInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__RobotGasInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotGasInfo, sizeof(ns5__RobotGasInfo), 1))
				break;
			if (!soap_in_PointerTons5__RobotGasInfo(soap, tag, NULL, "ns5:RobotGasInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__RobotGasInfo(soap, tag, &n, "ns5:RobotGasInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RobotGasInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RobotGasInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RobotGasInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RobotGasInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotGasInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__RobotGasInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__RobotGasInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__RobotGasInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__RobotGasInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__RobotGasInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__RobotGasInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__RobotGasInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__RobotGasInfo * >*)p = *(std::vector<ns5__RobotGasInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RobotMileageInfo(struct soap *soap, std::vector<ns5__RobotMileageInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RobotMileageInfo(struct soap *soap, const std::vector<ns5__RobotMileageInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RobotMileageInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RobotMileageInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RobotMileageInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__RobotMileageInfo * >*a, const char *type)
{
	for (std::vector<ns5__RobotMileageInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RobotMileageInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RobotMileageInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RobotMileageInfo(struct soap *soap, const char *tag, std::vector<ns5__RobotMileageInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__RobotMileageInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__RobotMileageInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotMileageInfo, sizeof(ns5__RobotMileageInfo), 1))
				break;
			if (!soap_in_PointerTons5__RobotMileageInfo(soap, tag, NULL, "ns5:RobotMileageInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__RobotMileageInfo(soap, tag, &n, "ns5:RobotMileageInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RobotMileageInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RobotMileageInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RobotMileageInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RobotMileageInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotMileageInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__RobotMileageInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__RobotMileageInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__RobotMileageInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__RobotMileageInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__RobotMileageInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__RobotMileageInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__RobotMileageInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__RobotMileageInfo * >*)p = *(std::vector<ns5__RobotMileageInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(struct soap *soap, std::vector<ns5__RobotYunTaiInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(struct soap *soap, const std::vector<ns5__RobotYunTaiInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RobotYunTaiInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RobotYunTaiInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__RobotYunTaiInfo * >*a, const char *type)
{
	for (std::vector<ns5__RobotYunTaiInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RobotYunTaiInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RobotYunTaiInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(struct soap *soap, const char *tag, std::vector<ns5__RobotYunTaiInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__RobotYunTaiInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__RobotYunTaiInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo, sizeof(ns5__RobotYunTaiInfo), 1))
				break;
			if (!soap_in_PointerTons5__RobotYunTaiInfo(soap, tag, NULL, "ns5:RobotYunTaiInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__RobotYunTaiInfo(soap, tag, &n, "ns5:RobotYunTaiInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RobotYunTaiInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__RobotYunTaiInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__RobotYunTaiInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__RobotYunTaiInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__RobotYunTaiInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__RobotYunTaiInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__RobotYunTaiInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__RobotYunTaiInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__RobotYunTaiInfo * >*)p = *(std::vector<ns5__RobotYunTaiInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RobotPosInfo(struct soap *soap, std::vector<ns5__RobotPosInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RobotPosInfo(struct soap *soap, const std::vector<ns5__RobotPosInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RobotPosInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RobotPosInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RobotPosInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__RobotPosInfo * >*a, const char *type)
{
	for (std::vector<ns5__RobotPosInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RobotPosInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RobotPosInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RobotPosInfo(struct soap *soap, const char *tag, std::vector<ns5__RobotPosInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__RobotPosInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__RobotPosInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotPosInfo, sizeof(ns5__RobotPosInfo), 1))
				break;
			if (!soap_in_PointerTons5__RobotPosInfo(soap, tag, NULL, "ns5:RobotPosInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__RobotPosInfo(soap, tag, &n, "ns5:RobotPosInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RobotPosInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RobotPosInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RobotPosInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RobotPosInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotPosInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__RobotPosInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__RobotPosInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__RobotPosInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__RobotPosInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__RobotPosInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__RobotPosInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__RobotPosInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__RobotPosInfo * >*)p = *(std::vector<ns5__RobotPosInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RobotTaskState(struct soap *soap, std::vector<ns5__RobotTaskState * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RobotTaskState(struct soap *soap, const std::vector<ns5__RobotTaskState * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RobotTaskState * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RobotTaskState(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RobotTaskState(struct soap *soap, const char *tag, int id, const std::vector<ns5__RobotTaskState * >*a, const char *type)
{
	for (std::vector<ns5__RobotTaskState * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RobotTaskState(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RobotTaskState * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RobotTaskState(struct soap *soap, const char *tag, std::vector<ns5__RobotTaskState * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__RobotTaskState *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__RobotTaskState, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotTaskState, sizeof(ns5__RobotTaskState), 1))
				break;
			if (!soap_in_PointerTons5__RobotTaskState(soap, tag, NULL, "ns5:RobotTaskState"))
				break;
		}
		else if (!soap_in_PointerTons5__RobotTaskState(soap, tag, &n, "ns5:RobotTaskState"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RobotTaskState(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RobotTaskState * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RobotTaskState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RobotTaskState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotTaskState, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__RobotTaskState * >);
		if (size)
			*size = sizeof(std::vector<ns5__RobotTaskState * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__RobotTaskState * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__RobotTaskState * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__RobotTaskState * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__RobotTaskState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__RobotTaskState * > %p -> %p\n", q, p));
	*(std::vector<ns5__RobotTaskState * >*)p = *(std::vector<ns5__RobotTaskState * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__SpeedInfo(struct soap *soap, std::vector<ns5__SpeedInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__SpeedInfo(struct soap *soap, const std::vector<ns5__SpeedInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__SpeedInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__SpeedInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__SpeedInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__SpeedInfo * >*a, const char *type)
{
	for (std::vector<ns5__SpeedInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__SpeedInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__SpeedInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__SpeedInfo(struct soap *soap, const char *tag, std::vector<ns5__SpeedInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__SpeedInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__SpeedInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__SpeedInfo, sizeof(ns5__SpeedInfo), 1))
				break;
			if (!soap_in_PointerTons5__SpeedInfo(soap, tag, NULL, "ns5:SpeedInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__SpeedInfo(soap, tag, &n, "ns5:SpeedInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__SpeedInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__SpeedInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__SpeedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__SpeedInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__SpeedInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__SpeedInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__SpeedInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__SpeedInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__SpeedInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__SpeedInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__SpeedInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__SpeedInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__SpeedInfo * >*)p = *(std::vector<ns5__SpeedInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__BatteryInfo(struct soap *soap, std::vector<ns5__BatteryInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__BatteryInfo(struct soap *soap, const std::vector<ns5__BatteryInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__BatteryInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__BatteryInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__BatteryInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__BatteryInfo * >*a, const char *type)
{
	for (std::vector<ns5__BatteryInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__BatteryInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__BatteryInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__BatteryInfo(struct soap *soap, const char *tag, std::vector<ns5__BatteryInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__BatteryInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__BatteryInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__BatteryInfo, sizeof(ns5__BatteryInfo), 1))
				break;
			if (!soap_in_PointerTons5__BatteryInfo(soap, tag, NULL, "ns5:BatteryInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__BatteryInfo(soap, tag, &n, "ns5:BatteryInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__BatteryInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__BatteryInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__BatteryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__BatteryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__BatteryInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__BatteryInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__BatteryInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__BatteryInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__BatteryInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__BatteryInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__BatteryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__BatteryInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__BatteryInfo * >*)p = *(std::vector<ns5__BatteryInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RobotInfo(struct soap *soap, std::vector<ns5__RobotInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RobotInfo(struct soap *soap, const std::vector<ns5__RobotInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RobotInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RobotInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RobotInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__RobotInfo * >*a, const char *type)
{
	for (std::vector<ns5__RobotInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RobotInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RobotInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RobotInfo(struct soap *soap, const char *tag, std::vector<ns5__RobotInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__RobotInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__RobotInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotInfo, sizeof(ns5__RobotInfo), 1))
				break;
			if (!soap_in_PointerTons5__RobotInfo(soap, tag, NULL, "ns5:RobotInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__RobotInfo(soap, tag, &n, "ns5:RobotInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RobotInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RobotInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RobotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RobotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__RobotInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__RobotInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__RobotInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__RobotInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__RobotInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__RobotInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__RobotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__RobotInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__RobotInfo * >*)p = *(std::vector<ns5__RobotInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ConnectInfo(struct soap *soap, std::vector<ns5__ConnectInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ConnectInfo(struct soap *soap, const std::vector<ns5__ConnectInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ConnectInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ConnectInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ConnectInfo(struct soap *soap, const char *tag, int id, const std::vector<ns5__ConnectInfo * >*a, const char *type)
{
	for (std::vector<ns5__ConnectInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ConnectInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ConnectInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ConnectInfo(struct soap *soap, const char *tag, std::vector<ns5__ConnectInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__ConnectInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TaskFinish_ns5__ConnectInfo, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__ConnectInfo, sizeof(ns5__ConnectInfo), 1))
				break;
			if (!soap_in_PointerTons5__ConnectInfo(soap, tag, NULL, "ns5:ConnectInfo"))
				break;
		}
		else if (!soap_in_PointerTons5__ConnectInfo(soap, tag, &n, "ns5:ConnectInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ConnectInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ConnectInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__ConnectInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__ConnectInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TaskFinish_std__vectorTemplateOfPointerTons5__ConnectInfo, n, TaskFinish_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__ConnectInfo * >);
		if (size)
			*size = sizeof(std::vector<ns5__ConnectInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__ConnectInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__ConnectInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__ConnectInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__ConnectInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__ConnectInfo * > %p -> %p\n", q, p));
	*(std::vector<ns5__ConnectInfo * >*)p = *(std::vector<ns5__ConnectInfo * >*)q;
}

} // namespace TaskFinish


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of TaskFinishC.cpp */
